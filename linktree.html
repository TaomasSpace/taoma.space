<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TAOMA™ — Linktree</title>
    <meta
      name="description"
      content="TAOMA™ Linktree: zentrale Anlaufstelle für alle TAOMA Links, Socials und Projekte."
    />
    <meta property="og:title" content="TAOMA™ — Linktree" />
    <meta
      property="og:description"
      content="Alle TAOMA Links, Socials und Projekte auf einen Blick."
    />
    <meta property="og:type" content="profile" />
    <meta property="og:url" content="https://taoma.space/linktree" />
    <meta property="og:image" content="https://taoma.space/static/icon.png" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="TAOMA™ — Linktree" />
    <meta
      name="twitter:description"
      content="Alle TAOMA Links, Socials und Projekte auf einen Blick."
    />
    <meta name="twitter:image" content="https://taoma.space/static/icon.png" />
    <link rel="canonical" href="https://taoma.space/linktree" />
    <meta name="robots" content="index,follow" />
    <meta name="theme-color" content="#0f1223" />
    <link rel="icon" type="image/png" href="/static/icon.png" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "ProfilePage",
        "url": "https://taoma.space/linktree",
        "name": "TAOMA Linktree",
        "inLanguage": "de",
        "about": "Zentrale Links und Projekte von TAOMA",
        "breadcrumb": "Home > Linktree"
      }
    </script>
    <style>
      :root {
        --bg: #0e1020;
        --ink: #e9ebff;
        --muted: #a2a9c8;
        --acc: #85a3ff;
        --card: #171b3b;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        --radius: 16px;
        --link-color: #e9ebff;
        --link-bg: #171b3b;
        --link-bg-hover: color-mix(in oklab, #171b3b, white 4%);
        --name-color: #e9ebff;
        --location-color: #a2a9c8;
        --quote-color: #e9ebff;
        --cursor: auto;
      }

      body {
        margin: 0;
        font: 15px/1.6 Inter, ui-sans-serif, system-ui;
        color: var(--ink);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background: var(--bg);
        overflow-x: hidden;
        cursor: var(--cursor, auto);
      }

      html,
      body,
      a,
      button,
      .link {
        cursor: var(--cursor, auto);
      }

      /* Background video/image */
      .bg {
        position: fixed;
        inset: 0;
        z-index: -1;
        overflow: hidden;
      }

      .bg img,
      .bg video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: 3rem 1rem;
      }

      .pfp-wrap {
        position: relative;
        width: 110px;
        height: 110px;
        margin: 0 auto 7px;
        display: grid;
        place-items: center;
      }

      .pfp {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: 3px solid #fff3;
        box-shadow: var(--shadow);
        object-fit: cover;
        max-width: 100%;
        max-height: 100%;
        position: relative;
        z-index: 1;
      }

      .pfp-frame {
        position: absolute;
        inset: -4px;
        width: calc(100% + 8px);
        height: calc(100% + 8px);
        object-fit: contain;
        pointer-events: none;
        z-index: 2;
      }

      .discord-presence {
        position: absolute;
        right: 4px;
        bottom: 4px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 3px solid rgba(15, 18, 35, 0.9);
        box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.25);
        background: #8a90a8;
        z-index: 3;
      }

      .discord-presence.hidden {
        display: none;
      }

      .discord-presence.status-online {
        background: #23a559;
      }

      .discord-presence.status-idle {
        background: #f0b232;
      }

      .discord-presence.status-dnd {
        background: #f23f43;
      }

      .discord-presence.status-offline {
        background: #8a90a8;
      }

      .discord-status {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.45rem;
        font-size: 0.95rem;
        color: var(--muted);
        margin-bottom: 0.6rem;
      }

      .discord-status.hidden {
        display: none;
      }

      .discord-status .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #8a90a8;
      }

      .discord-status.status-online .dot {
        background: #23a559;
      }

      .discord-status.status-idle .dot {
        background: #f0b232;
      }

      .discord-status.status-dnd .dot {
        background: #f23f43;
      }

      .discord-status.status-offline .dot {
        background: #8a90a8;
      }

      .discord-status .text {
        font-weight: 600;
      }

      .discord-badges {
        display: flex;
        gap: 0.45rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 1.4rem;
      }

      .discord-badges.hidden {
        display: none;
      }

      .discord-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.25rem 0.6rem;
        border-radius: 999px;
        background: #ffffff14;
        border: 1px solid #ffffff26;
        font-size: 0.75rem;
        font-weight: 700;
        color: var(--ink);
      }

      .discord-badge img {
        width: 28px;
        height: 28px;
        object-fit: contain;
        display: block;
      }

      .audio-player {
        width: 100%;
        max-width: 420px;
        margin: 0 auto 1.5rem;
        padding: 0.8rem 1rem;
        box-sizing: border-box;
        border-radius: 14px;
        background: var(--audio-bg, rgba(23, 27, 59, 0.6));
        border: 1px solid var(--audio-border, #ffffff26);
        box-shadow: var(--shadow);
        display: grid;
        gap: 0.55rem;
        text-align: left;
        color: var(--audio-text, var(--ink));
      }

      .audio-player.hidden {
        display: none;
      }

      .audio-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.85rem;
        color: var(--audio-muted, var(--muted));
        gap: 0.5rem;
      }

      .audio-title-wrap {
        display: flex;
        align-items: center;
        gap: 0.45rem;
        min-width: 0;
      }

      .audio-icon {
        width: 50px;
        height: 50px;
        border-radius: 6px;
        object-fit: cover;
        display: block;
      }

      .audio-icon.hidden {
        display: none;
      }

      .audio-title {
        font-weight: 700;
        color: var(--audio-text, var(--ink));
      }

      .audio-seek {
        width: 100%;
        accent-color: var(--audio-accent, var(--acc));
      }

      .audio-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .audio-btn {
        border: 1px solid #ffffff26;
        background: var(--audio-btn-bg, #ffffff14);
        color: var(--audio-text, var(--ink));
        border-radius: 999px;
        padding: 0.35rem 0.7rem;
        font-weight: 700;
        cursor: var(--cursor, pointer);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        min-width: 42px;
      }

      .audio-btn.primary {
        background: var(--audio-accent, var(--acc));
        color: var(--audio-accent-ink, #0e1020);
        border-color: color-mix(
          in oklab,
          var(--audio-accent, var(--acc)) 65%,
          #000
        );
      }

      .audio-btn svg {
        width: 16px;
        height: 16px;
      }

      .audio-btn .icon-pause {
        display: none;
      }

      .audio-btn.is-playing .icon-pause {
        display: block;
      }

      .audio-btn.is-playing .icon-play {
        display: none;
      }

      .name {
        font-size: 1.8rem;
        font-weight: 800;
        margin: 1rem 0 0.5rem;
        color: var(--name-color);
      }

      .location {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        justify-content: center;
        color: var(--location-color);
        margin-bottom: 1rem;
      }

      .quote {
        font-style: italic;
        color: var(--quote-color);
        margin-bottom: 1.5rem;
        max-width: 600px;
      }

      .badges {
        display: flex;
        gap: 0.4rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 2rem;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        /* kein Platz für Text nötig */
        background: #ffffff1a;
        border-radius: 999px;
        padding: 0.28rem;
        /* nur wenig Innenabstand */
        border: 1px solid #ffffff26;
        /* dezente Kante, optional */
      }

      .badge img {
        width: 20px;
        height: 20px;
        object-fit: contain;
        display: block;
      }

      .links {
        display: grid;
        gap: 12px;
        width: 100%;
        max-width: 420px;
        margin: 0 auto;
        /* <- zentriert die Liste innerhalb der Karte */
      }

      .visit-counter {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        margin: 1rem auto 0;
        padding: 0.55rem 0.9rem;
        border-radius: 999px;
        background: #ffffff14;
        color: var(--ink);
        font-weight: 600;
        border: 1px solid #ffffff26;
        box-shadow: var(--shadow);
      }

      .visit-counter svg {
        width: 18px;
        height: 18px;
      }

      .link {
        position: relative;
        /* für das absolut positionierte Icon */
        display: flex;
        align-items: center;
        justify-content: center;
        /* zentriert den Inhalt */
        text-align: center;
        gap: 0.6rem;
        padding: 0.9rem 1.2rem;
        border-radius: var(--radius);
        background: var(--link-bg);
        border: 1px solid #ffffff22;
        box-shadow: var(--shadow);
        transition: 0.2s;
        width: 100%;
        color: var(--link-color);
        /* volle Breite für schöne Pillenform */
      }

      .link:hover {
        transform: translateY(-2px);
        background: var(--link-bg-hover);
      }

      .link img {
        width: 35px;
        height: 35px;
        object-fit: contain;
        position: absolute;
        left: 14px;
        top: 50%;
        transform: translateY(-50%);
      }

      .link span {
        margin: 0 auto;
      }

      footer {
        padding: 1rem;
        text-align: center;
        font-size: 0.85rem;
        color: var(--muted);
      }

      footer a {
        color: inherit;
        font-weight: 700;
      }

      footer a:hover {
        text-decoration: underline;
      }

      .sound-toggle {
        position: fixed;
        right: 14px;
        bottom: 16px;
        z-index: 10;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.45rem 0.6rem;
        border-radius: 999px;
        background: #ffffff1a;
        color: var(--ink);
        border: 1px solid #ffffff33;
        box-shadow: var(--shadow);
        font-weight: 700;
        user-select: none;
        cursor: var(--cursor, pointer);
        backdrop-filter: blur(6px) saturate(1.2);
      }

      .sound-toggle.hidden {
        display: none;
      }

      .sound-toggle .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #ff6b6b;
      }

      .sound-toggle.on .dot {
        background: #1dd1a1;
      }

      .enter-gate {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(6px);
        background: rgba(0, 0, 0, 0.35);
        z-index: 9;
        transition: opacity 0.2s ease;
      }

      .enter-gate.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .enter-box {
        padding: 1rem 1.4rem;
        border-radius: 14px;
        background: rgba(15, 18, 35, 0.85);
        border: 1px solid #ffffff33;
        box-shadow: var(--shadow);
        color: var(--ink);
        text-align: center;
        min-width: 220px;
        cursor: var(--cursor, pointer);
        user-select: none;
      }

      .enter-box p {
        margin: 0 0 0.25rem;
        font-weight: 800;
        letter-spacing: 0.2px;
      }

      /* Name Effects */
      .name.glow {
        text-shadow: 0 0 8px color-mix(in oklab, currentColor 70%, transparent),
          0 0 12px color-mix(in oklab, currentColor 55%, transparent),
          0 0 18px color-mix(in oklab, currentColor 40%, transparent);
      }

      .name.neon {
        text-shadow: 0 0 6px color-mix(in oklab, currentColor 80%, transparent),
          0 0 14px color-mix(in oklab, currentColor 60%, transparent),
          0 0 24px color-mix(in oklab, currentColor 50%, transparent);
        filter: drop-shadow(
          0 0 10px color-mix(in oklab, currentColor 45%, transparent)
        );
      }

      .name.rainbow {
        background: linear-gradient(
          90deg,
          red,
          orange,
          yellow,
          green,
          cyan,
          blue,
          violet
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow 3s linear infinite;
      }

      @keyframes rainbow {
        0% {
          background-position: 0% 50%;
        }

        100% {
          background-position: 100% 50%;
        }
      }

      /* Background Effects */
      .bg.night::after {
        content: "";
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 50, 0.4);
        mix-blend-mode: multiply;
      }

      .bg.rain::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: url("/static/effects/rain.gif");
        background-size: cover;
        opacity: 0.4;
        pointer-events: none;
      }

      .bg.snow::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: url("/static/effects/snow.gif");
        background-size: cover;
        opacity: 0.5;
        pointer-events: none;
      }

      .card {
        background: rgba(23, 27, 59, var(--card-alpha, 0.8));
        /* Default 80% deckend */
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 2rem 2rem;
        max-width: 600px;
        width: 100%;
        backdrop-filter: blur(12px);
      }

      .card.transparent {
        background: transparent;
        backdrop-filter: none;
        box-shadow: none;
      }

      /* === Mobile Optimierungen === */
      /* Verhindere horizontales Scrollen */
      html,
      body {
        max-width: 100vw;
        overflow-x: hidden;
      }

      body {
        padding: 0;
        margin: 0;
      }

      /* Main Container */
      main {
        padding: 2rem 1rem;
        max-width: 100vw;
        overflow-x: hidden;
        box-sizing: border-box;
      }

      /* Card responsive */
      .card {
        background: rgba(23, 27, 59, var(--card-alpha, 0.8));
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 1.5rem 1rem;
        max-width: 600px;
        width: calc(100% - 2rem);
        /* Berücksichtigt main padding */
        backdrop-filter: blur(12px);
        box-sizing: border-box;
        margin: 0 auto;
      }

      /* Profilbild */
      .pfp {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        border: 3px solid #fff3;
        box-shadow: var(--shadow);
        object-fit: cover;
        flex-shrink: 0;
      }

      /* Name - lange Namen umbrechen */
      .name {
        font-size: clamp(1.4rem, 5vw, 1.8rem);
        font-weight: 800;
        margin: 1rem 0 0.5rem;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        max-width: 100%;
      }

      /* Location */
      .location {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        justify-content: center;
        color: var(--muted);
        margin-bottom: 1rem;
        flex-wrap: wrap;
        word-wrap: break-word;
        max-width: 100%;
      }

      .location.hidden {
        display: none;
      }

      /* Quote - lange Texte */
      .quote {
        font-style: italic;
        margin-bottom: 1.5rem;
        max-width: 100%;
        word-wrap: break-word;
        overflow-wrap: break-word;
        padding: 0 0.5rem;
        box-sizing: border-box;
      }

      /* Badges responsive */
      .badges {
        display: flex;
        gap: 0.4rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 2rem;
        padding: 0 0.5rem;
        max-width: 100%;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        background: #ffffff1a;
        border-radius: 999px;
        padding: 0.28rem;
        border: 1px solid #ffffff26;
        flex-shrink: 0;
      }

      .badge img {
        width: 20px;
        height: 20px;
        object-fit: contain;
        display: block;
      }

      /* Links Container */
      .links {
        display: grid;
        gap: 12px;
        width: 100%;
        max-width: 420px;
        margin: 0 auto;
        padding: 0;
        box-sizing: border-box;
      }

      /* Link Items */
      .link {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        gap: 0.6rem;
        padding: 0.9rem 1.2rem;
        border-radius: var(--radius);
        background: var(--link-bg);
        border: 1px solid #ffffff22;
        box-shadow: var(--shadow);
        transition: 0.2s;
        width: 100%;
        box-sizing: border-box;
        min-height: 48px;
        /* Touch-friendly Mindesthöhe */
        overflow: hidden;
        /* Verhindert Overflow */
        color: var(--link-color);
      }

      .link:hover {
        transform: translateY(-2px);
        background: var(--link-bg-hover);
      }

      /* Link Icon */
      .link img {
        width: 32px;
        height: 32px;
        object-fit: contain;
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        flex-shrink: 0;
      }

      /* Link Text */
      .link span {
        margin: 0 auto;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        max-width: calc(100% - 80px);
        /* Platz für Icon + Padding */
        padding: 0 0.5rem;
      }

      /* Footer */
      footer {
        padding: 1rem;
        text-align: center;
        font-size: 0.85rem;
        color: var(--muted);
        max-width: 100vw;
        overflow-x: hidden;
      }

      /* Sound Toggle Button */
      .sound-toggle {
        position: fixed;
        right: 12px;
        bottom: 14px;
        z-index: 10;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.45rem 0.6rem;
        border-radius: 999px;
        background: #ffffff1a;
        color: var(--ink);
        border: 1px solid #ffffff33;
        box-shadow: var(--shadow);
        font-weight: 700;
        user-select: none;
        cursor: var(--cursor, pointer);
        backdrop-filter: blur(6px) saturate(1.2);
        font-size: 0.85rem;
      }

      /* === Responsive Breakpoints === */
      /* Tablets und kleine Laptops */
      @media (max-width: 768px) {
        main {
          padding: 1.5rem 0.8rem;
        }

        .card {
          padding: 1.2rem 0.8rem;
          width: calc(100% - 1.6rem);
        }

        .name {
          font-size: clamp(1.3rem, 4.5vw, 1.6rem);
        }

        .quote {
          font-size: 0.95rem;
          padding: 0 0.3rem;
        }

        .links {
          max-width: 400px;
          gap: 10px;
        }

        .link {
          padding: 0.8rem 1rem;
        }
      }

      /* Smartphones */
      @media (max-width: 480px) {
        main {
          padding: 1rem 0.5rem;
        }

        .card {
          padding: 1rem 0.6rem;
          width: calc(100% - 1rem);
          border-radius: 12px;
        }

        .pfp {
          width: 90px;
          height: 90px;
        }

        .name {
          font-size: clamp(1.2rem, 6vw, 1.5rem);
          margin: 0.8rem 0 0.4rem;
        }

        .location {
          font-size: 0.9rem;
          margin-bottom: 0.8rem;
        }

        .location svg {
          width: 14px;
          height: 14px;
        }

        .quote {
          font-size: 0.9rem;
          margin-bottom: 1rem;
          padding: 0;
          line-height: 1.5;
        }

        .badges {
          gap: 0.3rem;
          margin-bottom: 1.5rem;
          padding: 0;
        }

        .badge {
          padding: 0.25rem;
        }

        .badge img {
          width: 18px;
          height: 18px;
        }

        .links {
          max-width: 100%;
          gap: 10px;
          padding: 0 0.25rem;
        }

        .link {
          padding: 0.75rem 0.8rem;
          border-radius: 14px;
          min-height: 52px;
        }

        .link img {
          width: 28px;
          height: 28px;
          left: 10px;
        }

        .link span {
          font-size: 0.9rem;
          max-width: calc(100% - 60px);
          padding: 0 0.3rem;
        }

        .sound-toggle {
          right: 10px;
          bottom: 12px;
          padding: 0.4rem 0.5rem;
          font-size: 0.8rem;
        }

        .sound-toggle .dot {
          width: 7px;
          height: 7px;
        }

        .audio-player {
          padding: 0.7rem 0.8rem;
          margin-bottom: 1.2rem;
        }

        .audio-meta {
          font-size: 0.8rem;
        }

        .audio-title {
          font-size: 0.85rem;
        }

        .discord-presence {
          width: 16px;
          height: 16px;
          border-width: 2px;
        }

        footer {
          padding: 0.8rem 0.5rem;
          font-size: 0.8rem;
        }
        .pfp-wrap {
          width: 100px;
          height: 100px;
        }
      }

      /* Sehr kleine Smartphones */
      @media (max-width: 360px) {
        .card {
          padding: 0.8rem 0.5rem;
        }

        .pfp {
          width: 80px;
          height: 80px;
        }

        .name {
          font-size: 1.2rem;
        }

        .quote {
          font-size: 0.85rem;
        }

        .link {
          padding: 0.7rem 0.7rem;
          min-height: 48px;
        }

        .link img {
          width: 24px;
          height: 24px;
        }

        .link span {
          font-size: 0.85rem;
          max-width: calc(100% - 50px);
        }
      }

      /* Landscape-Modus für Smartphones */
      @media (max-height: 500px) and (orientation: landscape) {
        main {
          padding: 1rem 0.5rem;
        }

        .pfp {
          width: 70px;
          height: 70px;
        }

        .name {
          font-size: 1.3rem;
          margin: 0.5rem 0 0.3rem;
        }

        .quote {
          margin-bottom: 0.8rem;
        }

        .badges {
          margin-bottom: 1rem;
        }

        .link {
          padding: 0.6rem 0.8rem;
          min-height: 44px;
        }
      }

      /* Background anpassen */
      .bg {
        position: fixed;
        inset: 0;
        z-index: -1;
        overflow: hidden;
        max-width: 100vw;
      }

      .bg img,
      .bg video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        max-width: 100vw;
      }

      /* Lange URLs in Links kürzen */
      @media (max-width: 480px) {
        .link span {
          overflow: hidden;
          text-overflow: ellipsis;
          display: -webkit-box;
          -webkit-line-clamp: 2;
          line-clamp: 2;
          /* Max 2 Zeilen */
          -webkit-box-orient: vertical;
        }
      }
    </style>
  </head>

  <body>
    <div class="bg" id="bg"></div>
    <div
      id="enterOverlay"
      class="enter-gate hidden"
      role="button"
      tabindex="0"
      aria-label="Enter site to enable media"
    >
      <div class="enter-box">
        <p>Click to enter</p>
        <span class="muted">Enable video & sound</span>
      </div>
    </div>
    <button id="soundBtn" class="sound-toggle hidden" aria-label="Toggle sound">
      <span class="dot" aria-hidden="true"></span>
      <span id="soundLabel">Sound off</span>
    </button>
    <main>
      <div class="card" id="card">
        <div class="pfp-wrap">
          <img
            id="pfp"
            class="pfp"
            src="/static/icon.png"
            loading="lazy"
            decoding="async"
            alt="Profile picture"
          />
          <img
            id="pfpFrame"
            class="pfp-frame"
            src=""
            alt=""
            loading="lazy"
            decoding="async"
            style="display: none"
          />
          <span
            id="discordPresence"
            class="discord-presence hidden"
            role="img"
            aria-label="Discord status"
          ></span>
        </div>
        <div id="name" class="name">User</div>
        <div id="discordStatusLine" class="discord-status hidden">
          <span class="dot" aria-hidden="true"></span>
          <span id="discordStatusText" class="text"></span>
        </div>
        <div id="quote" class="quote">-</div>
        <div class="location" id="loc"></div>
        <div class="discord-badges hidden" id="discordBadges"></div>
        <div class="badges" id="badges"></div>

        <div id="audioPlayer" class="audio-player hidden">
          <div class="audio-meta">
            <div class="audio-title-wrap">
              <img
                id="audioIcon"
                class="audio-icon hidden"
                alt=""
                loading="lazy"
                decoding="async"
              />
              <span id="audioTitle" class="audio-title">Audio</span>
            </div>
            <span id="audioTime" class="audio-time">0:00 / 0:00</span>
          </div>
          <input
            id="audioSeek"
            class="audio-seek"
            type="range"
            min="0"
            max="0"
            value="0"
          />
          <div class="audio-controls">
            <button
              id="audioBack"
              class="audio-btn"
              type="button"
              aria-label="Back 10 seconds"
            >
              <svg viewBox="0 0 24 24" aria-hidden="true" fill="currentColor">
                <path d="M11 18V6l-6 6 6 6zM19 18V6l-6 6 6 6z" />
              </svg>
            </button>
            <button
              id="audioPlay"
              class="audio-btn primary"
              type="button"
              aria-label="Play or pause"
            >
              <svg
                class="icon-play"
                viewBox="0 0 24 24"
                aria-hidden="true"
                fill="currentColor"
              >
                <path d="M8 5v14l11-7z" />
              </svg>
              <svg
                class="icon-pause"
                viewBox="0 0 24 24"
                aria-hidden="true"
                fill="currentColor"
              >
                <path d="M6 5h4v14H6zm8 0h4v14h-4z" />
              </svg>
            </button>
            <button
              id="audioForward"
              class="audio-btn"
              type="button"
              aria-label="Forward 10 seconds"
            >
              <svg viewBox="0 0 24 24" aria-hidden="true" fill="currentColor">
                <path d="M13 6v12l6-6-6-6zM5 6v12l6-6-6-6z" />
              </svg>
            </button>
          </div>
        </div>
        <div class="links" id="links"></div>
        <div id="visitCounter" class="visit-counter" style="display: none">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
            />
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
            />
          </svg>
          <span id="visitCounterValue">0</span>
        </div>
      </div>
    </main>

    <footer>© <span id="year"></span> TAOMA™</footer>

    <script>
      async function resizeCursorImage(url, size = 32) {
        return new Promise((resolve, reject) => {
          const img = new Image();

          img.crossOrigin = "anonymous"; // Wichtig, falls das PNG von deiner Domain kommt
          img.onload = () => {
            // Canvas erstellen
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;

            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, size, size);

            // Bild proportional skalieren
            const scale = Math.min(size / img.width, size / img.height);
            const w = img.width * scale;
            const h = img.height * scale;

            const x = (size - w) / 2;
            const y = (size - h) / 2;

            ctx.drawImage(img, x, y, w, h);

            // Base64 URL erzeugen
            const resizedUrl = canvas.toDataURL("image/png");
            resolve(resizedUrl);
          };

          img.onerror = reject;
          img.src = url;
        });
      }

      (() => {
        "use strict";

        const yearEl = document.getElementById("year");
        if (yearEl) yearEl.textContent = new Date().getFullYear();

        const soundBtn = document.getElementById("soundBtn");
        const soundLabel = document.getElementById("soundLabel");
        const audioPlayer = document.getElementById("audioPlayer");
        const audioIcon = document.getElementById("audioIcon");
        const audioTitle = document.getElementById("audioTitle");
        const audioTime = document.getElementById("audioTime");
        const audioSeek = document.getElementById("audioSeek");
        const audioPlayBtn = document.getElementById("audioPlay");
        const audioBackBtn = document.getElementById("audioBack");
        const audioForwardBtn = document.getElementById("audioForward");
        let bgVideo = null;
        let bgAudio = null;
        let soundOn = false;
        let gateActive = false;
        let audioSeekActive = false;
        let audioCleanup = null;

        function safeUrl(
          raw,
          { allowRelative = true, allowedProtocols = ["http:", "https:"] } = {}
        ) {
          if (typeof raw !== "string") return "";
          const trimmed = raw.trim();
          if (!trimmed) return "";
          if (/^javascript:/i.test(trimmed)) return "";
          try {
            const parsed = new URL(trimmed, window.location.origin);
            if (allowedProtocols.includes(parsed.protocol)) {
              if (
                (parsed.protocol === "http:" || parsed.protocol === "https:") &&
                !trimmed.startsWith("http") &&
                allowRelative
              ) {
                return trimmed;
              }
              return parsed.href;
            }
          } catch (_) {
            if (
              allowRelative &&
              trimmed.startsWith("/") &&
              !trimmed.startsWith("//")
            ) {
              return trimmed;
            }
          }
          if (
            allowRelative &&
            trimmed.startsWith("/") &&
            !trimmed.startsWith("//")
          ) {
            return trimmed;
          }
          return "";
        }

        const safeMediaUrl = (raw) =>
          safeUrl(raw, {
            allowRelative: true,
            allowedProtocols: ["http:", "https:"],
          });

        function hexToRgba(hex, alpha = 1) {
          const m = /^#?([a-fA-F0-9]{3}|[a-fA-F0-9]{6})$/.exec(
            (hex || "").trim()
          );
          if (!m) return null;
          let h = m[1];
          if (h.length === 3)
            h = h
              .split("")
              .map((c) => c + c)
              .join("");
          const int = parseInt(h, 16);
          const r = (int >> 16) & 255;
          const g = (int >> 8) & 255;
          const b = int & 255;
          const a = Math.min(1, Math.max(0, alpha));
          return `rgba(${r}, ${g}, ${b}, ${a})`;
        }
        const safeLinkUrl = (raw) =>
          safeUrl(raw, {
            allowRelative: false,
            allowedProtocols: ["http:", "https:", "mailto:", "tel:"],
          });

        const VIDEO_EXTENSIONS = [".mp4", ".webm", ".m4v", ".mov"];
        const looksLikeVideo = (url) =>
          VIDEO_EXTENSIONS.some((ext) =>
            (url || "").toLowerCase().includes(ext)
          );

        function pickBackgroundSource(data, preferLite) {
          const primary = safeMediaUrl(data.background_url);
          const low =
            preferLite &&
            (safeMediaUrl(data.background_low_url) ||
              safeMediaUrl(data.background_preview_url) ||
              null);
          const chosen = (low || primary || "").trim();
          const isVideo = looksLikeVideo(chosen) || !!data.background_is_video;
          const useVideo =
            isVideo && !(preferLite && low && !looksLikeVideo(low));
          return { url: chosen, isVideo: useVideo };
        }

        const DEFAULT_LINK_COLOR = "#e9ebff";
        const DEFAULT_LINK_BG = "#171b3b";
        const DEFAULT_CARD_COLOR = "#171b3b";
        const DEFAULT_TEXT_COLOR = "#e9ebff";
        const DEFAULT_NAME_COLOR = "#e9ebff";
        const DEFAULT_LOCATION_COLOR = "#a2a9c8";
        const DEFAULT_QUOTE_COLOR = "#e9ebff";
        const DEFAULT_AUDIO_BG_COLOR = "#171b3b";
        const DEFAULT_AUDIO_BG_ALPHA = 60;
        const DEFAULT_AUDIO_TEXT_COLOR = "#e9ebff";
        const DEFAULT_AUDIO_ACCENT_COLOR = "#85a3ff";

        function sanitizeHexColor(raw) {
          if (typeof raw !== "string") return "";
          const trimmed = raw.trim();
          return /^#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(trimmed)
            ? trimmed
            : "";
        }

        function hexToRgb(hex) {
          const clean = sanitizeHexColor(hex);
          if (!clean) return null;
          const raw = clean.slice(1);
          const parts =
            raw.length === 3
              ? raw.split("").map((ch) => ch + ch)
              : [raw.slice(0, 2), raw.slice(2, 4), raw.slice(4, 6)];
          const [r, g, b] = parts.map((p) => parseInt(p, 16));
          return { r, g, b };
        }

        function rgbToRgba(rgb, alpha = 1) {
          if (!rgb) return "";
          const a = Math.min(1, Math.max(0, alpha));
          return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})`;
        }

        function lightenRgb(rgb, amount = 0.08) {
          const t = Math.min(1, Math.max(0, amount));
          return {
            r: Math.round(rgb.r + (255 - rgb.r) * t),
            g: Math.round(rgb.g + (255 - rgb.g) * t),
            b: Math.round(rgb.b + (255 - rgb.b) * t),
          };
        }

        function applyLinkStyles(linkColorRaw, linkBgRaw, linkBgAlphaRaw) {
          const rootStyle = document.documentElement.style;
          const linkColor =
            sanitizeHexColor(linkColorRaw) || DEFAULT_LINK_COLOR;
          const bgHex = sanitizeHexColor(linkBgRaw) || DEFAULT_LINK_BG;
          const bgRgb = hexToRgb(bgHex) || hexToRgb(DEFAULT_LINK_BG);
          const alpha =
            Math.min(100, Math.max(0, Number(linkBgAlphaRaw ?? 100))) / 100;
          const base = rgbToRgba(bgRgb, alpha);
          const hover = rgbToRgba(lightenRgb(bgRgb, 0.07), alpha);
          rootStyle.setProperty("--link-color", linkColor);
          rootStyle.setProperty("--link-bg", base || DEFAULT_LINK_BG);
          rootStyle.setProperty(
            "--link-bg-hover",
            hover || base || DEFAULT_LINK_BG
          );
        }

        function applyTextColors(data) {
          const rootStyle = document.documentElement.style;
          const base = sanitizeHexColor(data?.text_color) || DEFAULT_TEXT_COLOR;
          const location =
            sanitizeHexColor(data?.location_color) ||
            sanitizeHexColor(data?.text_color) ||
            DEFAULT_LOCATION_COLOR;
          const name =
            sanitizeHexColor(data?.name_color) ||
            sanitizeHexColor(data?.link_color) ||
            DEFAULT_NAME_COLOR;
          const quote =
            sanitizeHexColor(data?.quote_color) || base || DEFAULT_QUOTE_COLOR;

          rootStyle.setProperty("--ink", base);
          rootStyle.setProperty("--muted", location);
          rootStyle.setProperty("--name-color", name);
          rootStyle.setProperty("--location-color", location);
          rootStyle.setProperty("--quote-color", quote);
        }

        function applyAudioPlayerStyles(data) {
          if (!audioPlayer) return;
          const bgHex =
            sanitizeHexColor(data?.audio_player_bg_color) ||
            DEFAULT_AUDIO_BG_COLOR;
          const bgRgb = hexToRgb(bgHex) || hexToRgb(DEFAULT_AUDIO_BG_COLOR);
          const rawAlpha = Number(data?.audio_player_bg_alpha);
          const alpha = Number.isFinite(rawAlpha)
            ? Math.min(100, Math.max(0, rawAlpha))
            : DEFAULT_AUDIO_BG_ALPHA;
          const bg = bgRgb ? rgbToRgba(bgRgb, alpha / 100) : "";
          const border = bgRgb
            ? rgbToRgba(
                lightenRgb(bgRgb, 0.12),
                Math.min(1, alpha / 100 + 0.12)
              )
            : "";
          const btnBg = bgRgb
            ? rgbToRgba(lightenRgb(bgRgb, 0.08), Math.min(1, alpha / 100 + 0.1))
            : "";
          const textHex =
            sanitizeHexColor(data?.audio_player_text_color) ||
            sanitizeHexColor(data?.text_color) ||
            DEFAULT_AUDIO_TEXT_COLOR;
          const textRgb =
            hexToRgb(textHex) || hexToRgb(DEFAULT_AUDIO_TEXT_COLOR);
          const muted = textRgb ? rgbToRgba(textRgb, 0.72) : "";
          const accentHex =
            sanitizeHexColor(data?.audio_player_accent_color) ||
            sanitizeHexColor(data?.link_color) ||
            DEFAULT_AUDIO_ACCENT_COLOR;

          if (bg) audioPlayer.style.setProperty("--audio-bg", bg);
          if (border) audioPlayer.style.setProperty("--audio-border", border);
          if (btnBg) audioPlayer.style.setProperty("--audio-btn-bg", btnBg);
          if (textHex) audioPlayer.style.setProperty("--audio-text", textHex);
          if (muted) audioPlayer.style.setProperty("--audio-muted", muted);
          if (accentHex)
            audioPlayer.style.setProperty("--audio-accent", accentHex);
        }

        function createLocationIcon() {
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg"
          );
          svg.setAttribute("width", "16");
          svg.setAttribute("height", "16");
          svg.setAttribute("viewBox", "0 0 24 24");
          svg.setAttribute("fill", "currentColor");
          svg.setAttribute("aria-hidden", "true");
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute(
            "d",
            "M12 2C7.6 2 4 5.6 4 10c0 5.3 8 12 8 12s8-6.7 8-12c0-4.4-3.6-8-8-8zm0 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"
          );
          svg.appendChild(path);
          return svg;
        }

        const PRESENCE_LABELS = {
          online: "Online",
          idle: "Idle",
          dnd: "Do not disturb",
          offline: "Offline",
        };
        const PRESENCE_CLASSES = [
          "status-online",
          "status-idle",
          "status-dnd",
          "status-offline",
        ];

        function normalizePresence(raw) {
          const key = String(raw || "online").toLowerCase();
          return ["online", "idle", "dnd", "offline"].includes(key)
            ? key
            : "online";
        }

        function applyPresenceClass(el, presence) {
          if (!el) return;
          PRESENCE_CLASSES.forEach((cls) => el.classList.remove(cls));
          el.classList.add(`status-${normalizePresence(presence)}`);
        }

        function formatTime(seconds) {
          if (!Number.isFinite(seconds) || seconds <= 0) return "0:00";
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${String(secs).padStart(2, "0")}`;
        }

        function stripFileExtension(name) {
          if (!name) return "";
          const base = String(name).trim();
          const dot = base.lastIndexOf(".");
          if (dot <= 0) return base;
          return base.slice(0, dot);
        }

        function getAudioTitle(url) {
          if (!url) return "Audio";
          try {
            const u = new URL(url, window.location.origin);
            const name = (u.pathname || "").split("/").pop();
            if (name) return stripFileExtension(decodeURIComponent(name));
          } catch (_) {}
          return "Audio";
        }

        function syncAudioUI() {
          if (!audioPlayer || !audioSeek || !audioTime || !audioPlayBtn) return;
          if (!bgAudio) {
            audioTime.textContent = "0:00 / 0:00";
            audioSeek.value = "0";
            audioSeek.max = "0";
            audioPlayBtn.classList.remove("is-playing");
            audioPlayBtn.setAttribute("aria-label", "Play");
            return;
          }
          const duration = Number.isFinite(bgAudio.duration)
            ? bgAudio.duration
            : 0;
          const current = Number.isFinite(bgAudio.currentTime)
            ? bgAudio.currentTime
            : 0;
          if (!audioSeekActive) {
            audioSeek.max = duration ? String(duration) : "0";
            audioSeek.value = String(
              Math.min(current, duration || current || 0)
            );
          }
          audioTime.textContent = `${formatTime(current)} / ${formatTime(
            duration
          )}`;
          const playing = !bgAudio.paused;
          audioPlayBtn.classList.toggle("is-playing", playing);
          audioPlayBtn.setAttribute("aria-label", playing ? "Pause" : "Play");
        }

        function bindAudioPlayer(audio) {
          if (!audio) return () => {};
          const update = () => syncAudioUI();
          const onPlay = () => syncAudioUI();
          const onPause = () => syncAudioUI();
          audio.addEventListener("timeupdate", update);
          audio.addEventListener("loadedmetadata", update);
          audio.addEventListener("play", onPlay);
          audio.addEventListener("pause", onPause);
          audio.addEventListener("ended", onPause);
          return () => {
            audio.removeEventListener("timeupdate", update);
            audio.removeEventListener("loadedmetadata", update);
            audio.removeEventListener("play", onPlay);
            audio.removeEventListener("pause", onPause);
            audio.removeEventListener("ended", onPause);
          };
        }

        function updateSoundUI() {
          if (!soundBtn) return;
          soundBtn.classList.toggle("on", soundOn);
          soundLabel.textContent = soundOn ? "Sound on" : "Sound off";
        }

        function showGate(show) {
          const gate = document.getElementById("enterOverlay");
          if (!gate) return;
          if (show) {
            gate.classList.remove("hidden");
            gateActive = true;
            gate.focus({ preventScroll: true });
          } else {
            gate.classList.add("hidden");
            gateActive = false;
          }
        }

        async function turnSoundOn() {
          try {
            if (bgAudio) {
              bgAudio.muted = false;
              await bgAudio.play().catch(() => {});
            } else if (bgVideo) {
              bgVideo.muted = false;
              await bgVideo.play().catch(() => {});
            } else {
              return;
            }
            soundOn = true;
            updateSoundUI();
            soundBtn.classList.remove("hidden");
            syncAudioUI();
          } catch (_) {
            // bleibt off
          }
        }

        function turnSoundOff() {
          try {
            if (bgAudio) {
              bgAudio.muted = true;
            }
            if (bgVideo) {
              bgVideo.muted = true;
            }
            soundOn = false;
            updateSoundUI();
            syncAudioUI();
          } catch (_) {}
        }

        async function playBackgroundVideo(unmute) {
          if (!bgVideo) return false;
          const tryPlay = async (mute) => {
            bgVideo.muted = mute;
            try {
              await bgVideo.play();
              return true;
            } catch (_) {
              return false;
            }
          };
          if (unmute) {
            if (await tryPlay(false)) return true;
            if (await tryPlay(true)) return true;
          } else if (await tryPlay(true)) {
            return true;
          }
          return false;
        }

        if (soundBtn) {
          soundBtn.addEventListener("click", () => {
            if (soundOn) turnSoundOff();
            else turnSoundOn();
          });
        }

        if (audioSeek) {
          audioSeek.addEventListener("pointerdown", () => {
            audioSeekActive = true;
          });
          audioSeek.addEventListener("pointerup", () => {
            audioSeekActive = false;
            syncAudioUI();
          });
          audioSeek.addEventListener("pointercancel", () => {
            audioSeekActive = false;
            syncAudioUI();
          });
          audioSeek.addEventListener("input", () => {
            if (!bgAudio) return;
            const nextTime = Number(audioSeek.value || 0);
            if (Number.isFinite(nextTime)) bgAudio.currentTime = nextTime;
          });
        }

        if (audioPlayBtn) {
          audioPlayBtn.addEventListener("click", async () => {
            if (!bgAudio) return;
            if (bgAudio.paused) {
              await turnSoundOn();
            } else {
              bgAudio.pause();
            }
            syncAudioUI();
          });
        }

        if (audioBackBtn) {
          audioBackBtn.addEventListener("click", () => {
            if (!bgAudio) return;
            bgAudio.currentTime = Math.max(0, bgAudio.currentTime - 10);
            syncAudioUI();
          });
        }

        if (audioForwardBtn) {
          audioForwardBtn.addEventListener("click", () => {
            if (!bgAudio || !Number.isFinite(bgAudio.duration)) return;
            bgAudio.currentTime = Math.min(
              bgAudio.duration,
              bgAudio.currentTime + 10
            );
            syncAudioUI();
          });
        }

        async function enterExperience() {
          showGate(false);
          if (bgVideo) {
            bgVideo.dataset.userReady = "1";
            bgVideo.dataset.wantSound = bgAudio ? "0" : "1";
            const ok = await playBackgroundVideo(!bgAudio);
            if (ok && !bgAudio) {
              soundOn = !bgVideo.muted;
              updateSoundUI();
            }
          }
          if (bgAudio) {
            bgAudio.muted = false;
            bgAudio
              .play()
              .then(() => {
                soundOn = true;
                updateSoundUI();
                syncAudioUI();
              })
              .catch(() => {});
          }
        }

        const gate = document.getElementById("enterOverlay");
        if (gate) {
          gate.addEventListener("click", enterExperience);
          gate.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              enterExperience();
            }
          });
        }

        // Ein “erster User-Input” schaltet optional sofort Ton an
        const firstGesture = () => {
          turnSoundOn();
          window.removeEventListener("pointerdown", firstGesture);
        };
        window.addEventListener("pointerdown", firstGesture, { once: true });

        const CACHE_PREFIX = "taoma:linktree:v1:";
        const CACHE_MS = 90 * 1000; // short-lived cache to speed up repeat visits
        let lastData = null;
        let initialRenderDone = false;
        let lastMediaMode = null;
        let lastDevice = null;
        let discordStatusCache = null;
        let discordStatusPromise = null;

        function getConnectionProfile() {
          const conn =
            navigator.connection ||
            navigator.mozConnection ||
            navigator.webkitConnection;
          const downlink =
            conn && typeof conn.downlink === "number" ? conn.downlink : null;
          return {
            saveData:
              !!(conn && conn.saveData) ||
              (typeof window.matchMedia === "function" &&
                window.matchMedia("(prefers-reduced-data: reduce)").matches),
            effectiveType: (conn && conn.effectiveType) || "",
            downlink,
          };
        }

        function shouldUseLiteMedia(profile = getConnectionProfile()) {
          const dl =
            typeof profile.downlink === "number" ? profile.downlink : null;
          const slow =
            profile.saveData ||
            ["slow-2g", "2g", "3g"].includes(profile.effectiveType || "") ||
            (dl !== null && dl < 1.5);
          return !!slow;
        }

        function makeCacheKey({ slug, templateId, device }) {
          if (templateId) return `${CACHE_PREFIX}tpl:${templateId}:${device}`;
          return `${CACHE_PREFIX}slug:${slug || "anon"}:${device}`;
        }

        function readCachedTree(key) {
          try {
            const raw = sessionStorage.getItem(key);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed.savedAt !== "number" || !parsed.data)
              return null;
            if (Date.now() - parsed.savedAt > CACHE_MS) {
              sessionStorage.removeItem(key);
              return null;
            }
            return parsed.data;
          } catch (_) {
            return null;
          }
        }

        function writeCachedTree(key, data) {
          try {
            sessionStorage.setItem(
              key,
              JSON.stringify({ savedAt: Date.now(), data: data || null })
            );
          } catch (_) {}
        }

        async function fetchDiscordStatus() {
          if (discordStatusCache !== null) return discordStatusCache;
          if (discordStatusPromise) return discordStatusPromise;
          discordStatusPromise = (async () => {
            try {
              const r = await fetch("/api/discord/status", {
                credentials: "include",
              });
              if (!r.ok) throw new Error("discord status failed");
              const json = await r.json();
              discordStatusCache = json || { linked: false };
            } catch (_) {
              discordStatusCache = { linked: false };
            } finally {
              discordStatusPromise = null;
            }
            return discordStatusCache;
          })();
          return discordStatusPromise;
        }

        function updateProfileFromUser(data) {
          if (!data || !data.is_template_demo) return;
          if (!currentUser || !currentUser.profile_picture) return;
          const pfp = document.getElementById("pfp");
          const url = safeMediaUrl(currentUser.profile_picture);
          if (!pfp || !url) return;
          try {
            const absolute = new URL(url, window.location.origin).href;
            if (pfp.src === absolute) return;
          } catch (_) {
            // ignore comparison errors
          }
          pfp.src = url;
        }

        async function applyUserDiscordFrame(data) {
          if (!data || !data.is_template_demo || !data.discord_frame_enabled)
            return;
          const status = await fetchDiscordStatus();
          if (!status || !status.linked || !status.decoration_url) return;
          const frame = document.getElementById("pfpFrame");
          const url = safeMediaUrl(status.decoration_url);
          if (!frame || !url) return;
          frame.src = url;
          frame.style.display = "block";
        }

        async function hydrateUserEnhancements(data, device, userPromise) {
          try {
            const user = await userPromise.catch(() => null);
            currentUser = currentUser || user;
            if (!data) return;
            if (data.is_template_demo) {
              updateProfileFromUser(data);
              await applyUserDiscordFrame(data);
            }
          } catch (_) {
            // ignore hydration errors to avoid blocking initial render
          }
        }

        let currentUser = null;

        async function fetchSessionUser() {
          try {
            const r = await fetch("/api/auth/verify", {
              credentials: "include",
            });
            if (!r.ok) return null;
            const json = await r.json();
            currentUser = json && json.user ? json.user : null;
            return currentUser;
          } catch (_) {
            return null;
          }
        }

        function detectDevice(requestedDevice) {
          return requestedDevice === "mobile"
            ? "mobile"
            : requestedDevice === "pc"
            ? "pc"
            : window.matchMedia("(max-width: 720px)").matches
            ? "mobile"
            : "pc";
        }

        let visibilityHandlerAdded = false;

        async function fetchTreeData({ templateId, slug, device }) {
          if (templateId) {
            const r = await fetch(
              `/api/marketplace/templates/${encodeURIComponent(templateId)}`,
              { credentials: "include" }
            );
            if (!r.ok) return null;
            const tpl = await r.json();
            const variants = tpl.variants || [];
            const chosen =
              variants.find((v) => v.device_type === device) ||
              variants[0] ||
              tpl.data ||
              {};
            const data = { ...(chosen || {}) };
            data.slug = data.slug || tpl.name || "Template";
            data.device_type = data.device_type || device;
            data.user_username =
              data.user_username || tpl.owner_username || "Template";
            data.profile_picture =
              data.profile_picture || tpl.preview_image_url || null;
            data.is_template_demo = true;
            return data;
          }

          const r = await fetch(
            `/api/linktrees/${encodeURIComponent(slug)}?device=${device}`
          );
          if (!r.ok) return null;
          return await r.json();
        }

        function renderTree(
          data,
          {
            preferLite = shouldUseLiteMedia(),
            fromCache = false,
            device = detectDevice(),
          } = {}
        ) {
          if (!data) return;
          lastData = data;
          lastMediaMode = preferLite ? "lite" : "full";
          lastDevice = device;
          const isMobile = device === "mobile";
          let needsGate = false;

          let bgIsVideo = false;
          let bgUrl = "";
          const bgEl = document.getElementById("bg");
          bgVideo = null;
          if (bgEl) {
            bgEl.textContent = "";
            const bgSource = pickBackgroundSource(data, preferLite);
            bgUrl = bgSource.url;
            bgIsVideo = bgSource.isVideo;
            if (bgUrl) {
              if (bgIsVideo) {
                const video = document.createElement("video");
                video.id = "bgvid";
                video.src = bgUrl;
                video.autoplay = false;
                video.muted = true;
                video.loop = true;
                video.setAttribute("muted", "");
                video.setAttribute("playsinline", "");
                video.setAttribute("webkit-playsinline", "");
                video.preload = preferLite ? "metadata" : "auto";
                if (preferLite) {
                  video.setAttribute("data-lite", "true");
                }
                video.addEventListener("loadeddata", () => {
                  if (bgVideo !== video) return;
                  if (video.dataset.userReady !== "1" || document.hidden)
                    return;
                  playBackgroundVideo(video.dataset.wantSound === "1");
                });
                bgEl.appendChild(video);
                bgVideo = video;
                needsGate = true;
                if (!visibilityHandlerAdded) {
                  document.addEventListener("visibilitychange", () => {
                    if (!document.hidden && !gateActive && bgVideo) {
                      playBackgroundVideo(bgVideo.dataset.wantSound === "1");
                    }
                  });
                  visibilityHandlerAdded = true;
                }
              } else {
                const img = document.createElement("img");
                img.src = bgUrl;
                img.alt = "Background";
                img.loading = "lazy";
                img.decoding = "async";
                bgEl.appendChild(img);
              }
            }
          }
          if (bgEl) {
            bgEl.classList.remove("night", "rain", "snow");
            if (data.background_effect && data.background_effect !== "none") {
              bgEl.classList.add(data.background_effect);
            }
          }

          // Audio (Song hat Vorrang vor Video-Ton)
          if (bgAudio) {
            try {
              bgAudio.pause();
            } catch {}
            if (audioCleanup) {
              audioCleanup();
              audioCleanup = null;
            }
            bgAudio.remove();
            bgAudio = null;
          }
          syncAudioUI();
          const songUrl = safeMediaUrl(data.song_url);
          const songIconUrl = safeMediaUrl(data.song_icon_url);
          const showAudioPlayer = !!data.show_audio_player && !!songUrl;
          if (audioPlayer) {
            applyAudioPlayerStyles(data);
            audioPlayer.classList.toggle("hidden", !showAudioPlayer);
          }
          if (audioIcon) {
            if (songIconUrl) {
              audioIcon.src = songIconUrl;
              audioIcon.classList.remove("hidden");
            } else {
              audioIcon.removeAttribute("src");
              audioIcon.classList.add("hidden");
            }
          }
          if (showAudioPlayer && audioTitle) {
            const songName = (data.song_name || "").trim();
            const title = stripFileExtension(songName) || getAudioTitle(songUrl);
            audioTitle.style.display = "";
            audioTitle.textContent = title || "Audio";
          }
          if (songUrl) {
            bgAudio = document.createElement("audio");
            bgAudio.src = songUrl;
            bgAudio.loop = true;
            bgAudio.preload = preferLite ? "metadata" : "auto";
            bgAudio.muted = true; // Autoplay-friendly start, gate will unmute
            document.body.appendChild(bgAudio);
            bgAudio.play().catch(() => {});
            audioCleanup = bindAudioPlayer(bgAudio);
            syncAudioUI();
            needsGate = true;
            if (soundBtn) soundBtn.classList.remove("hidden"); // Button zeigen - Nutzer kann unmute'n
          } else if (bgIsVideo && bgVideo) {
            // Kein Song -> Videoton anbieten
            if (soundBtn) soundBtn.classList.remove("hidden");
          } else {
            if (soundBtn) soundBtn.classList.add("hidden"); // nichts abzuspielen
          }
          if (bgVideo && songUrl) {
            bgVideo.muted = true;
          }
          if (needsGate) {
            showGate(true);
          } else {
            showGate(false);
          }
          soundOn = false;
          updateSoundUI();

          const cardEl = document.getElementById("card");
          if (cardEl) {
            const raw = Number(data.transparency);
            const clamped = Number.isFinite(raw)
              ? Math.min(100, Math.max(0, raw))
              : 0;
            const cardAlpha = 1 - clamped / 100;
            const cardHex =
              sanitizeHexColor(data.card_color) || DEFAULT_CARD_COLOR;
            const cardBg =
              hexToRgba(cardHex, cardAlpha) || `rgba(23, 27, 59, ${cardAlpha})`;

            if (cardAlpha <= 0) {
              cardEl.classList.add("transparent");
              cardEl.style.background = "";
            } else {
              cardEl.classList.remove("transparent");
              cardEl.style.background = cardBg;
            }
          }
          applyTextColors(data);
          applyLinkStyles(
            data.link_color,
            data.link_bg_color,
            data.link_bg_alpha
          );

          const cursorUrl = safeMediaUrl(data.cursor_url);
          if (cursorUrl && !isMobile) {
            resizeCursorImage(cursorUrl, 32)
              .then((resized) => {
                const cursorDecl = `url("${resized}") 0 0, auto`;
                document.documentElement.style.setProperty(
                  "--cursor",
                  cursorDecl
                );
              })
              .catch(() => {
                document.documentElement.style.setProperty("--cursor", "auto");
              });
          } else {
            document.documentElement.style.setProperty("--cursor", "auto");
          }

          // Profil/Badges/Links wie gehabt
          const pfp = document.getElementById("pfp");
          const pfpFrame = document.getElementById("pfpFrame");
          if (pfp) {
            const prefersUserPfp =
              data.is_template_demo &&
              currentUser &&
              currentUser.profile_picture;
            const profileUrl =
              safeMediaUrl(
                prefersUserPfp
                  ? currentUser.profile_picture
                  : data.profile_picture
              ) ||
              safeMediaUrl(currentUser && currentUser.profile_picture) ||
              "/static/icon.png";
            pfp.src = profileUrl;
          }
          if (pfpFrame) {
            const frameUrl = safeMediaUrl(data.discord_decoration_url);
            if (data.discord_frame_enabled && frameUrl) {
              pfpFrame.src = frameUrl;
              pfpFrame.style.display = "block";
            } else {
              pfpFrame.style.display = "none";
            }
          }
          const presence = normalizePresence(data.discord_presence);
          const presenceLabel = PRESENCE_LABELS[presence] || "Online";
          const presenceEl = document.getElementById("discordPresence");
          const statusLine = document.getElementById("discordStatusLine");
          const statusTextEl = document.getElementById("discordStatusText");
          const discordLinked = !!data.discord_linked;
          if (presenceEl) {
            const showPresence = discordLinked && data.discord_presence_enabled;
            presenceEl.classList.toggle("hidden", !showPresence);
            applyPresenceClass(presenceEl, presence);
            presenceEl.setAttribute(
              "aria-label",
              `Discord status: ${presenceLabel}`
            );
          }
          if (statusLine && statusTextEl) {
            const showStatus = discordLinked && data.discord_status_enabled;
            statusLine.classList.toggle("hidden", !showStatus);
            if (showStatus) {
              applyPresenceClass(statusLine, presence);
              const statusText = (data.discord_status_text || "").trim();
              statusTextEl.textContent = statusText || presenceLabel;
            } else {
              statusTextEl.textContent = "";
            }
          }
          const nameEl = document.getElementById("name");
          if (nameEl) {
            const mode = data.display_name_mode || "slug";
            if (mode === "username") {
              nameEl.textContent = data.user_username || data.slug || "User";
            } else if (mode === "custom" && data.custom_display_name) {
              nameEl.textContent = data.custom_display_name;
            } else {
              nameEl.textContent = data.slug || "User";
            }

            // Effekt-Klassen setzen
            nameEl.classList.remove("glow", "neon", "rainbow");
            if (data.name_effect && data.name_effect !== "none") {
              nameEl.classList.add(data.name_effect);
            }
          }
          const quoteEl = document.getElementById("quote");
          if (quoteEl) quoteEl.textContent = data.quote || "";
          const locEl = document.getElementById("loc");
          if (locEl) {
            locEl.textContent = "";
            const locText =
              typeof data.location === "string" ? data.location.trim() : "";
            locEl.classList.toggle("hidden", !locText);
            if (locText) {
              const icon = createLocationIcon();
              const text = document.createElement("span");
              text.textContent = ` ${locText}`;
              locEl.appendChild(icon);
              locEl.appendChild(text);
            }
          }

          const discordBadgesEl = document.getElementById("discordBadges");
          if (discordBadgesEl) {
            discordBadgesEl.innerHTML = "";
            const list = Array.isArray(data.discord_badges)
              ? data.discord_badges
              : [];
            const showBadges =
              discordLinked && data.discord_badges_enabled && list.length > 0;
            discordBadgesEl.classList.toggle("hidden", !showBadges);
            if (showBadges) {
              const frag = document.createDocumentFragment();
              list.forEach((badge) => {
                if (!badge) return;
                const item = document.createElement("span");
                item.className = "discord-badge";
                const label = badge.label || badge.code || "badge";
                item.title = label;
                item.setAttribute("aria-label", label);
                const iconUrl = safeMediaUrl(badge.icon_url);
                if (iconUrl) {
                  const img = document.createElement("img");
                  img.src = iconUrl;
                  img.alt = "";
                  img.loading = "lazy";
                  img.decoding = "async";
                  item.appendChild(img);
                }
                frag.appendChild(item);
              });
              discordBadgesEl.appendChild(frag);
            }
          }

          const badgesEl = document.getElementById("badges");
          if (badgesEl) {
            badgesEl.innerHTML = "";
            const frag = document.createDocumentFragment();
            (data.icons || []).forEach((ic) => {
              if (!ic.displayed) return;

              const desc = ic.description || ic.code || "badge";
              const wrap = document.createElement("span");
              wrap.className = "badge";
              // Tooltip via title (Desktop) + aria-label (AT / Touch-Langdruck zeigt oft auch title)
              wrap.title = desc;
              wrap.setAttribute("aria-label", desc);

              const img = document.createElement("img");
              const iconUrl = safeMediaUrl(ic.image_url);
              if (!iconUrl) return;
              img.src = iconUrl;
              img.alt = desc;
              img.width = 20;
              img.height = 20;
              img.loading = "lazy";
              img.decoding = "async";

              wrap.appendChild(img);
              frag.appendChild(wrap);
            });
            badgesEl.appendChild(frag);
          }
          const linksEl = document.getElementById("links");
          if (linksEl) {
            linksEl.textContent = "";
            const frag = document.createDocumentFragment();
            (data.links || []).forEach((l) => {
              if (!l.is_active) return;
              const href = safeLinkUrl(l.url);
              if (!href) return;
              const a = document.createElement("a");
              a.className = "link";
              a.href = href;
              a.target = "_blank";
              a.rel = "noreferrer noopener";
              const iconUrl = safeMediaUrl(l.icon_url);
              if (iconUrl) {
                const img = document.createElement("img");
                img.src = iconUrl;
                img.alt = "";
                img.loading = "lazy";
                img.decoding = "async";
                a.appendChild(img);
              }
              const span = document.createElement("span");
              span.textContent = l.label || l.url;
              a.appendChild(span);
              frag.appendChild(a);
            });
            linksEl.appendChild(frag);
          }

          const visitBox = document.getElementById("visitCounter");
          const visitValue = document.getElementById("visitCounterValue");
          if (visitBox && visitValue) {
            if (data.show_visit_counter) {
              visitValue.textContent = Number(
                data.visit_count || 0
              ).toLocaleString();
              const textColor =
                hexToRgba(data.visit_counter_color, 1) ||
                hexToRgba(data.text_color, 1) ||
                null;
              if (textColor) visitBox.style.color = textColor;
              const bgAlpha = Number.isFinite(
                Number(data.visit_counter_bg_alpha)
              )
                ? Number(data.visit_counter_bg_alpha)
                : 20;
              const bgColor =
                hexToRgba(
                  data.visit_counter_bg_color || "#ffffff",
                  Math.min(1, Math.max(0, bgAlpha / 100))
                ) || "rgba(255,255,255,0.14)";
              visitBox.style.backgroundColor = bgColor;
              visitBox.style.display = "inline-flex";
            } else {
              visitBox.style.display = "none";
            }
          }
        }

        async function loadTree() {
          try {
            const params = new URLSearchParams(location.search);
            let templateId = params.get("template_id");
            const parts = location.pathname.split("/").filter(Boolean);
            if (
              !templateId &&
              parts[0] === "marketplace" &&
              parts[1] === "templates"
            ) {
              templateId = parts[2] || null;
            }
            const requestedDevice = params.get("device");
            const device = detectDevice(requestedDevice);
            const slug = decodeURIComponent(
              location.pathname.split("/").pop() || ""
            );
            const cacheKey = makeCacheKey({ slug, templateId, device });
            const preferLite = shouldUseLiteMedia();

            const userPromise = fetchSessionUser();
            const cached = readCachedTree(cacheKey);
            if (cached && !initialRenderDone) {
              renderTree(cached, { preferLite, fromCache: true, device });
              initialRenderDone = true;
              hydrateUserEnhancements(cached, device, userPromise).catch(
                () => {}
              );
            }

            const dataPromise = fetchTreeData({ templateId, slug, device });
            const liveData = await dataPromise;
            let data = liveData || cached;
            if (!data) return;
            writeCachedTree(cacheKey, data);
            if (!initialRenderDone) {
              renderTree(data, { preferLite, fromCache: false, device });
              initialRenderDone = true;
            } else {
              lastData = data;
            }
            hydrateUserEnhancements(data, device, userPromise).catch(() => {});
          } catch (e) {
            console.error("loadTree failed:", e);
          }
        }

        const connection =
          navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection;
        const prefersReducedData =
          typeof window.matchMedia === "function"
            ? window.matchMedia("(prefers-reduced-data: reduce)")
            : null;

        function handleMediaPreferenceChange() {
          if (!lastData) return;
          const preferLite = shouldUseLiteMedia();
          if ((preferLite ? "lite" : "full") === lastMediaMode) return;
          renderTree(lastData, {
            preferLite,
            fromCache: true,
            device: lastDevice || detectDevice(),
          });
        }

        if (connection && connection.addEventListener) {
          connection.addEventListener("change", handleMediaPreferenceChange);
        }
        if (prefersReducedData && prefersReducedData.addEventListener) {
          prefersReducedData.addEventListener(
            "change",
            handleMediaPreferenceChange
          );
        } else if (prefersReducedData && prefersReducedData.addListener) {
          prefersReducedData.addListener(handleMediaPreferenceChange);
        }

        loadTree();
        document.addEventListener("DOMContentLoaded", () => {
          console.log("Page loaded (HTML ready)");
        });
      })();
    </script>
  </body>
</html>
