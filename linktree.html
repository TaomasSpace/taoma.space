<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TAOMA™ — Linktree</title>
    <meta
      name="description"
      content="TAOMA™ Linktree: zentrale Anlaufstelle für alle TAOMA Links, Socials und Projekte."
    />
    <meta property="og:title" content="TAOMA™ — Linktree" />
    <meta
      property="og:description"
      content="Alle TAOMA Links, Socials und Projekte auf einen Blick."
    />
    <meta property="og:type" content="profile" />
    <meta property="og:url" content="https://taoma.space/linktree" />
    <meta property="og:image" content="https://taoma.space/static/icon.png" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="TAOMA™ — Linktree" />
    <meta
      name="twitter:description"
      content="Alle TAOMA Links, Socials und Projekte auf einen Blick."
    />
    <meta name="twitter:image" content="https://taoma.space/static/icon.png" />
    <link rel="canonical" href="https://taoma.space/linktree" />
    <meta name="robots" content="index,follow" />
    <meta name="theme-color" content="#0f1223" />
    <link rel="icon" type="image/png" href="/static/icon.png" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "ProfilePage",
        "url": "https://taoma.space/linktree",
        "name": "TAOMA Linktree",
        "inLanguage": "de",
        "about": "Zentrale Links und Projekte von TAOMA",
        "breadcrumb": "Home > Linktree"
      }
    </script>
    <style>
      :root {
        --bg: #0e1020;
        --ink: #e9ebff;
        --muted: #a2a9c8;
        --acc: #85a3ff;
        --card: #171b3b;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        --radius: 16px;
        --link-color: #e9ebff;
        --link-bg: #171b3b;
        --link-bg-hover: color-mix(in oklab, #171b3b, white 4%);
        --link-cols: 1;
        --name-color: #e9ebff;
        --location-color: #a2a9c8;
        --quote-color: #e9ebff;
        --quote-glow-1: 8px;
        --quote-glow-2: 12px;
        --quote-glow-3: 18px;
        --quote-neon-1: 6px;
        --quote-neon-2: 14px;
        --quote-neon-3: 24px;
        --quote-neon-drop: 10px;
        --cursor: auto;
        --cursor-fx-color: var(--acc);
      }

      body {
        margin: 0;
        font:
          15px/1.6 Inter,
          ui-sans-serif,
          system-ui;
        color: var(--ink);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background: var(--bg);
        overflow-x: hidden;
        cursor: var(--cursor, auto);
      }

      html,
      body,
      a,
      button,
      .link {
        cursor: var(--cursor, auto);
      }

      /* Background video/image */
      .bg {
        position: fixed;
        inset: 0;
        z-index: -1;
        overflow: hidden;
      }

      .bg img,
      .bg video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: 3rem 1rem;
      }

      .pfp-wrap {
        position: relative;
        width: 110px;
        height: 110px;
        margin: 0 auto 7px;
        display: grid;
        place-items: center;
      }

      .pfp {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: 3px solid #fff3;
        box-shadow: var(--shadow);
        object-fit: cover;
        max-width: 100%;
        max-height: 100%;
        position: relative;
        z-index: 1;
      }

      .pfp-frame {
        position: absolute;
        inset: -4px;
        width: calc(100% + 8px);
        height: calc(100% + 8px);
        object-fit: contain;
        pointer-events: none;
        z-index: 2;
      }

      .discord-presence {
        position: absolute;
        right: 4px;
        bottom: 4px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(15, 18, 35, 0.9);
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
        background: #8a90a8;
        z-index: 3;
      }

      .discord-presence.hidden {
        display: none;
      }

      .discord-presence.status-online {
        background: #23a559;
      }

      .discord-presence.status-idle {
        background: #f0b232;
      }

      .discord-presence.status-dnd {
        background: #f23f43;
      }

      .discord-presence.status-offline {
        background: #8a90a8;
      }

      .discord-status {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.45rem;
        font-size: 0.95rem;
        color: var(--muted);
        margin-bottom: 0.6rem;
      }

      .discord-status.hidden {
        display: none;
      }

      .discord-status .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #8a90a8;
      }

      .discord-status.status-online .dot {
        background: #23a559;
      }

      .discord-status.status-idle .dot {
        background: #f0b232;
      }

      .discord-status.status-dnd .dot {
        background: #f23f43;
      }

      .discord-status.status-offline .dot {
        background: #8a90a8;
      }

      .discord-status .text {
        font-weight: 600;
      }

      .discord-badges {
        display: flex;
        gap: 0.45rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 1.4rem;
      }

      .discord-badges.hidden {
        display: none;
      }

      .discord-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.25rem 0.6rem;
        border-radius: 999px;
        background: #ffffff14;
        border: 1px solid #ffffff26;
        font-size: 0.75rem;
        font-weight: 700;
        color: var(--ink);
      }

      .discord-badge img {
        width: 28px;
        height: 28px;
        object-fit: contain;
        display: block;
      }

      .audio-player {
        width: 100%;
        max-width: 420px;
        margin: 0 auto 1.5rem;
        padding: 0.8rem 1rem;
        box-sizing: border-box;
        border-radius: 14px;
        background: var(--audio-bg, rgba(23, 27, 59, 0.6));
        border: 1px solid var(--audio-border, #ffffff26);
        box-shadow: var(--shadow);
        display: grid;
        gap: 0.55rem;
        text-align: left;
        color: var(--audio-text, var(--ink));
      }

      .audio-player.hidden {
        display: none;
      }

      .audio-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.85rem;
        color: var(--audio-muted, var(--muted));
        gap: 0.5rem;
      }

      .audio-title-wrap {
        display: flex;
        align-items: center;
        gap: 0.45rem;
        min-width: 0;
      }

      .audio-icon {
        width: 50px;
        height: 50px;
        border-radius: 6px;
        object-fit: cover;
        display: block;
      }

      .audio-icon.hidden {
        display: none;
      }

      .audio-title {
        font-weight: 700;
        color: var(--audio-text, var(--ink));
      }

      .audio-seek {
        width: 100%;
        accent-color: var(--audio-accent, var(--acc));
      }

      .audio-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .audio-btn {
        border: 1px solid #ffffff26;
        background: var(--audio-btn-bg, #ffffff14);
        color: var(--audio-text, var(--ink));
        border-radius: 999px;
        padding: 0.35rem 0.7rem;
        font-weight: 700;
        cursor: var(--cursor, pointer);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        min-width: 42px;
      }

      .audio-btn.primary {
        background: var(--audio-accent, var(--acc));
        color: var(--audio-accent-ink, #0e1020);
        border-color: color-mix(
          in oklab,
          var(--audio-accent, var(--acc)) 65%,
          #000
        );
      }

      .audio-btn svg {
        width: 16px;
        height: 16px;
      }

      .audio-btn .icon-pause {
        display: none;
      }

      .audio-btn.is-playing .icon-pause {
        display: block;
      }

      .audio-btn.is-playing .icon-play {
        display: none;
      }

      .name {
        font-size: 1.8rem;
        font-weight: 800;
        margin: 1rem 0 0.5rem;
        color: var(--name-color);
      }

      .name.has-id {
        position: relative;
        display: inline-flex;
        justify-content: center;
        align-items: center;
      }

      .name.has-id::after {
        content: attr(data-id);
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translate(-50%, 6px);
        background: rgba(0, 0, 0, 0.35);
        color: var(--ink);
        font-size: 0.75rem;
        padding: 0.2rem 0.55rem;
        border-radius: 999px;
        border: 1px solid #ffffff26;
        box-shadow: var(--shadow);
        opacity: 0;
        pointer-events: none;
        white-space: nowrap;
        transition:
          opacity 0.15s ease,
          transform 0.15s ease;
      }

      .name.has-id:hover::after {
        opacity: 1;
        transform: translate(-50%, 10px);
      }

      .name.font-serif {
        font-family: Georgia, "Times New Roman", serif;
      }
      .name.font-mono {
        font-family:
          ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "Courier New",
          monospace;
      }
      .name.font-script {
        font-family: "Segoe Script", "Comic Sans MS", cursive;
      }
      .name.font-display {
        font-family: Impact, "Arial Black", "Franklin Gothic", sans-serif;
        letter-spacing: 0.4px;
      }

      .location {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        justify-content: center;
        color: var(--location-color);
        margin-bottom: 1rem;
      }

      .quote {
        font-style: italic;
        color: var(--quote-color);
        margin-bottom: 1.5rem;
        max-width: 600px;
      }

      .quote.hidden {
        display: none;
      }
      .quote.font-serif {
        font-family: Georgia, "Times New Roman", serif;
      }
      .quote.font-mono {
        font-family:
          ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "Courier New",
          monospace;
        font-style: normal;
      }
      .quote.font-script {
        font-family: "Segoe Script", "Comic Sans MS", cursive;
      }
      .quote.font-display {
        font-family: Impact, "Arial Black", "Franklin Gothic", sans-serif;
        letter-spacing: 0.4px;
      }

      .quote.quote-cursor::after {
        content: " |";
        display: inline-block;
        opacity: 1;
      }
      .quote.rainbow.quote-cursor::after {
        color: var(--quote-color);
        -webkit-text-fill-color: var(--quote-color);
      }

      .quote.quote-cursor.cursor-blink::after {
        animation: quote-blink 0.9s steps(1, end) infinite;
      }

      @keyframes quote-blink {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0;
        }
      }

      .badges {
        display: flex;
        gap: 0.4rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 2rem;
      }

      .badges.hidden {
        display: none;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        /* kein Platz für Text nötig */
        background: #ffffff1a;
        border-radius: 999px;
        padding: 0.28rem;
        /* nur wenig Innenabstand */
        border: 1px solid #ffffff26;
        /* dezente Kante, optional */
      }

      .badge img {
        width: 20px;
        height: 20px;
        object-fit: contain;
        display: block;
      }

      .links {
        display: grid;
        gap: 12px;
        width: 100%;
        max-width: 420px;
        margin: 0 auto;
        grid-template-columns: repeat(var(--link-cols, 1), minmax(0, 1fr));
        /* <- zentriert die Liste innerhalb der Karte */
      }

      .links.hidden {
        display: none;
      }

      .section-row {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 1.25rem;
        width: 100%;
        align-items: start;
      }

      .section-row > * {
        width: 100%;
      }

      .visit-counter {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        margin: 1rem auto 0;
        padding: 0.55rem 0.9rem;
        border-radius: 999px;
        background: #ffffff14;
        color: var(--ink);
        font-weight: 600;
        border: 1px solid #ffffff26;
        box-shadow: var(--shadow);
      }

      .visit-counter svg {
        width: 18px;
        height: 18px;
      }

      .link {
        position: relative;
        /* für das absolut positionierte Icon */
        display: flex;
        align-items: center;
        justify-content: center;
        /* zentriert den Inhalt */
        text-align: center;
        gap: 0.6rem;
        padding: 0.9rem 1.2rem;
        border-radius: var(--radius);
        background: var(--link-bg);
        border: 1px solid #ffffff22;
        box-shadow: var(--shadow);
        transition: 0.2s;
        width: 100%;
        color: var(--link-color);
        /* volle Breite für schöne Pillenform */
      }

      .link:hover {
        transform: translateY(-2px);
        background: var(--link-bg-hover);
      }

      .link img {
        width: 35px;
        height: 35px;
        object-fit: contain;
        position: absolute;
        left: 14px;
        top: 50%;
        transform: translateY(-50%);
      }

      .link span {
        margin: 0 auto;
      }

      footer {
        padding: 1rem;
        text-align: center;
        font-size: 0.85rem;
        color: var(--muted);
      }

      footer a {
        color: inherit;
        font-weight: 700;
      }

      footer a:hover {
        text-decoration: underline;
      }

      .sound-toggle {
        position: fixed;
        right: 14px;
        bottom: 16px;
        z-index: 10;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.45rem 0.6rem;
        border-radius: 999px;
        background: #ffffff1a;
        color: var(--ink);
        border: 1px solid #ffffff33;
        box-shadow: var(--shadow);
        font-weight: 700;
        user-select: none;
        cursor: var(--cursor, pointer);
        backdrop-filter: blur(6px) saturate(1.2);
      }

      .sound-toggle.hidden {
        display: none;
      }

      .sound-toggle .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #ff6b6b;
      }

      .sound-toggle.on .dot {
        background: #1dd1a1;
      }

      .enter-gate {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(6px);
        background: rgba(0, 0, 0, 0.35);
        z-index: 9;
        transition: opacity 0.2s ease;
      }

      .enter-gate.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .enter-box {
        padding: 1rem 1.4rem;
        border-radius: 14px;
        background: rgba(15, 18, 35, 0.85);
        border: 1px solid #ffffff33;
        box-shadow: var(--shadow);
        color: var(--ink);
        text-align: center;
        min-width: 220px;
        cursor: var(--cursor, pointer);
        user-select: none;
      }

      .enter-box p {
        margin: 0 0 0.25rem;
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      .enter-text.font-serif {
        font-family: Georgia, "Times New Roman", serif;
      }
      .enter-text.font-mono {
        font-family:
          ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "Courier New",
          monospace;
        font-style: normal;
      }
      .enter-text.font-script {
        font-family: "Segoe Script", "Comic Sans MS", cursive;
      }
      .enter-text.font-display {
        font-family: Impact, "Arial Black", "Franklin Gothic", sans-serif;
        letter-spacing: 0.4px;
      }
      .enter-text.glow {
        text-shadow:
          0 0 8px color-mix(in oklab, currentColor 70%, transparent),
          0 0 12px color-mix(in oklab, currentColor 55%, transparent),
          0 0 18px color-mix(in oklab, currentColor 40%, transparent);
      }
      .enter-text.neon {
        text-shadow:
          0 0 6px color-mix(in oklab, currentColor 80%, transparent),
          0 0 14px color-mix(in oklab, currentColor 60%, transparent),
          0 0 24px color-mix(in oklab, currentColor 50%, transparent);
        filter: drop-shadow(
          0 0 10px color-mix(in oklab, currentColor 45%, transparent)
        );
      }
      .enter-text.rainbow {
        background: linear-gradient(
          90deg,
          red,
          orange,
          yellow,
          green,
          cyan,
          blue,
          violet
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow 3s linear infinite;
      }

      /* Name Effects */
      .name.glow {
        text-shadow:
          0 0 8px color-mix(in oklab, currentColor 70%, transparent),
          0 0 12px color-mix(in oklab, currentColor 55%, transparent),
          0 0 18px color-mix(in oklab, currentColor 40%, transparent);
      }

      .name.neon {
        text-shadow:
          0 0 6px color-mix(in oklab, currentColor 80%, transparent),
          0 0 14px color-mix(in oklab, currentColor 60%, transparent),
          0 0 24px color-mix(in oklab, currentColor 50%, transparent);
        filter: drop-shadow(
          0 0 10px color-mix(in oklab, currentColor 45%, transparent)
        );
      }

      .name.rainbow {
        background: linear-gradient(
          90deg,
          red,
          orange,
          yellow,
          green,
          cyan,
          blue,
          violet
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow 3s linear infinite;
      }

      @keyframes rainbow {
        0% {
          background-position: 0% 50%;
        }

        100% {
          background-position: 100% 50%;
        }
      }

      /* Quote Effects */
      .quote.glow {
        text-shadow:
          0 0 var(--quote-glow-1) color-mix(in oklab, currentColor 70%, transparent),
          0 0 var(--quote-glow-2) color-mix(in oklab, currentColor 55%, transparent),
          0 0 var(--quote-glow-3) color-mix(in oklab, currentColor 40%, transparent);
      }

      .quote.neon {
        text-shadow:
          0 0 var(--quote-neon-1) color-mix(in oklab, currentColor 80%, transparent),
          0 0 var(--quote-neon-2) color-mix(in oklab, currentColor 60%, transparent),
          0 0 var(--quote-neon-3) color-mix(in oklab, currentColor 50%, transparent);
        filter: drop-shadow(
          0 0 var(--quote-neon-drop) color-mix(in oklab, currentColor 45%, transparent)
        );
      }

      .quote.rainbow {
        background: linear-gradient(
          90deg,
          red,
          orange,
          yellow,
          green,
          cyan,
          blue,
          violet
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow 3s linear infinite;
      }

      /* Background Effects */
      .bg.night::after {
        content: "";
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 50, 0.4);
        mix-blend-mode: multiply;
      }

      .bg.rain::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: url("/static/effects/rain.gif");
        background-size: cover;
        opacity: 0.4;
        pointer-events: none;
      }

      .bg.snow::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: url("/static/effects/snow.gif");
        background-size: cover;
        opacity: 0.5;
        pointer-events: none;
      }

      /* Cursor Effects */
      .cursor-glow {
        position: fixed;
        left: 0;
        top: 0;
        width: var(--cursor-fx-size, 28px);
        height: var(--cursor-fx-size, 28px);
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 8;
        opacity: 0;
        transition: opacity 0.2s ease;
        mix-blend-mode: screen;
      }

      .cursor-glow.circle {
        border-radius: 50%;
        background: radial-gradient(
          circle,
          color-mix(in oklab, var(--cursor-fx-color, #85a3ff) 65%, transparent),
          transparent 70%
        );
        box-shadow:
          0 0 18px
            color-mix(
              in oklab,
              var(--cursor-fx-color, #85a3ff) 55%,
              transparent
            ),
          0 0 42px
            color-mix(
              in oklab,
              var(--cursor-fx-color, #85a3ff) 35%,
              transparent
            );
      }

      .cursor-glow.shape {
        border-radius: 0;
        background: color-mix(
          in oklab,
          var(--cursor-fx-color, #85a3ff) 32%,
          transparent
        );
        -webkit-mask-image: var(--cursor-fx-image);
        -webkit-mask-repeat: no-repeat;
        -webkit-mask-size: contain;
        -webkit-mask-position: center;
        mask-image: var(--cursor-fx-image);
        mask-repeat: no-repeat;
        mask-size: contain;
        mask-position: center;
        filter: drop-shadow(
            0 0 12px
              color-mix(
                in oklab,
                var(--cursor-fx-color, #85a3ff) 55%,
                transparent
              )
          )
          drop-shadow(
            0 0 30px
              color-mix(
                in oklab,
                var(--cursor-fx-color, #85a3ff) 35%,
                transparent
              )
          );
      }

      .cursor-fx-canvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 8;
      }

      .card {
        background: rgba(23, 27, 59, var(--card-alpha, 0.8));
        /* Default 80% deckend */
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 2rem 2rem;
        max-width: 600px;
        width: 100%;
        backdrop-filter: blur(12px);
      }

      .card.transparent {
        background: transparent;
        backdrop-filter: none;
        box-shadow: none;
      }

      /* === Mobile Optimierungen === */
      /* Verhindere horizontales Scrollen */
      html,
      body {
        max-width: 100vw;
        overflow-x: hidden;
      }

      body {
        padding: 0;
        margin: 0;
      }

      /* Main Container */
      main {
        padding: 2rem 1rem;
        max-width: 100vw;
        overflow-x: hidden;
        box-sizing: border-box;
      }

      /* Card responsive */
      .card {
        background: rgba(23, 27, 59, var(--card-alpha, 0.8));
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 1.5rem 1rem;
        max-width: 600px;
        width: calc(100% - 2rem);
        /* Berücksichtigt main padding */
        backdrop-filter: blur(12px);
        box-sizing: border-box;
        margin: 0 auto;
      }

      .editor-actions {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 0.6rem;
      }

      .editor-actions.hidden {
        display: none;
      }

      .edit-canvas-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.8rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.1);
        color: var(--ink);
        font-weight: 700;
        font-size: 0.85rem;
      }

      .edit-canvas-btn:hover {
        background: rgba(255, 255, 255, 0.18);
      }

      .card.wide {
        max-width: 980px;
        width: min(100%, 980px);
        text-align: left;
      }

      .card.wide .pfp-wrap {
        margin: 0 0 0.6rem;
      }

      .card.wide .links {
        max-width: none;
        margin: 0;
      }

      .card.wide .link {
        justify-content: flex-start;
        text-align: left;
        padding-left: 3rem;
      }

      .card.wide .visit-counter {
        margin: 1rem 0 0;
      }

      .card.canvas {
        position: relative;
        min-height: 0;
        padding: 0;
        max-width: none;
        width: auto;
      }

      .card.canvas .links {
        margin: 0;
        max-width: none;
      }

      .card.canvas .visit-counter {
        margin: 0;
        max-width: none;
      }

      .card.canvas .badges {
        margin-bottom: 0;
        max-width: none;
      }

      .card.canvas .audio-player {
        margin: 0;
        max-width: none;
      }

      .plate-group {
        position: absolute;
        inset: 0 auto auto 0;
      }

      .canvas-plate {
        position: absolute;
        inset: 0 auto auto 0;
      }

      @media (max-width: 900px) {
        .card.wide {
          text-align: center;
        }

        .card.wide .links {
          margin: 0 auto;
        }

        .card.wide .link {
          justify-content: center;
          text-align: center;
          padding-left: 1.2rem;
        }

        .card.wide .visit-counter {
          margin: 1rem auto 0;
        }

        .section-row {
          grid-template-columns: 1fr;
        }
      }

      /* Profilbild */
      .pfp {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        border: 3px solid #fff3;
        box-shadow: var(--shadow);
        object-fit: cover;
        flex-shrink: 0;
      }

      /* Name - lange Namen umbrechen */
      .name {
        font-size: clamp(1.4rem, 5vw, 1.8rem);
        font-weight: 800;
        margin: 1rem 0 0.5rem;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        max-width: 100%;
      }

      /* Location */
      .location {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        justify-content: center;
        color: var(--muted);
        margin-bottom: 1rem;
        flex-wrap: wrap;
        word-wrap: break-word;
        max-width: 100%;
      }

      .location.hidden {
        display: none;
      }

      /* Quote - lange Texte */
      .quote {
        font-style: italic;
        margin-bottom: 1.5rem;
        max-width: 100%;
        word-wrap: break-word;
        overflow-wrap: break-word;
        padding: 0 0.5rem;
        box-sizing: border-box;
      }

      /* Badges responsive */
      .badges {
        display: flex;
        gap: 0.4rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 2rem;
        padding: 0 0.5rem;
        max-width: 100%;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        background: #ffffff1a;
        border-radius: 999px;
        padding: 0.28rem;
        border: 1px solid #ffffff26;
        flex-shrink: 0;
      }

      .badge img {
        width: 20px;
        height: 20px;
        object-fit: contain;
        display: block;
      }

      /* Links Container */
      .links {
        display: grid;
        gap: 12px;
        width: 100%;
        max-width: 420px;
        margin: 0 auto;
        padding: 0;
        box-sizing: border-box;
        grid-template-columns: repeat(var(--link-cols, 1), minmax(0, 1fr));
      }

      /* Link Items */
      .link {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        gap: 0.6rem;
        padding: 0.9rem 1.2rem;
        border-radius: var(--radius);
        background: var(--link-bg);
        border: 1px solid #ffffff22;
        box-shadow: var(--shadow);
        transition: 0.2s;
        width: 100%;
        box-sizing: border-box;
        min-height: 48px;
        /* Touch-friendly Mindesthöhe */
        overflow: hidden;
        /* Verhindert Overflow */
        color: var(--link-color);
      }

      .link:hover {
        transform: translateY(-2px);
        background: var(--link-bg-hover);
      }

      /* Link Icon */
      .link img {
        width: 32px;
        height: 32px;
        object-fit: contain;
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        flex-shrink: 0;
      }

      /* Link Text */
      .link span {
        margin: 0 auto;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        max-width: calc(100% - 80px);
        /* Platz für Icon + Padding */
        padding: 0 0.5rem;
      }

      /* Footer */
      footer {
        padding: 1rem;
        text-align: center;
        font-size: 0.85rem;
        color: var(--muted);
        max-width: 100vw;
        overflow-x: hidden;
      }

      /* Sound Toggle Button */
      .sound-toggle {
        position: fixed;
        right: 12px;
        bottom: 14px;
        z-index: 10;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.45rem 0.6rem;
        border-radius: 999px;
        background: #ffffff1a;
        color: var(--ink);
        border: 1px solid #ffffff33;
        box-shadow: var(--shadow);
        font-weight: 700;
        user-select: none;
        cursor: var(--cursor, pointer);
        backdrop-filter: blur(6px) saturate(1.2);
        font-size: 0.85rem;
      }

      /* === Responsive Breakpoints === */
      /* Tablets und kleine Laptops */
      @media (max-width: 768px) {
        main {
          padding: 1.5rem 0.8rem;
        }

        .card {
          padding: 1.2rem 0.8rem;
          width: calc(100% - 1.6rem);
        }

        .name {
          font-size: clamp(1.3rem, 4.5vw, 1.6rem);
        }

        .quote {
          font-size: 0.95rem;
          padding: 0 0.3rem;
        }

        .links {
          max-width: 400px;
          gap: 10px;
        }

        .link {
          padding: 0.8rem 1rem;
        }
      }

      /* Smartphones */
      @media (max-width: 480px) {
        main {
          padding: 1rem 0.5rem;
        }

        .card {
          padding: 1rem 0.6rem;
          width: calc(100% - 1rem);
          border-radius: 12px;
        }

        .pfp {
          width: 90px;
          height: 90px;
        }

        .name {
          font-size: clamp(1.2rem, 6vw, 1.5rem);
          margin: 0.8rem 0 0.4rem;
        }

        .location {
          font-size: 0.9rem;
          margin-bottom: 0.8rem;
        }

        .location svg {
          width: 14px;
          height: 14px;
        }

        .quote {
          font-size: 0.9rem;
          margin-bottom: 1rem;
          padding: 0;
          line-height: 1.5;
        }

        .badges {
          gap: 0.3rem;
          margin-bottom: 1.5rem;
          padding: 0;
        }

        .badge {
          padding: 0.25rem;
        }

        .badge img {
          width: 18px;
          height: 18px;
        }

        .links {
          max-width: 100%;
          gap: 10px;
          padding: 0 0.25rem;
        }

        .link {
          padding: 0.75rem 0.8rem;
          border-radius: 14px;
          min-height: 52px;
        }

        .link img {
          width: 28px;
          height: 28px;
          left: 10px;
        }

        .link span {
          font-size: 0.9rem;
          max-width: calc(100% - 60px);
          padding: 0 0.3rem;
        }

        .sound-toggle {
          right: 10px;
          bottom: 12px;
          padding: 0.4rem 0.5rem;
          font-size: 0.8rem;
        }

        .sound-toggle .dot {
          width: 7px;
          height: 7px;
        }

        .audio-player {
          padding: 0.7rem 0.8rem;
          margin-bottom: 1.2rem;
        }

        .audio-meta {
          font-size: 0.8rem;
        }

        .audio-title {
          font-size: 0.85rem;
        }

        .discord-presence {
          width: 16px;
          height: 16px;
          border-width: 2px;
        }

        footer {
          padding: 0.8rem 0.5rem;
          font-size: 0.8rem;
        }
        .pfp-wrap {
          width: 100px;
          height: 100px;
        }
      }

      /* Sehr kleine Smartphones */
      @media (max-width: 360px) {
        .card {
          padding: 0.8rem 0.5rem;
        }

        .pfp {
          width: 80px;
          height: 80px;
        }

        .name {
          font-size: 1.2rem;
        }

        .quote {
          font-size: 0.85rem;
        }

        .link {
          padding: 0.7rem 0.7rem;
          min-height: 48px;
        }

        .link img {
          width: 24px;
          height: 24px;
        }

        .link span {
          font-size: 0.85rem;
          max-width: calc(100% - 50px);
        }
      }

      /* Landscape-Modus für Smartphones */
      @media (max-height: 500px) and (orientation: landscape) {
        main {
          padding: 1rem 0.5rem;
        }

        .pfp {
          width: 70px;
          height: 70px;
        }

        .name {
          font-size: 1.3rem;
          margin: 0.5rem 0 0.3rem;
        }

        .quote {
          margin-bottom: 0.8rem;
        }

        .badges {
          margin-bottom: 1rem;
        }

        .link {
          padding: 0.6rem 0.8rem;
          min-height: 44px;
        }
      }

      /* Background anpassen */
      .bg {
        position: fixed;
        inset: 0;
        z-index: -1;
        overflow: hidden;
        max-width: 100vw;
      }

      .bg img,
      .bg video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        max-width: 100vw;
      }

      /* Lange URLs in Links kürzen */
      @media (max-width: 480px) {
        .link span {
          overflow: hidden;
          text-overflow: ellipsis;
          display: -webkit-box;
          -webkit-line-clamp: 2;
          line-clamp: 2;
          /* Max 2 Zeilen */
          -webkit-box-orient: vertical;
        }
      }

      .links.icons-only .link {
        justify-content: center;
        text-align: center;
        padding: 0.7rem;
        min-height: 64px;
        aspect-ratio: 1 / 1;
      }

      .links.icons-only .link img {
        position: static;
        left: auto;
        top: auto;
        transform: none;
        width: 36px;
        height: 36px;
      }

      .links.icons-only .link span {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .links.icons-only .link.no-icon {
        aspect-ratio: auto;
        padding: 0.8rem 1rem;
        min-height: 48px;
      }

      .links.icons-only .link.no-icon span {
        position: static;
        width: auto;
        height: auto;
        margin: 0;
        overflow: visible;
        clip: auto;
        white-space: normal;
      }

      .links.icons-only .link::after {
        content: attr(data-label);
        position: absolute;
        left: 50%;
        bottom: calc(100% + 8px);
        transform: translateX(-50%) translateY(4px);
        background: rgba(0, 0, 0, 0.7);
        color: var(--ink);
        padding: 0.25rem 0.6rem;
        border-radius: 8px;
        font-size: 0.75rem;
        font-weight: 600;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition:
          opacity 0.15s ease,
          transform 0.15s ease;
      }

      .links.icons-only .link:hover::after,
      .links.icons-only .link:focus-visible::after {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      .links.icons-only .link[data-label=""]::after {
        display: none;
      }

      .card.wide .links.icons-only .link {
        justify-content: center;
        text-align: center;
        padding-left: 0.7rem;
      }
    </style>
  </head>

  <body>
    <div class="bg" id="bg"></div>
    <div
      id="enterOverlay"
      class="enter-gate hidden"
      role="button"
      tabindex="0"
      aria-label="Enter site to enable media"
    >
      <div class="enter-box">
          <p id="enterText" class="enter-text">Click to enter</p>
      </div>
    </div>
    <button id="soundBtn" class="sound-toggle hidden" aria-label="Toggle sound">
      <span class="dot" aria-hidden="true"></span>
      <span id="soundLabel">Sound off</span>
    </button>
    <main>
      <div class="card" id="card">
        <div id="editorActions" class="editor-actions hidden">
          <a id="editCanvasBtn" class="edit-canvas-btn" href="#">Edit in canvas</a>
        </div>
        <div class="pfp-wrap">
          <img
            id="pfp"
            class="pfp"
            src="/static/icon.png"
            loading="lazy"
            decoding="async"
            alt="Profile picture"
          />
          <img
            id="pfpFrame"
            class="pfp-frame"
            src=""
            alt=""
            loading="lazy"
            decoding="async"
            style="display: none"
          />
          <span
            id="discordPresence"
            class="discord-presence hidden"
            role="img"
            aria-label="Discord status"
          ></span>
        </div>
        <div id="name" class="name">User</div>
        <div id="discordStatusLine" class="discord-status hidden">
          <span class="dot" aria-hidden="true"></span>
          <span id="discordStatusText" class="text"></span>
        </div>
        <div id="quote" class="quote">-</div>
        <div class="location" id="loc"></div>
        <div class="discord-badges hidden" id="discordBadges"></div>
        <div class="badges" id="badges"></div>

        <div id="audioPlayer" class="audio-player hidden">
          <div class="audio-meta">
            <div class="audio-title-wrap">
              <img
                id="audioIcon"
                class="audio-icon hidden"
                alt=""
                loading="lazy"
                decoding="async"
              />
              <span id="audioTitle" class="audio-title">Audio</span>
            </div>
            <span id="audioTime" class="audio-time">0:00 / 0:00</span>
          </div>
          <input
            id="audioSeek"
            class="audio-seek"
            type="range"
            min="0"
            max="0"
            value="0"
          />
          <div class="audio-controls">
            <button
              id="audioBack"
              class="audio-btn"
              type="button"
              aria-label="Back 10 seconds"
            >
              <svg viewBox="0 0 24 24" aria-hidden="true" fill="currentColor">
                <path d="M11 18V6l-6 6 6 6zM19 18V6l-6 6 6 6z" />
              </svg>
            </button>
            <button
              id="audioPlay"
              class="audio-btn primary"
              type="button"
              aria-label="Play or pause"
            >
              <svg
                class="icon-play"
                viewBox="0 0 24 24"
                aria-hidden="true"
                fill="currentColor"
              >
                <path d="M8 5v14l11-7z" />
              </svg>
              <svg
                class="icon-pause"
                viewBox="0 0 24 24"
                aria-hidden="true"
                fill="currentColor"
              >
                <path d="M6 5h4v14H6zm8 0h4v14h-4z" />
              </svg>
            </button>
            <button
              id="audioForward"
              class="audio-btn"
              type="button"
              aria-label="Forward 10 seconds"
            >
              <svg viewBox="0 0 24 24" aria-hidden="true" fill="currentColor">
                <path d="M13 6v12l6-6-6-6zM5 6v12l6-6-6-6z" />
              </svg>
            </button>
          </div>
        </div>
        <div class="links" id="links"></div>
        <div id="visitCounter" class="visit-counter" style="display: none">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
            />
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
            />
          </svg>
          <span id="visitCounterValue">0</span>
        </div>
      </div>
    </main>

    <footer>© <span id="year"></span> TAOMA™</footer>

    <script>
      async function resizeCursorImage(url, size = 32) {
        return new Promise((resolve, reject) => {
          const img = new Image();

          img.crossOrigin = "anonymous"; // Wichtig, falls das PNG von deiner Domain kommt
          img.onload = () => {
            // Canvas erstellen
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;

            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, size, size);

            // Bild proportional skalieren
            const scale = Math.min(size / img.width, size / img.height);
            const w = img.width * scale;
            const h = img.height * scale;

            const x = (size - w) / 2;
            const y = (size - h) / 2;

            ctx.drawImage(img, x, y, w, h);

            // Base64 URL erzeugen
            const resizedUrl = canvas.toDataURL("image/png");
            resolve(resizedUrl);
          };

          img.onerror = reject;
          img.src = url;
        });
      }

      (() => {
        "use strict";

        const yearEl = document.getElementById("year");
        if (yearEl) yearEl.textContent = new Date().getFullYear();

        const soundBtn = document.getElementById("soundBtn");
        const soundLabel = document.getElementById("soundLabel");
        const audioPlayer = document.getElementById("audioPlayer");
        const audioIcon = document.getElementById("audioIcon");
        const audioTitle = document.getElementById("audioTitle");
        const audioTime = document.getElementById("audioTime");
        const audioSeek = document.getElementById("audioSeek");
        const audioPlayBtn = document.getElementById("audioPlay");
        const audioBackBtn = document.getElementById("audioBack");
        const audioForwardBtn = document.getElementById("audioForward");
        let bgVideo = null;
        let bgAudio = null;
        let soundOn = false;
        let gateActive = false;
        let audioSeekActive = false;
        let audioCleanup = null;
        let quoteTypingToken = 0;

        function safeUrl(
          raw,
          { allowRelative = true, allowedProtocols = ["http:", "https:"] } = {},
        ) {
          if (typeof raw !== "string") return "";
          const trimmed = raw.trim();
          if (!trimmed) return "";
          if (/^javascript:/i.test(trimmed)) return "";
          try {
            const parsed = new URL(trimmed, window.location.origin);
            if (allowedProtocols.includes(parsed.protocol)) {
              if (
                (parsed.protocol === "http:" || parsed.protocol === "https:") &&
                !trimmed.startsWith("http") &&
                allowRelative
              ) {
                return trimmed;
              }
              return parsed.href;
            }
          } catch (_) {
            if (
              allowRelative &&
              trimmed.startsWith("/") &&
              !trimmed.startsWith("//")
            ) {
              return trimmed;
            }
          }
          if (
            allowRelative &&
            trimmed.startsWith("/") &&
            !trimmed.startsWith("//")
          ) {
            return trimmed;
          }
          return "";
        }

        const safeMediaUrl = (raw) =>
          safeUrl(raw, {
            allowRelative: true,
            allowedProtocols: ["http:", "https:"],
          });

        function hashString(input) {
          let h = 2166136261;
          const str = String(input || "");
          for (let i = 0; i < str.length; i += 1) {
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619);
          }
          return (h >>> 0).toString(16);
        }

        function hexToRgba(hex, alpha = 1) {
          const m = /^#?([a-fA-F0-9]{3}|[a-fA-F0-9]{6})$/.exec(
            (hex || "").trim(),
          );
          if (!m) return null;
          let h = m[1];
          if (h.length === 3)
            h = h
              .split("")
              .map((c) => c + c)
              .join("");
          const int = parseInt(h, 16);
          const r = (int >> 16) & 255;
          const g = (int >> 8) & 255;
          const b = int & 255;
          const a = Math.min(1, Math.max(0, alpha));
          return `rgba(${r}, ${g}, ${b}, ${a})`;
        }
        const safeLinkUrl = (raw) =>
          safeUrl(raw, {
            allowRelative: false,
            allowedProtocols: ["http:", "https:", "mailto:", "tel:"],
          });

        const VIDEO_EXTENSIONS = [".mp4", ".webm", ".m4v", ".mov"];
        const looksLikeVideo = (url) =>
          VIDEO_EXTENSIONS.some((ext) =>
            (url || "").toLowerCase().includes(ext),
          );

        function pickBackgroundSource(data, preferLite) {
          const primary = safeMediaUrl(data.background_url);
          const low =
            preferLite &&
            (safeMediaUrl(data.background_low_url) ||
              safeMediaUrl(data.background_preview_url) ||
              null);
          const chosen = (low || primary || "").trim();
          const isVideo = looksLikeVideo(chosen) || !!data.background_is_video;
          const useVideo =
            isVideo && !(preferLite && low && !looksLikeVideo(low));
          return { url: chosen, isVideo: useVideo };
        }

        function cleanMetaText(value, maxLen = 180) {
          if (value === undefined || value === null) return "";
          const text = String(value).replace(/\s+/g, " ").trim();
          if (!text) return "";
          return text.length > maxLen ? `${text.slice(0, maxLen - 1)}…` : text;
        }

        function resolveDisplayName(data) {
          const mode = (data && data.display_name_mode) || "slug";
          if (mode === "username") {
            return (data.user_username || data.slug || "").trim();
          }
          if (mode === "custom" && data.custom_display_name) {
            return String(data.custom_display_name).trim();
          }
          return (data.slug || data.user_username || "").trim();
        }

        function resolveQuoteText(data) {
          const list = Array.isArray(data?.quote_typing_texts)
            ? data.quote_typing_texts
            : [];
          for (const entry of list) {
            const text = String(entry || "").trim();
            if (text) return text;
          }
          const fallback = String(data?.quote || "").trim();
          return fallback;
        }

        function toAbsoluteUrl(raw) {
          if (!raw) return "";
          try {
            return new URL(raw, window.location.origin).href;
          } catch (_) {
            return raw;
          }
        }

        function setMetaProperty(prop, content) {
          if (!prop || !content) return;
          let el = document.querySelector(`meta[property="${prop}"]`);
          if (!el) {
            el = document.createElement("meta");
            el.setAttribute("property", prop);
            document.head.appendChild(el);
          }
          el.setAttribute("content", content);
        }

        function setMetaName(name, content) {
          if (!name || !content) return;
          let el = document.querySelector(`meta[name="${name}"]`);
          if (!el) {
            el = document.createElement("meta");
            el.setAttribute("name", name);
            document.head.appendChild(el);
          }
          el.setAttribute("content", content);
        }

        function setCanonical(url) {
          if (!url) return;
          let el = document.querySelector('link[rel="canonical"]');
          if (!el) {
            el = document.createElement("link");
            el.setAttribute("rel", "canonical");
            document.head.appendChild(el);
          }
          el.setAttribute("href", url);
        }

        function applyMeta(data, { bgUrl, bgIsVideo } = {}) {
          if (!data) return;
          const name = cleanMetaText(resolveDisplayName(data)) || "Custom Linktree";
          const title = `TAOMA™ – ${name}`;
          const quote = cleanMetaText(resolveQuoteText(data));
          const loc = cleanMetaText(data?.location);
          const description =
            quote || (loc ? `Location: ${loc}` : "Build your own powerful, customizable linktree");

          const url =
            data.is_template_demo || !data.slug
              ? window.location.href
              : new URL(
                  `/tree/${encodeURIComponent(data.slug)}`,
                  window.location.origin,
                ).href;

          let image = "";
          if (bgUrl && !bgIsVideo) image = bgUrl;
          if (!image) {
            image =
              safeMediaUrl(data.linktree_profile_picture) ||
              safeMediaUrl(data.profile_picture) ||
              safeMediaUrl(currentUser && currentUser.profile_picture) ||
              "/static/icon.png";
          }
          const ogImage = toAbsoluteUrl(image);

          document.title = title;
          setCanonical(url);
          setMetaProperty("og:title", title);
          setMetaProperty("og:description", description);
          setMetaProperty("og:image", ogImage);
          setMetaProperty("og:url", url);
          setMetaName("twitter:card", "summary_large_image");
          setMetaName("twitter:title", title);
          setMetaName("twitter:description", description);
          setMetaName("twitter:image", ogImage);
        }

        const DEFAULT_LINK_COLOR = "#e9ebff";
        const DEFAULT_LINK_BG = "#171b3b";
        const DEFAULT_CARD_COLOR = "#171b3b";
        const DEFAULT_TEXT_COLOR = "#e9ebff";
        const DEFAULT_NAME_COLOR = "#e9ebff";
        const DEFAULT_LOCATION_COLOR = "#a2a9c8";
        const DEFAULT_QUOTE_COLOR = "#e9ebff";
        const DEFAULT_ENTRY_BG_COLOR = "#0f1223";
        const DEFAULT_ENTRY_BG_ALPHA = 85;
        const DEFAULT_ENTRY_OVERLAY_ALPHA = 35;
        const DEFAULT_ENTRY_TEXT_COLOR = "#e9ebff";
        const DEFAULT_ENTRY_FONT_SIZE = 16;
        const DEFAULT_AUDIO_BG_COLOR = "#171b3b";
        const DEFAULT_AUDIO_BG_ALPHA = 60;
        const DEFAULT_AUDIO_TEXT_COLOR = "#e9ebff";
        const DEFAULT_AUDIO_ACCENT_COLOR = "#85a3ff";
        const DEFAULT_CURSOR_FX_ALPHA = 0.7;
        const LINK_COLUMNS_MIN = 1;
        const LINK_COLUMNS_MAX = 8;
        const CURSOR_IMAGE_SIZE = 32;
        const SECTION_ORDER_DEFAULT = [
          "pfp",
          "name",
          "discord_status",
          "quote",
          "location",
          "badges",
          "audio",
          "links",
          "visit_counter",
        ];
        const SECTION_KEY_ALIASES = {
          discord_badges: "badges",
        };
        const SECTION_ORDER_ALLOWED = new Set(SECTION_ORDER_DEFAULT);
        const CANVAS_PLATE_MIN_W = 1;
        const CANVAS_PLATE_MIN_H = 1;
        const CANVAS_PLATE_MAX_W = 20000;
        const CANVAS_PLATE_MAX_H = 20000;
        const CANVAS_SIZE_MIN_W = 1;
        const CANVAS_SIZE_MIN_H = 1;
        const CANVAS_LEGACY_GRID_DEFAULT = 8;

        function defaultPlateUnits(key) {
          switch (key) {
            case "pfp":
              return { w: 14, h: 14 };
            case "name":
              return { w: 24, h: 6 };
            case "discord_status":
              return { w: 24, h: 6 };
            case "quote":
              return { w: 32, h: 10 };
            case "location":
              return { w: 20, h: 5 };
            case "badges":
              return { w: 24, h: 8 };
            case "audio":
              return { w: 28, h: 8 };
            case "links":
              return { w: 32, h: 26 };
            case "visit_counter":
              return { w: 20, h: 6 };
            default:
              return { w: 18, h: 6 };
          }
        }

        function defaultPlatePixels(key) {
          const el = getSectionElement(key);
          if (el) {
            const rect = el.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              return { w: Math.round(rect.width), h: Math.round(rect.height) };
            }
          }
          const units = defaultPlateUnits(key);
          return {
            w: units.w * CANVAS_LEGACY_GRID_DEFAULT,
            h: units.h * CANVAS_LEGACY_GRID_DEFAULT,
          };
        }

        function computeCanvasContentBounds(layout) {
          const plates = layout?.plates || {};
          const groups = layout?.groups || {};
          let maxX = 0;
          let maxY = 0;
          Object.entries(plates).forEach(([key, plate]) => {
            if (!plate) return;
            const w = Number.isFinite(plate.w)
              ? plate.w
              : defaultPlatePixels(key).w;
            const h = Number.isFinite(plate.h)
              ? plate.h
              : defaultPlatePixels(key).h;
            const group =
              plate.group && groups[plate.group] ? groups[plate.group] : null;
            const offsetX = group ? group.x : 0;
            const offsetY = group ? group.y : 0;
            const x = (Number.isFinite(plate.x) ? plate.x : 0) + offsetX;
            const y = (Number.isFinite(plate.y) ? plate.y : 0) + offsetY;
            maxX = Math.max(maxX, x + w);
            maxY = Math.max(maxY, y + h);
          });
          return {
            w: Math.max(CANVAS_SIZE_MIN_W, maxX + 2),
            h: Math.max(CANVAS_SIZE_MIN_H, maxY + 2),
          };
        }

        function normalizeSectionOrder(raw) {
          let items = [];
          if (Array.isArray(raw)) {
            items = raw;
          } else if (typeof raw === "string") {
            try {
              const parsed = JSON.parse(raw);
              if (Array.isArray(parsed)) items = parsed;
            } catch (_) {
              items = [raw];
            }
          }
          const out = [];
          const seen = new Set();
          items.forEach((item) => {
            if (item === null || item === undefined) return;
            if (Array.isArray(item)) {
              const row = [];
              item.forEach((sub) => {
                const rawKey = String(sub || "").trim().toLowerCase();
                const key = SECTION_KEY_ALIASES[rawKey] || rawKey;
                if (!key || !SECTION_ORDER_ALLOWED.has(key)) return;
                if (seen.has(key)) return;
                seen.add(key);
                row.push(key);
              });
              if (row.length === 1) {
                out.push(row[0]);
              } else if (row.length > 1) {
                out.push(row.slice(0, 2));
              }
              return;
            }
            const rawKey = String(item || "").trim().toLowerCase();
            const key = SECTION_KEY_ALIASES[rawKey] || rawKey;
            if (!key || !SECTION_ORDER_ALLOWED.has(key)) return;
            if (seen.has(key)) return;
            seen.add(key);
            out.push(key);
          });
          SECTION_ORDER_DEFAULT.forEach((key) => {
            if (!seen.has(key)) {
              out.push(key);
              seen.add(key);
            }
          });
          return out;
        }

        function getSectionElement(key) {
          switch (key) {
            case "pfp":
              return document.querySelector(".pfp-wrap");
            case "name":
              return document.getElementById("name");
            case "discord_status":
              return document.getElementById("discordStatusLine");
            case "quote":
              return document.getElementById("quote");
            case "location":
              return document.getElementById("loc");
            case "badges":
              return document.getElementById("badges");
            case "discord_badges":
              return document.getElementById("badges");
            case "audio":
              return document.getElementById("audioPlayer");
            case "links":
              return document.getElementById("links");
            case "visit_counter":
              return document.getElementById("visitCounter");
            default:
              return null;
          }
        }

        function clearSectionRows(card) {
          const existingRows = card.querySelectorAll(".section-row");
          existingRows.forEach((row) => {
            while (row.firstChild) {
              card.insertBefore(row.firstChild, row);
            }
            row.remove();
          });
        }

        function resetCanvasLayout(card) {
          if (!card) return;
          clearSectionRows(card);
          card.classList.remove("canvas");
          card.style.removeProperty("min-height");
          card.style.removeProperty("width");
          card.style.removeProperty("height");
          card.style.removeProperty("max-width");
          card.style.removeProperty("padding");
          const groups = card.querySelectorAll(".plate-group");
          groups.forEach((group) => {
            while (group.firstChild) {
              card.insertBefore(group.firstChild, group);
            }
            group.remove();
          });
          SECTION_ORDER_DEFAULT.forEach((key) => {
            const el = getSectionElement(key);
            if (!el) return;
            el.classList.remove("canvas-plate");
            el.style.removeProperty("position");
            el.style.removeProperty("left");
            el.style.removeProperty("top");
            el.style.removeProperty("transform");
            el.style.removeProperty("margin");
            el.style.removeProperty("width");
            el.style.removeProperty("height");
            el.style.removeProperty("max-width");
            el.style.removeProperty("max-height");
            if (key === "pfp") {
              const img = el.querySelector(".pfp");
              if (img) {
                img.style.removeProperty("width");
                img.style.removeProperty("height");
              }
            }
          });
        }

        function flattenSectionOrder(order) {
          const list = [];
          (order || SECTION_ORDER_DEFAULT).forEach((item) => {
            if (Array.isArray(item)) {
              item.forEach((key) => list.push(key));
            } else {
              list.push(item);
            }
          });
          return list;
        }

        function buildDefaultCanvasLayout(order) {
          const plates = {};
          let y = 24;
          flattenSectionOrder(order).forEach((key) => {
            const size = defaultPlatePixels(key);
            plates[key] = { x: 24, y, w: size.w, h: size.h, group: null };
            y += size.h + 24;
          });
          const bounds = computeCanvasContentBounds({
            plates,
            groups: {},
          });
          return {
            enabled: true,
            grid: 1,
            size: { w: bounds.w, h: bounds.h },
            plates,
            groups: {},
          };
        }

        function normalizeCanvasLayout(raw, order) {
          if (!raw) return null;
          let data = raw;
          if (typeof raw === "string") {
            try {
              data = JSON.parse(raw);
            } catch (_) {
              return null;
            }
          }
          if (!data || typeof data !== "object") return null;
          const gridRaw = parseInt(data.grid ?? 1, 10);
          const legacyGrid = Number.isFinite(gridRaw) && gridRaw > 1 ? gridRaw : 1;
          const scale = legacyGrid;
          const fallback = buildDefaultCanvasLayout(order);
          const plates = {};
          const groups = {};
          let size = null;
          if (data.size && typeof data.size === "object") {
            const sw = parseInt(data.size.w ?? 0, 10);
            const sh = parseInt(data.size.h ?? 0, 10);
            if (Number.isFinite(sw) && Number.isFinite(sh)) {
              size = {
                w: Math.min(
                  CANVAS_PLATE_MAX_W,
                  Math.max(CANVAS_SIZE_MIN_W, sw * scale),
                ),
                h: Math.min(
                  CANVAS_PLATE_MAX_H,
                  Math.max(CANVAS_SIZE_MIN_H, sh * scale),
                ),
              };
            }
          }
          if (data.groups && typeof data.groups === "object") {
            Object.entries(data.groups).forEach(([gid, g]) => {
              if (!g || typeof g !== "object") return;
              const gx = parseInt(g.x ?? 0, 10);
              const gy = parseInt(g.y ?? 0, 10);
              if (!Number.isFinite(gx) || !Number.isFinite(gy)) return;
              groups[String(gid)] = { x: gx * scale, y: gy * scale };
            });
          }
          if (data.plates && typeof data.plates === "object") {
            Object.entries(data.plates).forEach(([key, plate]) => {
              const rawKey = String(key || "").trim().toLowerCase();
              const k = SECTION_KEY_ALIASES[rawKey] || rawKey;
              if (!k || !SECTION_ORDER_ALLOWED.has(k)) return;
              if (!plate || typeof plate !== "object") return;
              const px = parseInt(plate.x ?? 0, 10);
              const py = parseInt(plate.y ?? 0, 10);
              if (!Number.isFinite(px) || !Number.isFinite(py)) return;
              const entry = { x: px * scale, y: py * scale };
              const pw = parseInt(plate.w ?? 0, 10);
              const ph = parseInt(plate.h ?? 0, 10);
              if (Number.isFinite(pw) && pw > 0) {
                entry.w = Math.min(
                  CANVAS_PLATE_MAX_W,
                  Math.max(CANVAS_PLATE_MIN_W, pw * scale),
                );
              }
              if (Number.isFinite(ph) && ph > 0) {
                entry.h = Math.min(
                  CANVAS_PLATE_MAX_H,
                  Math.max(CANVAS_PLATE_MIN_H, ph * scale),
                );
              }
              if (plate.group && groups[plate.group]) {
                entry.group = plate.group;
              }
              plates[k] = entry;
            });
          }
          Object.keys(fallback.plates).forEach((key) => {
            if (!plates[key]) plates[key] = { ...fallback.plates[key] };
          });
          if (!size) {
            const bounds = computeCanvasContentBounds({ plates, groups });
            size = { w: bounds.w, h: bounds.h };
          }
          return {
            enabled: true,
            grid: 1,
            size,
            plates,
            groups,
          };
        }

        let pfpSizeOffsets = null;

        function capturePfpOffsets() {
          const wrap = document.querySelector(".pfp-wrap");
          const img = document.querySelector(".pfp");
          if (!wrap || !img) {
            pfpSizeOffsets = { imgW: 0, imgH: 0 };
            return;
          }
          const wrapRect = wrap.getBoundingClientRect();
          const imgRect = img.getBoundingClientRect();
          pfpSizeOffsets = {
            imgW: Math.round(imgRect.width - wrapRect.width),
            imgH: Math.round(imgRect.height - wrapRect.height),
          };
        }

        function applyCanvasLayout(rawLayout, rawOrder, { isMobile } = {}) {
          const card = document.getElementById("card");
          if (!card) return false;
          const layout = normalizeCanvasLayout(rawLayout, rawOrder);
          if (!layout) return false;
          resetCanvasLayout(card);
          card.classList.add("canvas");
          card.style.maxWidth = "none";
          if (!pfpSizeOffsets) capturePfpOffsets();
          const groupEls = {};
          Object.entries(layout.groups || {}).forEach(([gid, g]) => {
            const groupEl = document.createElement("div");
            groupEl.className = "plate-group";
            groupEl.dataset.groupId = gid;
            groupEl.style.transform = `translate(${g.x}px, ${g.y}px)`;
            card.appendChild(groupEl);
            groupEls[gid] = groupEl;
          });

          SECTION_ORDER_DEFAULT.forEach((key) => {
            const el = getSectionElement(key);
            if (!el) return;
            const plate = layout.plates[key];
            if (!plate) return;
            const parent = plate.group ? groupEls[plate.group] : card;
            if (!parent) return;
            el.classList.add("canvas-plate");
            el.style.position = "absolute";
            el.style.left = "0";
            el.style.top = "0";
            el.style.transform = `translate(${plate.x}px, ${plate.y}px)`;
            el.style.margin = "0";
            if (Number.isFinite(plate.w)) {
              const width = plate.w;
              el.style.width = `${width}px`;
              el.style.maxWidth = "none";
              if (key === "pfp") {
                const img = el.querySelector(".pfp");
                if (img && pfpSizeOffsets) {
                  img.style.width = `${width + pfpSizeOffsets.imgW}px`;
                }
              }
            }
            if (Number.isFinite(plate.h)) {
              const height = plate.h;
              el.style.height = `${height}px`;
              el.style.maxHeight = "none";
              if (key === "pfp") {
                const img = el.querySelector(".pfp");
                if (img && pfpSizeOffsets) {
                  img.style.height = `${height + pfpSizeOffsets.imgH}px`;
                }
              }
            }
            parent.appendChild(el);
          });

          if (layout.size && Number.isFinite(layout.size.w) && Number.isFinite(layout.size.h)) {
            card.style.width = `${layout.size.w}px`;
            card.style.height = `${layout.size.h}px`;
            card.style.minHeight = "";
          } else {
            const cardRect = card.getBoundingClientRect();
            let maxBottom = 0;
            let maxRight = 0;
            SECTION_ORDER_DEFAULT.forEach((key) => {
              const el = getSectionElement(key);
              if (!el) return;
              const rect = el.getBoundingClientRect();
              maxBottom = Math.max(maxBottom, rect.bottom - cardRect.top);
              maxRight = Math.max(maxRight, rect.right - cardRect.left);
            });
            if (maxBottom > 0) {
              card.style.minHeight = `${Math.ceil(maxBottom + 24)}px`;
            }
            if (maxRight > 0) {
              card.style.minWidth = "";
            }
          }
          return true;
        }

        function applySectionOrder(rawOrder) {
          const card = document.getElementById("card");
          if (!card) return false;
          resetCanvasLayout(card);
          const order = normalizeSectionOrder(rawOrder);
          let hasSideBySide = false;
          order.forEach((entry) => {
            if (Array.isArray(entry)) {
              const row = document.createElement("div");
              row.className = "section-row";
              entry.forEach((key) => {
                const el = getSectionElement(key);
                if (el) row.appendChild(el);
              });
              if (row.children.length > 1) {
                hasSideBySide = true;
                card.appendChild(row);
              } else if (row.children.length === 1) {
                card.appendChild(row.firstElementChild);
              }
            } else {
              const el = getSectionElement(entry);
              if (el) card.appendChild(el);
            }
          });
          return hasSideBySide;
        }

        function applySectionLayout(rawOrder, rawCanvas, { isMobile } = {}) {
          const usedCanvas = applyCanvasLayout(rawCanvas, rawOrder, { isMobile });
          if (usedCanvas) {
            return { usedCanvas: true, hasSideBySide: false };
          }
          const hasSideBySide = applySectionOrder(rawOrder);
          return { usedCanvas: false, hasSideBySide };
        }

        function sanitizeHexColor(raw) {
          if (typeof raw !== "string") return "";
          const trimmed = raw.trim();
          return /^#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(trimmed)
            ? trimmed
            : "";
        }

        function normalizeLinkColumns(raw, fallback) {
          if (raw === undefined || raw === null || raw === "") return fallback;
          const n = parseInt(raw, 10);
          if (Number.isNaN(n)) return fallback;
          return Math.min(LINK_COLUMNS_MAX, Math.max(LINK_COLUMNS_MIN, n));
        }

        function hexToRgb(hex) {
          const clean = sanitizeHexColor(hex);
          if (!clean) return null;
          const raw = clean.slice(1);
          const parts =
            raw.length === 3
              ? raw.split("").map((ch) => ch + ch)
              : [raw.slice(0, 2), raw.slice(2, 4), raw.slice(4, 6)];
          const [r, g, b] = parts.map((p) => parseInt(p, 16));
          return { r, g, b };
        }

        function rgbToRgba(rgb, alpha = 1) {
          if (!rgb) return "";
          const a = Math.min(1, Math.max(0, alpha));
          return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})`;
        }

        function lightenRgb(rgb, amount = 0.08) {
          const t = Math.min(1, Math.max(0, amount));
          return {
            r: Math.round(rgb.r + (255 - rgb.r) * t),
            g: Math.round(rgb.g + (255 - rgb.g) * t),
            b: Math.round(rgb.b + (255 - rgb.b) * t),
          };
        }

        function applyLinkStyles(linkColorRaw, linkBgRaw, linkBgAlphaRaw) {
          const rootStyle = document.documentElement.style;
          const linkColor =
            sanitizeHexColor(linkColorRaw) || DEFAULT_LINK_COLOR;
          const bgHex = sanitizeHexColor(linkBgRaw) || DEFAULT_LINK_BG;
          const bgRgb = hexToRgb(bgHex) || hexToRgb(DEFAULT_LINK_BG);
          const alpha =
            Math.min(100, Math.max(0, Number(linkBgAlphaRaw ?? 100))) / 100;
          const base = rgbToRgba(bgRgb, alpha);
          const hover = rgbToRgba(lightenRgb(bgRgb, 0.07), alpha);
          rootStyle.setProperty("--link-color", linkColor);
          rootStyle.setProperty("--link-bg", base || DEFAULT_LINK_BG);
          rootStyle.setProperty(
            "--link-bg-hover",
            hover || base || DEFAULT_LINK_BG,
          );
        }

        function applyLinkLayout(data, { isMobile, wantsWide } = {}) {
          const linksEl = document.getElementById("links");
          if (!linksEl) return;
          const defaultCols = !isMobile && wantsWide ? 2 : 1;
          const cols = normalizeLinkColumns(data?.link_columns, defaultCols);
          if (Number.isFinite(cols)) {
            linksEl.style.setProperty("--link-cols", String(cols));
          } else {
            linksEl.style.removeProperty("--link-cols");
          }
          linksEl.classList.toggle("icons-only", !!data?.link_icons_only);
        }

        function applyTextColors(data) {
          const rootStyle = document.documentElement.style;
          const base = sanitizeHexColor(data?.text_color) || DEFAULT_TEXT_COLOR;
          const location =
            sanitizeHexColor(data?.location_color) ||
            sanitizeHexColor(data?.text_color) ||
            DEFAULT_LOCATION_COLOR;
          const name =
            sanitizeHexColor(data?.name_color) ||
            sanitizeHexColor(data?.link_color) ||
            DEFAULT_NAME_COLOR;
          const quote =
            sanitizeHexColor(data?.quote_color) || base || DEFAULT_QUOTE_COLOR;

          rootStyle.setProperty("--ink", base);
          rootStyle.setProperty("--muted", location);
          rootStyle.setProperty("--name-color", name);
          rootStyle.setProperty("--location-color", location);
          rootStyle.setProperty("--quote-color", quote);
        }

        function applyQuoteEffectStrength(data) {
          const rootStyle = document.documentElement.style;
          const raw = Number(data?.quote_effect_strength);
          const strength = Number.isFinite(raw)
            ? Math.min(100, Math.max(0, raw))
            : 70;
          const scale = strength / 70;
          const clampPx = (val) => Math.max(0, Math.round(val));
          const glow = [8, 12, 18].map((v) => clampPx(v * scale));
          const neon = [6, 14, 24].map((v) => clampPx(v * scale));
          const drop = clampPx(10 * scale);
          rootStyle.setProperty("--quote-glow-1", `${glow[0]}px`);
          rootStyle.setProperty("--quote-glow-2", `${glow[1]}px`);
          rootStyle.setProperty("--quote-glow-3", `${glow[2]}px`);
          rootStyle.setProperty("--quote-neon-1", `${neon[0]}px`);
          rootStyle.setProperty("--quote-neon-2", `${neon[1]}px`);
          rootStyle.setProperty("--quote-neon-3", `${neon[2]}px`);
          rootStyle.setProperty("--quote-neon-drop", `${drop}px`);
        }

        function normalizeFontFamily(raw) {
          const value = String(raw || "default").toLowerCase();
          return ["default", "serif", "mono", "script", "display"].includes(value)
            ? value
            : "default";
        }

        function normalizeEffectName(raw) {
          const value = String(raw || "none").toLowerCase();
          return ["none", "glow", "neon", "rainbow"].includes(value)
            ? value
            : "none";
        }

        function applyNameStyles(data) {
          const nameEl = document.getElementById("name");
          if (!nameEl || !data) return;
          const mode = data.display_name_mode || "slug";
          if (mode === "username") {
            nameEl.textContent = data.user_username || data.slug || "User";
          } else if (mode === "custom" && data.custom_display_name) {
            nameEl.textContent = data.custom_display_name;
          } else {
            nameEl.textContent = data.slug || "User";
          }
          nameEl.classList.remove(
            "glow",
            "neon",
            "rainbow",
            "font-serif",
            "font-mono",
            "font-script",
            "font-display",
          );
          const fx = normalizeEffectName(data.name_effect);
          if (fx !== "none") nameEl.classList.add(fx);
          const fontFamily = normalizeFontFamily(data.name_font_family);
          if (fontFamily !== "default") {
            nameEl.classList.add(`font-${fontFamily}`);
          }
          if (data.user_id) {
            nameEl.dataset.id = `ID: ${data.user_id}`;
            nameEl.classList.add("has-id");
            nameEl.title = `ID: ${data.user_id}`;
          } else {
            nameEl.classList.remove("has-id");
            nameEl.removeAttribute("data-id");
            nameEl.removeAttribute("title");
          }
        }

        function applyQuoteStyles(data) {
          const quoteEl = document.getElementById("quote");
          if (!quoteEl || !data) return;
          quoteEl.classList.remove(
            "glow",
            "neon",
            "rainbow",
            "font-serif",
            "font-mono",
            "font-script",
            "font-display",
          );
          const fx = normalizeEffectName(data.quote_effect);
          if (fx !== "none") quoteEl.classList.add(fx);
          const fontFamily = normalizeFontFamily(data.quote_font_family);
          if (fontFamily !== "default") {
            quoteEl.classList.add(`font-${fontFamily}`);
          }
        }

        function stopQuoteTyping() {
          quoteTypingToken += 1;
        }

        function setQuoteCursorState(el, { active, blink } = {}) {
          if (!el) return;
          el.classList.toggle("quote-cursor", !!active);
          el.classList.toggle("cursor-blink", !!blink);
        }

        function startQuoteTyping(el, texts, opts = {}) {
          if (!el) return;
          const list = (texts || []).filter((t) => typeof t === "string");
          if (!list.length) {
            el.textContent = "";
            return;
          }
          const token = ++quoteTypingToken;
          const typeDelay =
            Number.isFinite(Number(opts.typeDelay)) &&
            Number(opts.typeDelay) > 0
              ? Number(opts.typeDelay)
              : 42;
          const eraseDelay =
            Number.isFinite(Number(opts.eraseDelay)) &&
            Number(opts.eraseDelay) > 0
              ? Number(opts.eraseDelay)
              : Math.max(20, Math.round(typeDelay * 0.7));
          const holdDelay =
            Number.isFinite(Number(opts.holdDelay)) &&
            Number(opts.holdDelay) >= 0
              ? Number(opts.holdDelay)
              : 1200;
          const gapDelay =
            Number.isFinite(Number(opts.gapDelay)) && Number(opts.gapDelay) >= 0
              ? Number(opts.gapDelay)
              : 320;
          let idx = 0;
          let pos = 0;
          let deleting = false;

          const tick = () => {
            if (token !== quoteTypingToken) return;
            const full = list[idx] || "";
            if (!deleting) {
              setQuoteCursorState(el, { active: true, blink: false });
              pos = Math.min(full.length, pos + 1);
              el.textContent = full.slice(0, pos);
              if (pos >= full.length) {
                deleting = true;
                setQuoteCursorState(el, { active: true, blink: true });
                setTimeout(tick, holdDelay);
                return;
              }
              setTimeout(tick, typeDelay);
            } else {
              setQuoteCursorState(el, { active: true, blink: false });
              pos = Math.max(0, pos - 1);
              el.textContent = full.slice(0, pos);
              if (pos <= 0) {
                deleting = false;
                idx = (idx + 1) % list.length;
                setQuoteCursorState(el, { active: true, blink: true });
                setTimeout(tick, gapDelay);
                return;
              }
              setTimeout(tick, eraseDelay);
            }
          };
          tick();
        }

        function updateQuoteDisplay(data) {
          const quoteEl = document.getElementById("quote");
          if (!quoteEl) return false;
          const texts = Array.isArray(data?.quote_typing_texts)
            ? data.quote_typing_texts
            : [];
          const quoteSize = Number(data?.quote_font_size);
          if (Number.isFinite(quoteSize) && quoteSize > 0) {
            const clamped = Math.min(40, Math.max(10, quoteSize));
            quoteEl.style.fontSize = `${clamped}px`;
          } else {
            quoteEl.style.removeProperty("font-size");
          }
          const cleaned = texts
            .map((t) => String(t || "").trim())
            .filter(Boolean)
            .slice(0, 3);
          if (!cleaned.length && data?.quote) {
            cleaned.push(String(data.quote).trim());
          }
          if (!cleaned.length) {
            stopQuoteTyping();
            setQuoteCursorState(quoteEl, { active: false, blink: false });
            quoteEl.textContent = "";
            return false;
          }
          const wantsTyping = !!data?.quote_typing_enabled;
          if (!wantsTyping || prefersReducedMotion()) {
            stopQuoteTyping();
            setQuoteCursorState(quoteEl, { active: false, blink: false });
            quoteEl.textContent = cleaned[0];
            return true;
          }
          setQuoteCursorState(quoteEl, { active: true, blink: false });
          const rawSpeed = Number(data?.quote_typing_speed);
          const speed = Number.isFinite(rawSpeed)
            ? Math.min(200, Math.max(20, rawSpeed))
            : 42;
          const rawPause = Number(data?.quote_typing_pause);
          const pause = Number.isFinite(rawPause)
            ? Math.min(10000, Math.max(200, rawPause))
            : 1200;
          startQuoteTyping(quoteEl, cleaned, {
            typeDelay: speed,
            eraseDelay: Math.max(20, Math.round(speed * 0.7)),
            holdDelay: pause,
          });
          return true;
        }

        function applyAudioPlayerStyles(data) {
          if (!audioPlayer) return;
          const bgHex =
            sanitizeHexColor(data?.audio_player_bg_color) ||
            DEFAULT_AUDIO_BG_COLOR;
          const bgRgb = hexToRgb(bgHex) || hexToRgb(DEFAULT_AUDIO_BG_COLOR);
          const rawAlpha = Number(data?.audio_player_bg_alpha);
          const alpha = Number.isFinite(rawAlpha)
            ? Math.min(100, Math.max(0, rawAlpha))
            : DEFAULT_AUDIO_BG_ALPHA;
          const bg = bgRgb ? rgbToRgba(bgRgb, alpha / 100) : "";
          const border = bgRgb
            ? rgbToRgba(
                lightenRgb(bgRgb, 0.12),
                Math.min(1, alpha / 100 + 0.12),
              )
            : "";
          const btnBg = bgRgb
            ? rgbToRgba(lightenRgb(bgRgb, 0.08), Math.min(1, alpha / 100 + 0.1))
            : "";
          const textHex =
            sanitizeHexColor(data?.audio_player_text_color) ||
            sanitizeHexColor(data?.text_color) ||
            DEFAULT_AUDIO_TEXT_COLOR;
          const textRgb =
            hexToRgb(textHex) || hexToRgb(DEFAULT_AUDIO_TEXT_COLOR);
          const muted = textRgb ? rgbToRgba(textRgb, 0.72) : "";
          const accentHex =
            sanitizeHexColor(data?.audio_player_accent_color) ||
            sanitizeHexColor(data?.link_color) ||
            DEFAULT_AUDIO_ACCENT_COLOR;

          if (bg) audioPlayer.style.setProperty("--audio-bg", bg);
          if (border) audioPlayer.style.setProperty("--audio-border", border);
          if (btnBg) audioPlayer.style.setProperty("--audio-btn-bg", btnBg);
          if (textHex) audioPlayer.style.setProperty("--audio-text", textHex);
          if (muted) audioPlayer.style.setProperty("--audio-muted", muted);
          if (accentHex)
            audioPlayer.style.setProperty("--audio-accent", accentHex);
        }

        let cursorFxMode = "none";
        let cursorFxColor = DEFAULT_AUDIO_ACCENT_COLOR;
        let cursorFxRgb = hexToRgb(DEFAULT_AUDIO_ACCENT_COLOR);
        let cursorFxAlpha = DEFAULT_CURSOR_FX_ALPHA;
        let cursorFxOffsetX = 0;
        let cursorFxOffsetY = 0;
        let cursorGlowEl = null;
        let cursorFxCanvas = null;
        let cursorFxCtx = null;
        let cursorFxParticles = [];
        let cursorFxRaf = null;
        let cursorFxLastTime = 0;
        let cursorFxLastSpawn = 0;
        let cursorFxLastX = 0;
        let cursorFxLastY = 0;
        let cursorFxSize = { width: 0, height: 0, dpr: 1 };
        let cursorFxMoveHandler = null;
        let cursorFxLeaveHandler = null;
        let cursorFxResizeHandler = null;
        let cursorFxImage = "";
        let cursorFxImageSrc = "";
        let cursorFxHasImage = false;

        function setCursorFxSettings({ color, alpha } = {}) {
          const clean = sanitizeHexColor(color) || DEFAULT_AUDIO_ACCENT_COLOR;
          cursorFxColor = clean;
          cursorFxRgb = hexToRgb(clean) || hexToRgb(DEFAULT_AUDIO_ACCENT_COLOR);
          const rawAlpha = Number(alpha);
          cursorFxAlpha = Number.isFinite(rawAlpha)
            ? Math.min(100, Math.max(0, rawAlpha)) / 100
            : DEFAULT_CURSOR_FX_ALPHA;
          document.documentElement.style.setProperty(
            "--cursor-fx-color",
            clean,
          );
        }

        function setCursorFxOffset(px) {
          const offset = Number.isFinite(px) ? px : 0;
          cursorFxOffsetX = offset;
          cursorFxOffsetY = offset;
        }

        function setCursorGlowImage(imageUrl, size = CURSOR_IMAGE_SIZE) {
          const root = document.documentElement;
          const hasImage = !!imageUrl;
          cursorFxHasImage = hasImage;
          if (hasImage) {
            root.style.setProperty("--cursor-fx-image", `url("${imageUrl}")`);
            root.style.setProperty("--cursor-fx-size", `${size}px`);
          } else {
            root.style.removeProperty("--cursor-fx-image");
            root.style.removeProperty("--cursor-fx-size");
          }
          if (cursorGlowEl) {
            cursorGlowEl.classList.toggle("shape", hasImage);
            cursorGlowEl.classList.toggle("circle", !hasImage);
          }
        }

        function prefersReducedMotion() {
          return (
            typeof window.matchMedia === "function" &&
            window.matchMedia("(prefers-reduced-motion: reduce)").matches
          );
        }

        function ensureCursorGlow() {
          if (cursorGlowEl) return cursorGlowEl;
          const el = document.createElement("div");
          el.className = cursorFxHasImage
            ? "cursor-glow shape"
            : "cursor-glow circle";
          el.setAttribute("aria-hidden", "true");
          document.body.appendChild(el);
          cursorGlowEl = el;
          return el;
        }

        function ensureCursorCanvas() {
          if (cursorFxCanvas && cursorFxCtx) return cursorFxCanvas;
          const canvas = document.createElement("canvas");
          canvas.className = "cursor-fx-canvas";
          canvas.setAttribute("aria-hidden", "true");
          document.body.appendChild(canvas);
          cursorFxCanvas = canvas;
          cursorFxCtx = canvas.getContext("2d");
          resizeCursorCanvas();
          return canvas;
        }

        function resizeCursorCanvas() {
          if (!cursorFxCanvas || !cursorFxCtx) return;
          const dpr = window.devicePixelRatio || 1;
          const width = window.innerWidth;
          const height = window.innerHeight;
          cursorFxSize = { width, height, dpr };
          cursorFxCanvas.width = Math.round(width * dpr);
          cursorFxCanvas.height = Math.round(height * dpr);
          cursorFxCanvas.style.width = `${width}px`;
          cursorFxCanvas.style.height = `${height}px`;
          cursorFxCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function spawnCursorParticles(x, y, speed) {
          const count = Math.min(6, Math.max(2, Math.round(speed / 8)));
          for (let i = 0; i < count; i += 1) {
            const life = 520 + Math.random() * 520;
            cursorFxParticles.push({
              x,
              y,
              vx: (Math.random() - 0.5) * 0.08,
              vy: 0.06 + Math.random() * 0.09,
              life,
              maxLife: life,
              size: 1 + Math.random() * 2.6,
            });
          }
          if (cursorFxParticles.length > 180) {
            cursorFxParticles.splice(0, cursorFxParticles.length - 180);
          }
        }

        function tickCursorParticles(now) {
          if (!cursorFxCtx) return;
          const dt = Math.min(32, now - cursorFxLastTime);
          cursorFxLastTime = now;
          cursorFxCtx.clearRect(0, 0, cursorFxSize.width, cursorFxSize.height);
          const rgb = cursorFxRgb || { r: 133, g: 163, b: 255 };
          for (let i = cursorFxParticles.length - 1; i >= 0; i -= 1) {
            const p = cursorFxParticles[i];
            p.life -= dt;
            if (p.life <= 0) {
              cursorFxParticles.splice(i, 1);
              continue;
            }
            p.vy += 0.0005 * dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            const alpha = (p.life / p.maxLife) * 0.85 * cursorFxAlpha;
            cursorFxCtx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            cursorFxCtx.beginPath();
            cursorFxCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            cursorFxCtx.fill();
          }
          if (cursorFxParticles.length || now - cursorFxLastSpawn < 140) {
            cursorFxRaf = requestAnimationFrame(tickCursorParticles);
          } else {
            cursorFxRaf = null;
          }
        }

        function startCursorGlow() {
          const el = ensureCursorGlow();
          el.style.display = "block";
          cursorFxMoveHandler = (event) => {
            el.style.left = `${event.clientX + cursorFxOffsetX}px`;
            el.style.top = `${event.clientY + cursorFxOffsetY}px`;
            el.style.opacity = String(cursorFxAlpha);
          };
          cursorFxLeaveHandler = (event) => {
            if (event.type === "mouseout" && event.relatedTarget) return;
            el.style.opacity = "0";
          };
          document.addEventListener("pointermove", cursorFxMoveHandler, {
            passive: true,
          });
          document.addEventListener("mouseout", cursorFxLeaveHandler, {
            passive: true,
          });
        }

        function startCursorParticles() {
          ensureCursorCanvas();
          if (cursorFxCanvas) cursorFxCanvas.style.display = "block";
          cursorFxParticles = [];
          cursorFxLastTime = performance.now();
          cursorFxLastSpawn = 0;
          cursorFxLastX = 0;
          cursorFxLastY = 0;
          cursorFxMoveHandler = (event) => {
            const x = event.clientX + cursorFxOffsetX;
            const y = event.clientY + cursorFxOffsetY;
            const speed = Math.hypot(x - cursorFxLastX, y - cursorFxLastY);
            cursorFxLastX = x;
            cursorFxLastY = y;
            const now = performance.now();
            if (now - cursorFxLastSpawn < 16) return;
            cursorFxLastSpawn = now;
            spawnCursorParticles(x, y, speed);
            if (!cursorFxRaf) {
              cursorFxLastTime = now;
              cursorFxRaf = requestAnimationFrame(tickCursorParticles);
            }
          };
          cursorFxResizeHandler = () => resizeCursorCanvas();
          document.addEventListener("pointermove", cursorFxMoveHandler, {
            passive: true,
          });
          window.addEventListener("resize", cursorFxResizeHandler, {
            passive: true,
          });
        }

        function stopCursorFx() {
          if (cursorFxMoveHandler) {
            document.removeEventListener("pointermove", cursorFxMoveHandler);
            cursorFxMoveHandler = null;
          }
          if (cursorFxLeaveHandler) {
            document.removeEventListener("mouseout", cursorFxLeaveHandler);
            cursorFxLeaveHandler = null;
          }
          if (cursorFxResizeHandler) {
            window.removeEventListener("resize", cursorFxResizeHandler);
            cursorFxResizeHandler = null;
          }
          if (cursorFxRaf) {
            cancelAnimationFrame(cursorFxRaf);
            cursorFxRaf = null;
          }
          cursorFxParticles = [];
          if (cursorFxCtx && cursorFxSize.width && cursorFxSize.height) {
            cursorFxCtx.clearRect(
              0,
              0,
              cursorFxSize.width,
              cursorFxSize.height,
            );
          }
          if (cursorFxCanvas) cursorFxCanvas.style.display = "none";
          if (cursorGlowEl) cursorGlowEl.style.opacity = "0";
          cursorFxMode = "none";
        }

        function applyCursorEffect(mode, { isMobile } = {}) {
          const normalized = String(mode || "none").toLowerCase();
          const allowed =
            normalized === "glow" || normalized === "particles"
              ? normalized
              : "none";
          const next =
            allowed === "none" || isMobile || prefersReducedMotion()
              ? "none"
              : allowed;
          if (next === cursorFxMode) return;
          stopCursorFx();
          if (next === "glow") startCursorGlow();
          if (next === "particles") startCursorParticles();
          cursorFxMode = next;
        }

        function createLocationIcon() {
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg",
          );
          svg.setAttribute("width", "16");
          svg.setAttribute("height", "16");
          svg.setAttribute("viewBox", "0 0 24 24");
          svg.setAttribute("fill", "currentColor");
          svg.setAttribute("aria-hidden", "true");
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );
          path.setAttribute(
            "d",
            "M12 2C7.6 2 4 5.6 4 10c0 5.3 8 12 8 12s8-6.7 8-12c0-4.4-3.6-8-8-8zm0 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6z",
          );
          svg.appendChild(path);
          return svg;
        }

        const PRESENCE_LABELS = {
          online: "Online",
          idle: "Idle",
          dnd: "Do not disturb",
          offline: "Offline",
        };
        const PRESENCE_CLASSES = [
          "status-online",
          "status-idle",
          "status-dnd",
          "status-offline",
        ];

        function normalizePresence(raw) {
          const key = String(raw || "online").toLowerCase();
          return ["online", "idle", "dnd", "offline"].includes(key)
            ? key
            : "online";
        }

        function applyPresenceClass(el, presence) {
          if (!el) return;
          PRESENCE_CLASSES.forEach((cls) => el.classList.remove(cls));
          el.classList.add(`status-${normalizePresence(presence)}`);
        }

        function formatTime(seconds) {
          if (!Number.isFinite(seconds) || seconds <= 0) return "0:00";
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${String(secs).padStart(2, "0")}`;
        }

        function stripFileExtension(name) {
          if (!name) return "";
          const base = String(name).trim();
          const dot = base.lastIndexOf(".");
          if (dot <= 0) return base;
          return base.slice(0, dot);
        }

        function getAudioTitle(url) {
          if (!url) return "Audio";
          try {
            const u = new URL(url, window.location.origin);
            const name = (u.pathname || "").split("/").pop();
            if (name) return stripFileExtension(decodeURIComponent(name));
          } catch (_) {}
          return "Audio";
        }

        function syncAudioUI() {
          if (!audioPlayer || !audioSeek || !audioTime || !audioPlayBtn) return;
          if (!bgAudio) {
            audioTime.textContent = "0:00 / 0:00";
            audioSeek.value = "0";
            audioSeek.max = "0";
            audioPlayBtn.classList.remove("is-playing");
            audioPlayBtn.setAttribute("aria-label", "Play");
            return;
          }
          const duration = Number.isFinite(bgAudio.duration)
            ? bgAudio.duration
            : 0;
          const current = Number.isFinite(bgAudio.currentTime)
            ? bgAudio.currentTime
            : 0;
          if (!audioSeekActive) {
            audioSeek.max = duration ? String(duration) : "0";
            audioSeek.value = String(
              Math.min(current, duration || current || 0),
            );
          }
          audioTime.textContent = `${formatTime(current)} / ${formatTime(
            duration,
          )}`;
          const playing = !bgAudio.paused;
          audioPlayBtn.classList.toggle("is-playing", playing);
          audioPlayBtn.setAttribute("aria-label", playing ? "Pause" : "Play");
        }

        function bindAudioPlayer(audio) {
          if (!audio) return () => {};
          const update = () => syncAudioUI();
          const onPlay = () => syncAudioUI();
          const onPause = () => syncAudioUI();
          audio.addEventListener("timeupdate", update);
          audio.addEventListener("loadedmetadata", update);
          audio.addEventListener("play", onPlay);
          audio.addEventListener("pause", onPause);
          audio.addEventListener("ended", onPause);
          return () => {
            audio.removeEventListener("timeupdate", update);
            audio.removeEventListener("loadedmetadata", update);
            audio.removeEventListener("play", onPlay);
            audio.removeEventListener("pause", onPause);
            audio.removeEventListener("ended", onPause);
          };
        }

        function updateSoundUI() {
          if (!soundBtn) return;
          soundBtn.classList.toggle("on", soundOn);
          soundLabel.textContent = soundOn ? "Sound on" : "Sound off";
        }

        function showGate(show) {
          const gate = document.getElementById("enterOverlay");
          if (!gate) return;
          if (show) {
            gate.classList.remove("hidden");
            gateActive = true;
            gate.focus({ preventScroll: true });
          } else {
            gate.classList.add("hidden");
            gateActive = false;
          }
        }

        async function turnSoundOn() {
          try {
            if (bgAudio) {
              bgAudio.muted = false;
              await bgAudio.play().catch(() => {});
            } else if (bgVideo) {
              bgVideo.muted = false;
              await bgVideo.play().catch(() => {});
            } else {
              return;
            }
            soundOn = true;
            updateSoundUI();
            soundBtn.classList.remove("hidden");
            syncAudioUI();
          } catch (_) {
            // bleibt off
          }
        }

        function turnSoundOff() {
          try {
            if (bgAudio) {
              bgAudio.muted = true;
            }
            if (bgVideo) {
              bgVideo.muted = true;
            }
            soundOn = false;
            updateSoundUI();
            syncAudioUI();
          } catch (_) {}
        }

        async function playBackgroundVideo(unmute) {
          if (!bgVideo) return false;
          const tryPlay = async (mute) => {
            bgVideo.muted = mute;
            try {
              await bgVideo.play();
              return true;
            } catch (_) {
              return false;
            }
          };
          if (unmute) {
            if (await tryPlay(false)) return true;
            if (await tryPlay(true)) return true;
          } else if (await tryPlay(true)) {
            return true;
          }
          return false;
        }

        if (soundBtn) {
          soundBtn.addEventListener("click", () => {
            if (soundOn) turnSoundOff();
            else turnSoundOn();
          });
        }

        if (audioSeek) {
          audioSeek.addEventListener("pointerdown", () => {
            audioSeekActive = true;
          });
          audioSeek.addEventListener("pointerup", () => {
            audioSeekActive = false;
            syncAudioUI();
          });
          audioSeek.addEventListener("pointercancel", () => {
            audioSeekActive = false;
            syncAudioUI();
          });
          audioSeek.addEventListener("input", () => {
            if (!bgAudio) return;
            const nextTime = Number(audioSeek.value || 0);
            if (Number.isFinite(nextTime)) bgAudio.currentTime = nextTime;
          });
        }

        if (audioPlayBtn) {
          audioPlayBtn.addEventListener("click", async () => {
            if (!bgAudio) return;
            if (bgAudio.paused) {
              await turnSoundOn();
            } else {
              bgAudio.pause();
            }
            syncAudioUI();
          });
        }

        if (audioBackBtn) {
          audioBackBtn.addEventListener("click", () => {
            if (!bgAudio) return;
            bgAudio.currentTime = Math.max(0, bgAudio.currentTime - 10);
            syncAudioUI();
          });
        }

        if (audioForwardBtn) {
          audioForwardBtn.addEventListener("click", () => {
            if (!bgAudio || !Number.isFinite(bgAudio.duration)) return;
            bgAudio.currentTime = Math.min(
              bgAudio.duration,
              bgAudio.currentTime + 10,
            );
            syncAudioUI();
          });
        }

        async function enterExperience() {
          showGate(false);
          if (gateCacheKey) {
            try {
              sessionStorage.setItem(gateCacheKey, "1");
            } catch (_) {}
          }
          if (bgVideo) {
            bgVideo.dataset.userReady = "1";
            bgVideo.dataset.wantSound = bgAudio ? "0" : "1";
            const ok = await playBackgroundVideo(!bgAudio);
            if (ok && !bgAudio) {
              soundOn = !bgVideo.muted;
              updateSoundUI();
            }
          }
          if (bgAudio) {
            bgAudio.muted = false;
            bgAudio
              .play()
              .then(() => {
                soundOn = true;
                updateSoundUI();
                syncAudioUI();
              })
              .catch(() => {});
          }
        }

        const gate = document.getElementById("enterOverlay");
        if (gate) {
          gate.addEventListener("click", enterExperience);
          gate.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              enterExperience();
            }
          });
        }

        // Ein “erster User-Input” schaltet optional sofort Ton an
        const firstGesture = () => {
          turnSoundOn();
          window.removeEventListener("pointerdown", firstGesture);
        };
        window.addEventListener("pointerdown", firstGesture, { once: true });

        const CACHE_PREFIX = "taoma:linktree:v1:";
        const CACHE_MS = 90 * 1000; // short-lived cache to speed up repeat visits
        let lastData = null;
        let initialRenderDone = false;
        let lastMediaMode = null;
        let lastDevice = null;
        let lastMediaSig = null;
        let lastBgSig = null;
        let lastAudioSig = null;
        let lastCursorSig = null;
        let gateCacheKey = null;
        let discordStatusCache = null;
        let discordStatusPromise = null;

        function getConnectionProfile() {
          const conn =
            navigator.connection ||
            navigator.mozConnection ||
            navigator.webkitConnection;
          const downlink =
            conn && typeof conn.downlink === "number" ? conn.downlink : null;
          return {
            saveData:
              !!(conn && conn.saveData) ||
              (typeof window.matchMedia === "function" &&
                window.matchMedia("(prefers-reduced-data: reduce)").matches),
            effectiveType: (conn && conn.effectiveType) || "",
            downlink,
          };
        }

        function shouldUseLiteMedia(profile = getConnectionProfile()) {
          const dl =
            typeof profile.downlink === "number" ? profile.downlink : null;
          const slow =
            profile.saveData ||
            ["slow-2g", "2g", "3g"].includes(profile.effectiveType || "") ||
            (dl !== null && dl < 1.5);
          return !!slow;
        }

        function makeCacheKey({ slug, templateId, device }) {
          if (templateId) return `${CACHE_PREFIX}tpl:${templateId}:${device}`;
          return `${CACHE_PREFIX}slug:${slug || "anon"}:${device}`;
        }

        function readCachedTree(key) {
          try {
            const raw = sessionStorage.getItem(key);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed.savedAt !== "number" || !parsed.data)
              return null;
            if (Date.now() - parsed.savedAt > CACHE_MS) {
              sessionStorage.removeItem(key);
              return null;
            }
            return parsed.data;
          } catch (_) {
            return null;
          }
        }

        function writeCachedTree(key, data) {
          try {
            sessionStorage.setItem(
              key,
              JSON.stringify({ savedAt: Date.now(), data: data || null }),
            );
          } catch (_) {}
        }

        async function fetchDiscordStatus() {
          if (discordStatusCache !== null) return discordStatusCache;
          if (discordStatusPromise) return discordStatusPromise;
          discordStatusPromise = (async () => {
            try {
              const r = await fetch("/api/discord/status", {
                credentials: "include",
              });
              if (!r.ok) throw new Error("discord status failed");
              const json = await r.json();
              discordStatusCache = json || { linked: false };
            } catch (_) {
              discordStatusCache = { linked: false };
            } finally {
              discordStatusPromise = null;
            }
            return discordStatusCache;
          })();
          return discordStatusPromise;
        }

        const MOCK_DISCORD_BADGES = [
          {
            code: "nitro",
            label: "Discord Nitro",
            icon_url: "/static/discord-badges/discordnitro.svg",
          },
          {
            code: "hypesquad",
            label: "HypeSquad Brilliance",
            icon_url: "/static/discord-badges/hypesquadbrilliance.svg",
          },
          {
            code: "early_supporter",
            label: "Early Supporter",
            icon_url: "/static/discord-badges/discordearlysupporter.svg",
          },
          {
            code: "bug_hunter",
            label: "Bug Hunter",
            icon_url: "/static/discord-badges/discordbughunter1.svg",
          },
        ];
        const MOCK_STATUS_TEXTS = [
          "Building something new",
          "Open for collabs",
          "On the grind",
          "Ideas in motion",
          "Be right back",
        ];
        const MOCK_USERNAMES = ["DemoUser", "TemplateUser", "LinktreeFan"];

        function seededInt(seed, max) {
          const mod = Number(max) || 0;
          if (mod <= 0) return 0;
          const raw = parseInt(hashString(seed), 16);
          if (!Number.isFinite(raw)) return 0;
          return Math.abs(raw) % mod;
        }

        function seededRange(seed, min, max) {
          const lo = Number(min) || 0;
          const hi = Number(max) || 0;
          if (hi <= lo) return lo;
          return lo + seededInt(seed, hi - lo + 1);
        }

        function getDemoSeed(data, user) {
          const base = (data && (data.template_id || data.slug)) || "template";
          const userPart = user && user.id ? `u${user.id}` : "anon";
          return `${base}|${userPart}`;
        }

        function pickMockBadges(seed, count) {
          const list = MOCK_DISCORD_BADGES.slice();
          if (!list.length) return [];
          const take = Math.min(Math.max(1, count || 1), list.length);
          const start = seededInt(seed, list.length);
          const out = [];
          for (let i = 0; i < take; i += 1) {
            out.push(list[(start + i) % list.length]);
          }
          return out;
        }

        function buildMockDiscordData(seed) {
          const presenceOptions = ["online", "idle", "dnd"];
          const presence =
            presenceOptions[
              seededInt(`${seed}:presence`, presenceOptions.length)
            ];
          const statusText =
            MOCK_STATUS_TEXTS[
              seededInt(`${seed}:status`, MOCK_STATUS_TEXTS.length)
            ];
          const badgeCount = seededRange(`${seed}:badgeCount`, 2, 3);
          const badges = pickMockBadges(`${seed}:badges`, badgeCount);
          const decoration =
            badges[0] && badges[0].icon_url
              ? badges[0].icon_url
              : "/static/discord-badges/discordnitro.svg";
          return {
            linked: true,
            presence,
            status_text: statusText,
            badges,
            decoration_url: decoration,
          };
        }

        function buildMockVisitCount(seed) {
          return seededRange(`${seed}:visits`, 1200, 58900);
        }

        function buildMockUsername(seed) {
          return (
            MOCK_USERNAMES[seededInt(`${seed}:user`, MOCK_USERNAMES.length)] ||
            "DemoUser"
          );
        }

        function buildMockProfilePicture() {
          return "/static/icon.png";
        }

        async function fetchUserLinktreeForDemo(user, device) {
          if (!user) return null;
          const slug = String(user.linktree_slug || "").trim();
          if (slug) {
            try {
              const r = await fetch(
                `/api/linktrees/by-slug/${encodeURIComponent(
                  slug,
                )}/manage?device=${encodeURIComponent(device || "pc")}`,
                { credentials: "include" },
              );
              if (r.ok) return await r.json();
            } catch (_) {}
          }
          if (user.linktree_id) {
            try {
              const r = await fetch(
                `/api/linktrees/${encodeURIComponent(user.linktree_id)}/manage`,
                { credentials: "include" },
              );
              if (r.ok) return await r.json();
            } catch (_) {}
          }
          return null;
        }

        async function hydrateTemplateDemoData(baseData, device, userPromise) {
          if (!baseData || !baseData.is_template_demo)
            return { data: baseData, changed: false };
          const data = { ...baseData };
          let changed = false;
          let user = null;
          try {
            user = await userPromise.catch(() => null);
          } catch (_) {
            user = null;
          }
          if (user) currentUser = currentUser || user;

          const seed = getDemoSeed(data, user);
          const userName = user && user.username ? user.username : null;
          const userPfp =
            user && user.profile_picture ? user.profile_picture : null;

          if (userName) {
            if (data.user_username !== userName) {
              data.user_username = userName;
              changed = true;
            }
          } else {
            const mockName = buildMockUsername(seed);
            if (data.user_username !== mockName) {
              data.user_username = mockName;
              changed = true;
            }
          }

          const resolvedPfp = userPfp || buildMockProfilePicture();
          if (data.profile_picture !== resolvedPfp) {
            data.profile_picture = resolvedPfp;
            changed = true;
          }

          const needsDiscord =
            data.discord_frame_enabled ||
            data.discord_presence_enabled ||
            data.discord_status_enabled ||
            data.discord_badges_enabled;
          const needsVisit = !!data.show_visit_counter;

          let userLinktree = null;
          if ((needsDiscord || needsVisit) && user) {
            userLinktree = await fetchUserLinktreeForDemo(user, device);
          }

          if (needsVisit) {
            let visitCount = null;
            if (
              userLinktree &&
              Number.isFinite(Number(userLinktree.visit_count))
            ) {
              visitCount = Number(userLinktree.visit_count);
            }
            if (
              visitCount === null &&
              Number.isFinite(Number(data.visit_count)) &&
              Number(data.visit_count) > 0
            ) {
              visitCount = Number(data.visit_count);
            }
            if (visitCount === null) {
              visitCount = buildMockVisitCount(seed);
            }
            if (data.visit_count !== visitCount) {
              data.visit_count = visitCount;
              changed = true;
            }
          }

          if (needsDiscord) {
            let discordSource = null;
            if (userLinktree && userLinktree.discord_linked) {
              discordSource = {
                linked: true,
                presence: userLinktree.discord_presence,
                status_text: userLinktree.discord_status_text,
                badges: userLinktree.discord_badges,
                decoration_url: userLinktree.discord_decoration_url,
              };
            } else if (!userLinktree) {
              const status = await fetchDiscordStatus();
              if (status && status.linked) {
                discordSource = status;
              }
            }

            if (discordSource && discordSource.linked) {
              data.discord_linked = true;
              if (discordSource.presence)
                data.discord_presence = discordSource.presence;
              if (discordSource.status_text)
                data.discord_status_text = discordSource.status_text;
              if (Array.isArray(discordSource.badges))
                data.discord_badges = discordSource.badges;
              if (discordSource.decoration_url)
                data.discord_decoration_url = discordSource.decoration_url;
              changed = true;
            } else {
              const mock = buildMockDiscordData(seed);
              data.discord_linked = true;
              if (data.discord_presence_enabled && !data.discord_presence) {
                data.discord_presence = mock.presence;
              } else if (data.discord_presence_enabled) {
                data.discord_presence = data.discord_presence || mock.presence;
              }
              if (data.discord_status_enabled && !data.discord_status_text) {
                data.discord_status_text = mock.status_text;
              }
              if (data.discord_badges_enabled) {
                data.discord_badges = mock.badges;
              }
              if (data.discord_frame_enabled && !data.discord_decoration_url) {
                data.discord_decoration_url = mock.decoration_url;
              }
              changed = true;
            }
          }

          return { data, changed };
        }

        async function hydrateTemplateDemo(
          data,
          device,
          userPromise,
          preferLite,
        ) {
          if (!data || !data.is_template_demo) return data;
          try {
            const res = await hydrateTemplateDemoData(
              data,
              device,
              userPromise,
            );
            if (!res || !res.changed) return data;
            const next = res.data || data;
            lastData = next;
            renderTree(next, { preferLite, fromCache: true, device });
            return next;
          } catch (_) {
            return data;
          }
        }

        let currentUser = null;

        async function fetchSessionUser() {
          try {
            const r = await fetch("/api/auth/verify", {
              credentials: "include",
            });
            if (!r.ok) return null;
            const json = await r.json();
            currentUser = json && json.user ? json.user : null;
            if (currentUser && lastData) {
              updateEditorLink(lastData);
            }
            return currentUser;
          } catch (_) {
            return null;
          }
        }

        function updateEditorLink(data) {
          const actions = document.getElementById("editorActions");
          const btn = document.getElementById("editCanvasBtn");
          if (!actions || !btn || !data) return;
          const slug = data.slug || "";
          const ownerMatch =
            currentUser &&
            (currentUser.linktree_slug === slug ||
              currentUser.username === data.user_username);
          actions.classList.toggle("hidden", !ownerMatch);
          if (ownerMatch) {
            btn.href = `/linktree_canvas.html?slug=${encodeURIComponent(
              slug
            )}&device=${encodeURIComponent(lastDevice || "pc")}`;
          }
        }

        function detectDevice(requestedDevice) {
          return requestedDevice === "mobile"
            ? "mobile"
            : requestedDevice === "pc"
              ? "pc"
              : window.matchMedia("(max-width: 720px)").matches
                ? "mobile"
                : "pc";
        }

        let visibilityHandlerAdded = false;

        async function fetchTreeData({ templateId, slug, device }) {
          if (templateId) {
            const r = await fetch(
              `/api/marketplace/templates/${encodeURIComponent(templateId)}`,
              { credentials: "include" },
            );
            if (!r.ok) return null;
            const tpl = await r.json();
            const variants = tpl.variants || [];
            const chosen =
              variants.find((v) => v.device_type === device) ||
              variants[0] ||
              tpl.data ||
              {};
            const data = { ...(chosen || {}) };
            data.slug = data.slug || tpl.name || "Template";
            data.device_type = data.device_type || device;
            data.user_username =
              data.user_username || tpl.owner_username || "Template";
            data.profile_picture =
              data.profile_picture || tpl.preview_image_url || null;
            data.template_id = tpl.id || templateId || null;
            data.is_template_demo = true;
            return data;
          }

          const r = await fetch(
            `/api/linktrees/${encodeURIComponent(slug)}?device=${device}`,
          );
          if (!r.ok) return null;
          return await r.json();
        }

        function renderTree(
          data,
          {
            preferLite = shouldUseLiteMedia(),
            fromCache = false,
            device = detectDevice(),
          } = {},
        ) {
          if (!data) return;
          lastData = data;
          lastMediaMode = preferLite ? "lite" : "full";
          lastDevice = device;
          updateEditorLink(data);
          const isMobile = device === "mobile";
          const layoutResult = applySectionLayout(
            data.section_order,
            data.canvas_layout,
            { isMobile },
          );
          const hasSideBySide = layoutResult.hasSideBySide;
          const usedCanvas = layoutResult.usedCanvas;
          let needsGate = false;

          const bgSource = pickBackgroundSource(data, preferLite);
          const bgUrlNext = bgSource.url || "";
          const bgIsVideoNext = bgSource.isVideo;
          applyMeta(data, { bgUrl: bgUrlNext, bgIsVideo: bgIsVideoNext });
          const songUrlNext = safeMediaUrl(data.song_url);
          const songIconUrlNext = safeMediaUrl(data.song_icon_url);
          const showAudioPlayer = !!data.show_audio_player && !!songUrlNext;
          const cursorUrl = safeMediaUrl(data.cursor_url);
          const bgSig = hashString(
            `bg|${bgIsVideoNext ? "v" : "i"}|${bgUrlNext}`,
          );
          const audioSig = hashString(
            `audio|${songUrlNext}|${songIconUrlNext}|${
              showAudioPlayer ? "1" : "0"
            }`,
          );
          const cursorSig = hashString(
            `cursor|${cursorUrl}|${data.cursor_effect || "none"}|${
              isMobile ? "m" : "d"
            }|${data.cursor_effect_color || ""}|${
              data.cursor_effect_alpha ?? ""
            }`,
          );
          const mediaSig = hashString(`${bgSig}|${audioSig}|${cursorSig}`);
          const bgChanged = bgSig !== lastBgSig;
          const audioChanged = audioSig !== lastAudioSig;
          gateCacheKey = `taoma:linktree:gate:${mediaSig}`;
          const gateDismissed = (() => {
            try {
              return sessionStorage.getItem(gateCacheKey) === "1";
            } catch (_) {
              return false;
            }
          })();

          const bgEl = document.getElementById("bg");
          if (bgChanged) {
            bgVideo = null;
            if (bgEl) {
              bgEl.textContent = "";
              if (bgUrlNext) {
                if (bgIsVideoNext) {
                  const video = document.createElement("video");
                  video.id = "bgvid";
                  video.src = bgUrlNext;
                  video.autoplay = false;
                  video.muted = true;
                  video.loop = true;
                  video.setAttribute("muted", "");
                  video.setAttribute("playsinline", "");
                  video.setAttribute("webkit-playsinline", "");
                  video.preload = preferLite ? "metadata" : "auto";
                  if (preferLite) {
                    video.setAttribute("data-lite", "true");
                  }
                  video.addEventListener("loadeddata", () => {
                    if (bgVideo !== video) return;
                    if (video.dataset.userReady !== "1" || document.hidden)
                      return;
                    playBackgroundVideo(video.dataset.wantSound === "1");
                  });
                  bgEl.appendChild(video);
                  bgVideo = video;
                  needsGate = true;
                  if (!visibilityHandlerAdded) {
                    document.addEventListener("visibilitychange", () => {
                      if (!document.hidden && !gateActive && bgVideo) {
                        playBackgroundVideo(bgVideo.dataset.wantSound === "1");
                      }
                    });
                    visibilityHandlerAdded = true;
                  }
                } else {
                  const img = document.createElement("img");
                  img.src = bgUrlNext;
                  img.alt = "Background";
                  img.loading = "lazy";
                  img.decoding = "async";
                  bgEl.appendChild(img);
                }
              }
            }
          }
          if (bgEl) {
            bgEl.classList.remove("night", "rain", "snow");
            if (data.background_effect && data.background_effect !== "none") {
              bgEl.classList.add(data.background_effect);
            }
          }

          // Audio (Song hat Vorrang vor Video-Ton)
          if (audioChanged) {
            if (bgAudio) {
              try {
                bgAudio.pause();
              } catch {}
              if (audioCleanup) {
                audioCleanup();
                audioCleanup = null;
              }
              bgAudio.remove();
              bgAudio = null;
            }
          }
          syncAudioUI();
          if (audioPlayer) {
            applyAudioPlayerStyles(data);
            audioPlayer.classList.toggle("hidden", !showAudioPlayer);
          }
          if (audioIcon) {
            if (songIconUrlNext) {
              const abs = (() => {
                try {
                  return new URL(songIconUrlNext, window.location.origin).href;
                } catch (_) {
                  return songIconUrlNext;
                }
              })();
              if (audioIcon.src !== abs) audioIcon.src = songIconUrlNext;
              audioIcon.classList.remove("hidden");
            } else {
              audioIcon.removeAttribute("src");
              audioIcon.classList.add("hidden");
            }
          }
          if (showAudioPlayer && audioTitle) {
            const songName = (data.song_name || "").trim();
            const title =
              stripFileExtension(songName) || getAudioTitle(songUrlNext);
            audioTitle.style.display = "";
            audioTitle.textContent = title || "Audio";
          }
          if (songUrlNext) {
            if (!bgAudio) {
              bgAudio = document.createElement("audio");
              bgAudio.src = songUrlNext;
              bgAudio.loop = true;
              bgAudio.preload = preferLite ? "metadata" : "auto";
              bgAudio.muted = true; // Autoplay-friendly start, gate will unmute
              document.body.appendChild(bgAudio);
              bgAudio.play().catch(() => {});
              audioCleanup = bindAudioPlayer(bgAudio);
              syncAudioUI();
            }
            needsGate = true;
            if (soundBtn) soundBtn.classList.remove("hidden"); // Button zeigen - Nutzer kann unmute'n
          } else if (bgIsVideoNext && bgVideo) {
            // Kein Song -> Videoton anbieten
            if (soundBtn) soundBtn.classList.remove("hidden");
          } else {
            if (soundBtn) soundBtn.classList.add("hidden"); // nichts abzuspielen
          }
          if (bgVideo && songUrlNext) {
            bgVideo.muted = true;
          }
          const hasVideo = bgChanged ? bgIsVideoNext : !!bgVideo;
          const hasAudio = audioChanged ? !!songUrlNext : !!bgAudio;
          needsGate = needsGate || hasVideo || hasAudio;
          if (bgChanged || audioChanged) {
            if (needsGate && !gateDismissed) {
              showGate(true);
            } else {
              showGate(false);
            }
            soundOn = false;
            updateSoundUI();
          }
          lastMediaSig = mediaSig;
          lastBgSig = bgSig;
          lastAudioSig = audioSig;
          lastCursorSig = cursorSig;

          const cardEl = document.getElementById("card");
          if (cardEl) {
            const layoutMode = (data.layout_mode || "center")
              .toString()
              .toLowerCase();
            const wantsWide =
              !isMobile && !usedCanvas && (layoutMode === "wide" || hasSideBySide);
            cardEl.classList.toggle("wide", wantsWide);
            const raw = Number(data.transparency);
            const clamped = Number.isFinite(raw)
              ? Math.min(100, Math.max(0, raw))
              : 0;
            const cardAlpha = 1 - clamped / 100;
            const cardHex =
              sanitizeHexColor(data.card_color) || DEFAULT_CARD_COLOR;
            const cardBg =
              hexToRgba(cardHex, cardAlpha) || `rgba(23, 27, 59, ${cardAlpha})`;

            if (cardAlpha <= 0) {
              cardEl.classList.add("transparent");
              cardEl.style.background = "";
            } else {
              cardEl.classList.remove("transparent");
              cardEl.style.background = cardBg;
            }
          }
          applyTextColors(data);
          applyQuoteEffectStrength(data);
          applyLinkStyles(
            data.link_color,
            data.link_bg_color,
            data.link_bg_alpha,
          );
          applyLinkLayout(data, { isMobile, wantsWide });
          const cursorFxHex =
            sanitizeHexColor(data.cursor_effect_color) ||
            sanitizeHexColor(data.link_color) ||
            sanitizeHexColor(data.name_color) ||
            DEFAULT_AUDIO_ACCENT_COLOR;
          const rawCursorFxAlpha = data.cursor_effect_alpha;
          const cursorFxAlpha =
            rawCursorFxAlpha === undefined || rawCursorFxAlpha === null
              ? 70
              : Number(rawCursorFxAlpha);
          setCursorFxSettings({ color: cursorFxHex, alpha: cursorFxAlpha });
          setCursorFxOffset(cursorUrl && !isMobile ? CURSOR_IMAGE_SIZE / 2 : 0);
          applyCursorEffect(data.cursor_effect || "none", { isMobile });

          if (cursorUrl && !isMobile) {
            const shouldResize =
              !cursorFxImage || cursorFxImageSrc !== cursorUrl;
            if (shouldResize) {
              resizeCursorImage(cursorUrl, CURSOR_IMAGE_SIZE)
                .then((resized) => {
                  const cursorDecl = `url("${resized}") 0 0, auto`;
                  document.documentElement.style.setProperty(
                    "--cursor",
                    cursorDecl,
                  );
                  cursorFxImage = resized;
                  cursorFxImageSrc = cursorUrl;
                  setCursorGlowImage(resized, CURSOR_IMAGE_SIZE);
                })
                .catch(() => {
                  document.documentElement.style.setProperty(
                    "--cursor",
                    "auto",
                  );
                  setCursorGlowImage("");
                });
            } else {
              const cursorDecl = `url("${cursorFxImage}") 0 0, auto`;
              document.documentElement.style.setProperty(
                "--cursor",
                cursorDecl,
              );
              setCursorGlowImage(cursorFxImage, CURSOR_IMAGE_SIZE);
            }
          } else {
            document.documentElement.style.setProperty("--cursor", "auto");
            setCursorGlowImage("");
          }

          // Profil/Badges/Links wie gehabt
          const pfp = document.getElementById("pfp");
          const pfpFrame = document.getElementById("pfpFrame");
          if (pfp) {
            const prefersUserPfp =
              data.is_template_demo &&
              currentUser &&
              currentUser.profile_picture;
            const linktreePfp = safeMediaUrl(data.linktree_profile_picture);
            const primaryPfp = prefersUserPfp
              ? currentUser.profile_picture
              : linktreePfp || data.profile_picture;
            const profileUrl =
              safeMediaUrl(
                primaryPfp,
              ) ||
              safeMediaUrl(currentUser && currentUser.profile_picture) ||
              "/static/icon.png";
            pfp.src = profileUrl;
          }
          if (pfpFrame) {
            const frameUrl = safeMediaUrl(data.discord_decoration_url);
            if (data.discord_frame_enabled && frameUrl) {
              pfpFrame.src = frameUrl;
              pfpFrame.style.display = "block";
            } else {
              pfpFrame.style.display = "none";
            }
          }
          const presence = normalizePresence(data.discord_presence);
          const presenceLabel = PRESENCE_LABELS[presence] || "Online";
          const presenceEl = document.getElementById("discordPresence");
          const statusLine = document.getElementById("discordStatusLine");
          const statusTextEl = document.getElementById("discordStatusText");
          const discordLinked = !!data.discord_linked;
          if (presenceEl) {
            const showPresence = discordLinked && data.discord_presence_enabled;
            presenceEl.classList.toggle("hidden", !showPresence);
            applyPresenceClass(presenceEl, presence);
            presenceEl.setAttribute(
              "aria-label",
              `Discord status: ${presenceLabel}`,
            );
          }
          if (statusLine && statusTextEl) {
            const showStatus = discordLinked && data.discord_status_enabled;
            statusLine.classList.toggle("hidden", !showStatus);
            if (showStatus) {
              applyPresenceClass(statusLine, presence);
              const statusText = (data.discord_status_text || "").trim();
              statusTextEl.textContent = statusText || presenceLabel;
            } else {
              statusTextEl.textContent = "";
            }
          }
          const enterTextEl = document.getElementById("enterText");
            if (enterTextEl) {
              const entryText = (data.entry_text || "").trim();
              enterTextEl.textContent = entryText || "Click to enter";
            enterTextEl.classList.remove(
              "glow",
              "neon",
              "rainbow",
              "font-serif",
              "font-mono",
              "font-script",
              "font-display",
            );
            const entryFx = (data.entry_effect || "none").toString().toLowerCase();
            if (entryFx && entryFx !== "none") {
              enterTextEl.classList.add(entryFx);
            }
            const entryFont = (data.entry_font_family || "default")
              .toString()
              .toLowerCase();
            if (entryFont && entryFont !== "default") {
              enterTextEl.classList.add(`font-${entryFont}`);
            }
            const entrySize = Number(data.entry_font_size);
            if (Number.isFinite(entrySize) && entrySize > 0) {
              const clamped = Math.min(40, Math.max(10, entrySize));
              enterTextEl.style.fontSize = `${clamped}px`;
            } else {
              enterTextEl.style.removeProperty("font-size");
            }
            const entryColor =
              sanitizeHexColor(data.entry_text_color) || DEFAULT_ENTRY_TEXT_COLOR;
              if (entryColor) {
                enterTextEl.style.color = entryColor;
              } else {
                enterTextEl.style.removeProperty("color");
              }
            }
            const enterGate = document.getElementById("enterOverlay");
            if (enterGate) {
              const rawOverlayAlpha = Number(data.entry_overlay_alpha);
              const overlayAlpha = Number.isFinite(rawOverlayAlpha)
                ? Math.min(100, Math.max(0, rawOverlayAlpha))
                : DEFAULT_ENTRY_OVERLAY_ALPHA;
              enterGate.style.background = `rgba(0, 0, 0, ${
                overlayAlpha / 100
              })`;
            }
            const enterBox = document.querySelector(".enter-box");
            if (enterBox) {
              const boxEnabled =
                data.entry_box_enabled !== undefined && data.entry_box_enabled !== null
                  ? !!data.entry_box_enabled
                  : true;
              const borderEnabled =
                data.entry_border_enabled !== undefined &&
                data.entry_border_enabled !== null
                  ? !!data.entry_border_enabled
                  : true;
              const rawAlpha = Number(data.entry_bg_alpha);
              const alpha = Number.isFinite(rawAlpha)
                ? Math.min(100, Math.max(0, rawAlpha))
                : DEFAULT_ENTRY_BG_ALPHA;
              if (!boxEnabled) {
                enterBox.style.background = "transparent";
                enterBox.style.border = "none";
                enterBox.style.boxShadow = "none";
                enterBox.style.padding = "0";
                enterBox.style.minWidth = "auto";
              } else {
                const bg =
                  hexToRgba(DEFAULT_ENTRY_BG_COLOR, alpha / 100) ||
                  hexToRgba(DEFAULT_ENTRY_BG_COLOR, DEFAULT_ENTRY_BG_ALPHA / 100);
                if (bg) {
                  enterBox.style.background = bg;
                } else {
                  enterBox.style.removeProperty("background");
                }
                enterBox.style.removeProperty("box-shadow");
                enterBox.style.removeProperty("padding");
                enterBox.style.removeProperty("min-width");
                if (!borderEnabled) {
                  enterBox.style.border = "none";
                } else {
                  const borderColor = sanitizeHexColor(data.entry_border_color);
                  if (borderColor) {
                    enterBox.style.border = `1px solid ${borderColor}`;
                  } else {
                    enterBox.style.removeProperty("border");
                    enterBox.style.removeProperty("border-color");
                  }
                }
              }
            }
          applyNameStyles(data);
          applyQuoteStyles(data);
          const hasQuote = updateQuoteDisplay(data);
          const quoteEl = document.getElementById("quote");
          if (quoteEl) {
            quoteEl.classList.toggle("hidden", !hasQuote);
          }
          const locEl = document.getElementById("loc");
          if (locEl) {
            locEl.textContent = "";
            const locText =
              typeof data.location === "string" ? data.location.trim() : "";
            locEl.classList.toggle("hidden", !locText);
            if (locText) {
              const icon = createLocationIcon();
              const text = document.createElement("span");
              text.textContent = ` ${locText}`;
              locEl.appendChild(icon);
              locEl.appendChild(text);
            }
          }

          const badgesEl = document.getElementById("badges");
          if (badgesEl) {
            badgesEl.innerHTML = "";
            const frag = document.createDocumentFragment();
            let badgeCount = 0;
            (data.icons || []).forEach((ic) => {
              if (!ic.displayed) return;

              const desc = ic.description || ic.code || "badge";
              const wrap = document.createElement("span");
              wrap.className = "badge";
              // Tooltip via title (Desktop) + aria-label (AT / Touch-Langdruck zeigt oft auch title)
              wrap.title = desc;
              wrap.setAttribute("aria-label", desc);

              const img = document.createElement("img");
              const iconUrl = safeMediaUrl(ic.image_url);
              if (!iconUrl) return;
              img.src = iconUrl;
              img.alt = desc;
              img.width = 20;
              img.height = 20;
              img.loading = "lazy";
              img.decoding = "async";

              wrap.appendChild(img);
              frag.appendChild(wrap);
              badgeCount += 1;
            });

            if (discordLinked && data.discord_badges_enabled) {
              let discordList = Array.isArray(data.discord_badges)
                ? data.discord_badges
                : [];
              const filterCodes = Array.isArray(data.discord_badge_codes)
                ? data.discord_badge_codes
                : null;
              if (filterCodes) {
                discordList = discordList.filter((b) =>
                  filterCodes.includes(b && b.code),
                );
              }
              discordList.forEach((badge) => {
                if (!badge) return;
                const desc = badge.label || badge.code || "badge";
                const wrap = document.createElement("span");
                wrap.className = "badge";
                wrap.title = desc;
                wrap.setAttribute("aria-label", desc);

                const img = document.createElement("img");
                const iconUrl = safeMediaUrl(badge.icon_url);
                if (!iconUrl) return;
                img.src = iconUrl;
                img.alt = desc;
                img.width = 20;
                img.height = 20;
                img.loading = "lazy";
                img.decoding = "async";

                wrap.appendChild(img);
                frag.appendChild(wrap);
                badgeCount += 1;
              });
            }
            badgesEl.appendChild(frag);
            badgesEl.classList.toggle("hidden", badgeCount === 0);
          }
          const linksEl = document.getElementById("links");
          if (linksEl) {
            linksEl.textContent = "";
            const frag = document.createDocumentFragment();
            const rawLinks = Array.isArray(data.links) ? data.links : [];
            let linkItems = rawLinks;
            if (data.is_template_demo && data.demo_show_links) {
              const label =
                (data.demo_link_label || "").trim() || "Example Link";
              let url = (data.demo_link_url || "").trim();
              if (!url) url = "https://example.com";
              const iconUrl = (data.demo_link_icon_url || "").trim() || null;
              const demoLink = {
                label,
                url,
                icon_url: iconUrl,
                is_active: true,
              };
              linkItems = rawLinks.length ? rawLinks : [demoLink];
            }
            const iconsOnly = !!data.link_icons_only;
            let linkCount = 0;
            (linkItems || []).forEach((l) => {
              if (!l.is_active) return;
              const href = safeLinkUrl(l.url);
              if (!href) return;
              const a = document.createElement("a");
              a.className = "link";
              a.href = href;
              a.target = "_blank";
              a.rel = "noreferrer noopener";
              const labelText = (l.label || l.url || "").trim();
              if (labelText) {
                a.dataset.label = labelText;
                a.setAttribute("aria-label", labelText);
              } else {
                a.dataset.label = "";
              }
              const iconUrl = safeMediaUrl(l.icon_url);
              if (iconUrl) {
                const img = document.createElement("img");
                img.src = iconUrl;
                img.alt = "";
                img.loading = "lazy";
                img.decoding = "async";
                a.appendChild(img);
              } else if (iconsOnly) {
                a.classList.add("no-icon");
              }
              const span = document.createElement("span");
              span.textContent = labelText || l.url;
              if (iconsOnly && iconUrl) span.classList.add("sr-only");
              a.appendChild(span);
              frag.appendChild(a);
              linkCount += 1;
            });
            linksEl.appendChild(frag);
            linksEl.classList.toggle("hidden", linkCount === 0);
          }

          const visitBox = document.getElementById("visitCounter");
          const visitValue = document.getElementById("visitCounterValue");
          if (visitBox && visitValue) {
            if (data.show_visit_counter) {
              visitValue.textContent = Number(
                data.visit_count || 0,
              ).toLocaleString();
              const textColor =
                hexToRgba(data.visit_counter_color, 1) ||
                hexToRgba(data.text_color, 1) ||
                null;
              if (textColor) visitBox.style.color = textColor;
              const bgAlpha = Number.isFinite(
                Number(data.visit_counter_bg_alpha),
              )
                ? Number(data.visit_counter_bg_alpha)
                : 20;
              const bgColor =
                hexToRgba(
                  data.visit_counter_bg_color || "#ffffff",
                  Math.min(1, Math.max(0, bgAlpha / 100)),
                ) || "rgba(255,255,255,0.14)";
              visitBox.style.backgroundColor = bgColor;
              visitBox.style.display = "inline-flex";
            } else {
              visitBox.style.display = "none";
            }
          }
        }

        async function loadTree() {
          try {
            const params = new URLSearchParams(location.search);
            let templateId = params.get("template_id");
            const parts = location.pathname.split("/").filter(Boolean);
            if (
              !templateId &&
              parts[0] === "marketplace" &&
              parts[1] === "templates"
            ) {
              templateId = parts[2] || null;
            }
            const requestedDevice = params.get("device");
            const device = detectDevice(requestedDevice);
            const slug = decodeURIComponent(
              location.pathname.split("/").pop() || "",
            );
            const cacheKey = makeCacheKey({ slug, templateId, device });
            const preferLite = shouldUseLiteMedia();

            const userPromise = fetchSessionUser();
            const cached = readCachedTree(cacheKey);
            if (cached && !initialRenderDone) {
              renderTree(cached, { preferLite, fromCache: true, device });
              initialRenderDone = true;
            }

            const dataPromise = fetchTreeData({ templateId, slug, device });
            const liveData = await dataPromise;
            let data = liveData || cached;
            if (!data) return;
            writeCachedTree(cacheKey, data);
            if (!initialRenderDone) {
              renderTree(data, { preferLite, fromCache: false, device });
              initialRenderDone = true;
            } else {
              lastData = data;
            }
            await hydrateTemplateDemo(data, device, userPromise, preferLite);
          } catch (e) {
            console.error("loadTree failed:", e);
          }
        }

        const connection =
          navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection;
        const prefersReducedData =
          typeof window.matchMedia === "function"
            ? window.matchMedia("(prefers-reduced-data: reduce)")
            : null;

        function handleMediaPreferenceChange() {
          if (!lastData) return;
          const preferLite = shouldUseLiteMedia();
          if ((preferLite ? "lite" : "full") === lastMediaMode) return;
          renderTree(lastData, {
            preferLite,
            fromCache: true,
            device: lastDevice || detectDevice(),
          });
        }

        if (connection && connection.addEventListener) {
          connection.addEventListener("change", handleMediaPreferenceChange);
        }
        if (prefersReducedData && prefersReducedData.addEventListener) {
          prefersReducedData.addEventListener(
            "change",
            handleMediaPreferenceChange,
          );
        } else if (prefersReducedData && prefersReducedData.addListener) {
          prefersReducedData.addListener(handleMediaPreferenceChange);
        }

        loadTree();
        document.addEventListener("DOMContentLoaded", () => {
          console.log("Page loaded (HTML ready)");
        });
      })();
    </script>
  </body>
</html>
