<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TAOMA™ — Linktree Canvas</title>
    <meta
      name="description"
      content="TAOMA™ Linktree Canvas Editor"
    />
    <meta property="og:title" content="TAOMA™ — Linktree Canvas" />
    <meta
      property="og:description"
      content="Edit your Linktree layout in the canvas editor."
    />
    <meta property="og:type" content="profile" />
    <meta property="og:url" content="https://taoma.space/linktree" />
    <meta property="og:image" content="https://taoma.space/static/icon.png" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="TAOMA™ — Linktree Canvas" />
    <meta
      name="twitter:description"
      content="Edit your Linktree layout in the canvas editor."
    />
    <meta name="twitter:image" content="https://taoma.space/static/icon.png" />
    <link rel="canonical" href="https://taoma.space/linktree" />
    <meta name="robots" content="index,follow" />
    <meta name="theme-color" content="#0f1223" />
    <link rel="icon" type="image/png" href="/static/icon.png" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "ProfilePage",
        "url": "https://taoma.space/linktree",
        "name": "TAOMA Linktree",
        "inLanguage": "de",
        "about": "Zentrale Links und Projekte von TAOMA",
        "breadcrumb": "Home > Linktree"
      }
    </script>
    <style>
      :root {
        --bg: #0e1020;
        --ink: #e9ebff;
        --muted: #a2a9c8;
        --acc: #85a3ff;
        --card: #171b3b;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        --radius: 16px;
        --link-color: #e9ebff;
        --link-bg: #171b3b;
        --link-bg-hover: color-mix(in oklab, #171b3b, white 4%);
        --link-cols: 1;
        --name-color: #e9ebff;
        --location-color: #a2a9c8;
        --quote-color: #e9ebff;
        --quote-glow-1: 8px;
        --quote-glow-2: 12px;
        --quote-glow-3: 18px;
        --quote-neon-1: 6px;
        --quote-neon-2: 14px;
        --quote-neon-3: 24px;
        --quote-neon-drop: 10px;
        --cursor: auto;
        --cursor-fx-color: var(--acc);
      }

      body {
        margin: 0;
        font:
          15px/1.6 Inter,
          ui-sans-serif,
          system-ui;
        color: var(--ink);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background: var(--bg);
        overflow-x: hidden;
        cursor: var(--cursor, auto);
      }

      html,
      body,
      a,
      button,
      .link {
        cursor: var(--cursor, auto);
      }

      /* Background video/image */
      .bg {
        position: fixed;
        inset: 0;
        z-index: -1;
        overflow: hidden;
      }

      .bg img,
      .bg video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: 3rem 1rem;
      }

      body.canvas-editor {
        overflow: hidden;
      }

      .canvas-shell {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(0, 1fr) 360px;
        min-height: 100vh;
      }

      .canvas-stage {
        padding: 2.5rem 1.5rem 2rem;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow: auto;
      }

      .canvas-stage .card {
        margin: 0;
      }

      .inspector {
        position: sticky;
        top: 0;
        height: 100vh;
        display: flex;
        flex-direction: column;
        background: rgba(13, 17, 35, 0.94);
        border-left: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(14px);
        z-index: 5;
      }

      .inspector-header,
      .inspector-footer {
        padding: 1rem 1.1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      .inspector-footer {
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        border-bottom: none;
      }

      .inspector-body {
        flex: 1;
        overflow: auto;
        padding: 1rem 1.1rem 1.4rem;
        display: grid;
        gap: 1rem;
      }

      .inspector h3 {
        margin: 0 0 0.6rem;
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      .field {
        display: grid;
        gap: 0.35rem;
      }

      .field label {
        font-size: 0.85rem;
        font-weight: 700;
        color: var(--muted);
      }

      .input,
      .select {
        width: 100%;
        padding: 0.55rem 0.7rem;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.08);
        color: var(--ink);
        font: inherit;
      }

      .row {
        display: flex;
        gap: 0.6rem;
        align-items: center;
      }

      .btn {
        width: 100%;
        padding: 0.65rem 0.8rem;
        border-radius: 12px;
        border: 0;
        background: linear-gradient(135deg, #6c8cff, #71e5d2);
        color: #0e1020;
        font-weight: 800;
        cursor: pointer;
      }

      .btn.ghost {
        background: rgba(255, 255, 255, 0.08);
        color: var(--ink);
        border: 1px solid rgba(255, 255, 255, 0.14);
      }

      .inspector-note {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .muted {
        color: var(--muted);
      }

      .inspector-divider {
        height: 1px;
        background: rgba(255, 255, 255, 0.08);
        margin: 0.75rem 0;
      }

      .grid-2 {
        display: grid;
        gap: 0.6rem;
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .btn.sm {
        width: auto;
        padding: 0.45rem 0.6rem;
        border-radius: 10px;
        font-size: 0.8rem;
      }

      .btn.danger {
        background: #ff7a7a;
        color: #1b0e0e;
      }

      .inspector .links-list {
        display: grid;
        gap: 0.7rem;
      }

      .inspector .link-item {
        display: grid;
        gap: 0.5rem;
        padding: 0.7rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.04);
      }

      .inspector .link-item.dragging {
        opacity: 0.6;
        border-style: dashed;
      }

      .inspector .link-item .handle {
        font-size: 0.9rem;
        color: var(--muted);
        cursor: grab;
      }

      .inspector .link-icon-upload {
        display: grid;
        gap: 0.35rem;
      }

      .inspector .badge-grid {
        display: grid;
        gap: 0.6rem;
      }

      .inspector .badge-item {
        display: grid;
        gap: 0.35rem;
        padding: 0.6rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.04);
      }

      .inspector .badge-item .badge-row {
        display: grid;
        grid-template-columns: 24px minmax(0, 1fr) auto;
        align-items: center;
        gap: 0.5rem;
      }

      .inspector .badge-item img {
        width: 20px;
        height: 20px;
        object-fit: cover;
      }

      .inspector .pfp-preview {
        width: 84px;
        height: 84px;
        border-radius: 16px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.04);
      }

      .inspector .pfp-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .canvas-plate {
        position: absolute;
        inset: 0 auto auto 0;
        cursor: grab;
        user-select: none;
      }

      /* Optional: stretch supported object surfaces/backgrounds with plate size */
      .canvas-plate.fit-element-bg.audio-player {
        margin: 0;
        width: 100%;
        max-width: none;
        height: 100%;
        align-content: start;
      }

      .canvas-plate.fit-element-bg.visit-counter {
        margin: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: var(--radius);
        box-sizing: border-box;
      }

      .canvas-plate.fit-element-bg.links {
        margin: 0;
      }

      .canvas-plate.fit-element-bg.links.icons-only.icons-grouped {
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        align-content: center;
      }

      .canvas-plate.selected {
        outline: 2px solid rgba(113, 229, 210, 0.9);
        outline-offset: 3px;
      }

      .canvas-plate * {
        pointer-events: none;
      }

      .canvas-plate .resize-handle {
        position: absolute;
        width: 12px;
        height: 12px;
        border-radius: 999px;
        background: rgba(113, 229, 210, 0.95);
        border: 2px solid rgba(14, 18, 35, 0.9);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        pointer-events: auto;
        z-index: 5;
      }

      .canvas-plate .resize-e {
        right: -6px;
        top: 50%;
        transform: translate(50%, -50%);
        cursor: ew-resize;
      }

      .canvas-plate .resize-s {
        left: 50%;
        bottom: -6px;
        transform: translate(-50%, 50%);
        cursor: ns-resize;
      }

      .canvas-plate .resize-se {
        right: -6px;
        bottom: -6px;
        transform: translate(50%, 50%);
        cursor: nwse-resize;
      }

      .plate-group {
        position: absolute;
        inset: 0 auto auto 0;
      }

      .plate-group.selected {
        outline: 2px dashed rgba(113, 229, 210, 0.9);
        outline-offset: 4px;
      }

      .plate-group .group-handle {
        position: absolute;
        top: -24px;
        left: 0;
        padding: 0.2rem 0.5rem;
        border-radius: 999px;
        background: rgba(14, 18, 35, 0.85);
        border: 1px solid rgba(113, 229, 210, 0.6);
        font-size: 0.7rem;
        font-weight: 700;
        color: var(--ink);
        cursor: grab;
        user-select: none;
      }

      .canvas-resize-handle {
        position: absolute;
        right: 10px;
        bottom: 10px;
        width: 14px;
        height: 14px;
        border-radius: 4px;
        background: rgba(122, 162, 255, 0.9);
        border: 2px solid rgba(14, 18, 35, 0.9);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
        cursor: nwse-resize;
        z-index: 6;
      }

      .card.canvas {
        --canvas-grid: 8px;
      }

      @media (max-width: 1100px) {
        .canvas-shell {
          grid-template-columns: 1fr;
        }

        .inspector {
          position: relative;
          height: auto;
          border-left: none;
          border-top: 1px solid rgba(255, 255, 255, 0.12);
        }
      }

      .pfp-wrap {
        position: relative;
        width: 110px;
        height: 110px;
        margin: 0 auto 7px;
        display: grid;
        place-items: center;
      }

      .pfp {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: 3px solid #fff3;
        box-shadow: var(--shadow);
        object-fit: cover;
        max-width: 100%;
        max-height: 100%;
        position: relative;
        z-index: 1;
      }

      .pfp-frame {
        position: absolute;
        inset: -4px;
        width: calc(100% + 8px);
        height: calc(100% + 8px);
        object-fit: contain;
        pointer-events: none;
        z-index: 2;
      }

      .discord-presence {
        position: absolute;
        right: 4px;
        bottom: 4px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(15, 18, 35, 0.9);
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
        background: #8a90a8;
        z-index: 3;
      }

      .discord-presence.hidden {
        display: none;
      }

      .discord-presence.status-online {
        background: #23a559;
      }

      .discord-presence.status-idle {
        background: #f0b232;
      }

      .discord-presence.status-dnd {
        background: #f23f43;
      }

      .discord-presence.status-offline {
        background: #8a90a8;
      }

      .discord-status {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.45rem;
        font-size: 0.95rem;
        color: var(--muted);
        margin-bottom: 0.6rem;
      }

      .discord-status.hidden {
        display: none;
      }

      .discord-status .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #8a90a8;
      }

      .discord-status.status-online .dot {
        background: #23a559;
      }

      .discord-status.status-idle .dot {
        background: #f0b232;
      }

      .discord-status.status-dnd .dot {
        background: #f23f43;
      }

      .discord-status.status-offline .dot {
        background: #8a90a8;
      }

      .discord-status .text {
        font-weight: 600;
      }

      .discord-badges {
        display: flex;
        gap: 0.45rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 1.4rem;
      }

      .discord-badges.hidden {
        display: none;
      }

      .discord-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.25rem 0.6rem;
        border-radius: 999px;
        background: #ffffff14;
        border: 1px solid #ffffff26;
        font-size: 0.75rem;
        font-weight: 700;
        color: var(--ink);
      }

      .discord-badge img {
        width: 28px;
        height: 28px;
        object-fit: contain;
        display: block;
      }

      .audio-player {
        width: 100%;
        max-width: 420px;
        margin: 0 auto 1.5rem;
        padding: 0.8rem 1rem;
        box-sizing: border-box;
        border-radius: 14px;
        background: var(--audio-bg, rgba(23, 27, 59, 0.6));
        border: 1px solid var(--audio-border, #ffffff26);
        box-shadow: var(--shadow);
        display: grid;
        gap: 0.55rem;
        text-align: left;
        color: var(--audio-text, var(--ink));
      }

      .audio-player.hidden {
        display: none;
      }

      .audio-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.85rem;
        color: var(--audio-muted, var(--muted));
        gap: 0.5rem;
      }

      .audio-title-wrap {
        display: flex;
        align-items: center;
        gap: 0.45rem;
        min-width: 0;
      }

      .audio-icon {
        width: 50px;
        height: 50px;
        border-radius: 6px;
        object-fit: cover;
        display: block;
      }

      .audio-icon.hidden {
        display: none;
      }

      .audio-title {
        font-weight: 700;
        color: var(--audio-text, var(--ink));
      }

      .audio-seek {
        width: 100%;
        accent-color: var(--audio-accent, var(--acc));
      }

      .audio-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .audio-btn {
        border: 1px solid #ffffff26;
        background: var(--audio-btn-bg, #ffffff14);
        color: var(--audio-text, var(--ink));
        border-radius: 999px;
        padding: 0.35rem 0.7rem;
        font-weight: 700;
        cursor: var(--cursor, pointer);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        min-width: 42px;
      }

      .audio-btn.primary {
        background: var(--audio-accent, var(--acc));
        color: var(--audio-accent-ink, #0e1020);
        border-color: color-mix(
          in oklab,
          var(--audio-accent, var(--acc)) 65%,
          #000
        );
      }

      .audio-btn svg {
        width: 16px;
        height: 16px;
      }

      .audio-btn .icon-pause {
        display: none;
      }

      .audio-btn.is-playing .icon-pause {
        display: block;
      }

      .audio-btn.is-playing .icon-play {
        display: none;
      }

      .name {
        font-size: 1.8rem;
        font-weight: 800;
        margin: 1rem 0 0.5rem;
        color: var(--name-color);
      }

      .name.has-id {
        position: relative;
        display: inline-flex;
        justify-content: center;
        align-items: center;
      }

      .name.has-id::after {
        content: attr(data-id);
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translate(-50%, 6px);
        background: rgba(0, 0, 0, 0.35);
        color: var(--ink);
        font-size: 0.75rem;
        padding: 0.2rem 0.55rem;
        border-radius: 999px;
        border: 1px solid #ffffff26;
        box-shadow: var(--shadow);
        opacity: 0;
        pointer-events: none;
        white-space: nowrap;
        transition:
          opacity 0.15s ease,
          transform 0.15s ease;
      }

      .name.has-id:hover::after {
        opacity: 1;
        transform: translate(-50%, 10px);
      }

      .name.font-serif {
        font-family: Georgia, "Times New Roman", serif;
      }
      .name.font-mono {
        font-family:
          ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "Courier New",
          monospace;
      }
      .name.font-script {
        font-family: "Segoe Script", "Comic Sans MS", cursive;
      }
      .name.font-display {
        font-family: Impact, "Arial Black", "Franklin Gothic", sans-serif;
        letter-spacing: 0.4px;
      }

      .location {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        justify-content: center;
        color: var(--location-color);
        margin-bottom: 1rem;
      }

      .quote {
        font-style: italic;
        color: var(--quote-color);
        margin-bottom: 1.5rem;
        max-width: 600px;
      }

      .quote.hidden {
        display: none;
      }
      .quote.font-serif {
        font-family: Georgia, "Times New Roman", serif;
      }
      .quote.font-mono {
        font-family:
          ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "Courier New",
          monospace;
        font-style: normal;
      }
      .quote.font-script {
        font-family: "Segoe Script", "Comic Sans MS", cursive;
      }
      .quote.font-display {
        font-family: Impact, "Arial Black", "Franklin Gothic", sans-serif;
        letter-spacing: 0.4px;
      }

      .quote.quote-cursor::after {
        content: " |";
        display: inline-block;
        opacity: 1;
      }
      .quote.rainbow.quote-cursor::after {
        color: var(--quote-color);
        -webkit-text-fill-color: var(--quote-color);
      }

      .quote.quote-cursor.cursor-blink::after {
        animation: quote-blink 0.9s steps(1, end) infinite;
      }

      @keyframes quote-blink {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0;
        }
      }

      .badges {
        display: flex;
        gap: 0.4rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 2rem;
      }

      .badges.hidden {
        display: none;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        /* kein Platz für Text nötig */
        background: #ffffff1a;
        border-radius: 999px;
        padding: 0.28rem;
        /* nur wenig Innenabstand */
        border: 1px solid #ffffff26;
        /* dezente Kante, optional */
      }

      .badge img {
        width: 20px;
        height: 20px;
        object-fit: contain;
        display: block;
      }

      .links {
        display: grid;
        gap: 12px;
        width: 100%;
        max-width: 420px;
        margin: 0 auto;
        /* <- zentriert die Liste innerhalb der Karte */
        grid-template-columns: repeat(var(--link-cols, 1), minmax(0, 1fr));
      }

      .links.hidden {
        display: none;
      }

      .section-row {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 1.25rem;
        width: 100%;
        align-items: start;
      }

      .section-row > * {
        width: 100%;
      }

      .visit-counter {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        margin: 1rem auto 0;
        padding: 0.55rem 0.9rem;
        border-radius: 999px;
        background: #ffffff14;
        color: var(--ink);
        font-weight: 600;
        border: 1px solid #ffffff26;
        box-shadow: var(--shadow);
      }

      .visit-counter svg {
        width: 18px;
        height: 18px;
      }

      .link {
        position: relative;
        /* für das absolut positionierte Icon */
        display: flex;
        align-items: center;
        justify-content: center;
        /* zentriert den Inhalt */
        text-align: center;
        gap: 0.6rem;
        padding: 0.9rem 1.2rem;
        border-radius: var(--radius);
        background: var(--link-bg);
        border: 1px solid #ffffff22;
        box-shadow: var(--shadow);
        transition: 0.2s;
        width: 100%;
        color: var(--link-color);
        /* volle Breite für schöne Pillenform */
      }

      .link:hover {
        transform: translateY(-2px);
        background: var(--link-bg-hover);
      }

      .links.link-bg-alpha-zero .link {
        border-color: transparent;
        box-shadow: none;
      }

      .links.link-bg-alpha-zero .link:hover {
        background: transparent;
      }

      .link img {
        width: 35px;
        height: 35px;
        object-fit: contain;
        position: absolute;
        left: 14px;
        top: 50%;
        transform: translateY(-50%);
      }

      .link span {
        margin: 0 auto;
      }

      footer {
        padding: 1rem;
        text-align: center;
        font-size: 0.85rem;
        color: var(--muted);
      }

      footer a {
        color: inherit;
        font-weight: 700;
      }

      footer a:hover {
        text-decoration: underline;
      }

      .sound-toggle {
        position: fixed;
        right: 14px;
        bottom: 16px;
        z-index: 10;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.45rem 0.6rem;
        border-radius: 999px;
        background: #ffffff1a;
        color: var(--ink);
        border: 1px solid #ffffff33;
        box-shadow: var(--shadow);
        font-weight: 700;
        user-select: none;
        cursor: var(--cursor, pointer);
        backdrop-filter: blur(6px) saturate(1.2);
      }

      .sound-toggle.hidden {
        display: none;
      }

      .sound-toggle .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #ff6b6b;
      }

      .sound-toggle.on .dot {
        background: #1dd1a1;
      }

      .enter-gate {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(6px);
        background: rgba(0, 0, 0, 0.35);
        z-index: 9;
        transition: opacity 0.2s ease;
      }

      .enter-gate.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .enter-box {
        padding: 1rem 1.4rem;
        border-radius: 14px;
        background: rgba(15, 18, 35, 0.85);
        border: 1px solid #ffffff33;
        box-shadow: var(--shadow);
        color: var(--ink);
        text-align: center;
        min-width: 220px;
        cursor: var(--cursor, pointer);
        user-select: none;
      }

      .enter-box p {
        margin: 0 0 0.25rem;
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      .enter-text.font-serif {
        font-family: Georgia, "Times New Roman", serif;
      }
      .enter-text.font-mono {
        font-family:
          ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "Courier New",
          monospace;
        font-style: normal;
      }
      .enter-text.font-script {
        font-family: "Segoe Script", "Comic Sans MS", cursive;
      }
      .enter-text.font-display {
        font-family: Impact, "Arial Black", "Franklin Gothic", sans-serif;
        letter-spacing: 0.4px;
      }
      .enter-text.glow {
        text-shadow:
          0 0 8px color-mix(in oklab, currentColor 70%, transparent),
          0 0 12px color-mix(in oklab, currentColor 55%, transparent),
          0 0 18px color-mix(in oklab, currentColor 40%, transparent);
      }
      .enter-text.neon {
        text-shadow:
          0 0 6px color-mix(in oklab, currentColor 80%, transparent),
          0 0 14px color-mix(in oklab, currentColor 60%, transparent),
          0 0 24px color-mix(in oklab, currentColor 50%, transparent);
        filter: drop-shadow(
          0 0 10px color-mix(in oklab, currentColor 45%, transparent)
        );
      }
      .enter-text.rainbow {
        background: linear-gradient(
          90deg,
          red,
          orange,
          yellow,
          green,
          cyan,
          blue,
          violet
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow 3s linear infinite;
      }

      /* Name Effects */
      .name.glow {
        text-shadow:
          0 0 8px color-mix(in oklab, currentColor 70%, transparent),
          0 0 12px color-mix(in oklab, currentColor 55%, transparent),
          0 0 18px color-mix(in oklab, currentColor 40%, transparent);
      }

      .name.neon {
        text-shadow:
          0 0 6px color-mix(in oklab, currentColor 80%, transparent),
          0 0 14px color-mix(in oklab, currentColor 60%, transparent),
          0 0 24px color-mix(in oklab, currentColor 50%, transparent);
        filter: drop-shadow(
          0 0 10px color-mix(in oklab, currentColor 45%, transparent)
        );
      }

      .name.rainbow {
        background: linear-gradient(
          90deg,
          red,
          orange,
          yellow,
          green,
          cyan,
          blue,
          violet
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow 3s linear infinite;
      }

      @keyframes rainbow {
        0% {
          background-position: 0% 50%;
        }

        100% {
          background-position: 100% 50%;
        }
      }

      /* Quote Effects */
      .quote.glow {
        text-shadow:
          0 0 var(--quote-glow-1) color-mix(in oklab, currentColor 70%, transparent),
          0 0 var(--quote-glow-2) color-mix(in oklab, currentColor 55%, transparent),
          0 0 var(--quote-glow-3) color-mix(in oklab, currentColor 40%, transparent);
      }

      .quote.neon {
        text-shadow:
          0 0 var(--quote-neon-1) color-mix(in oklab, currentColor 80%, transparent),
          0 0 var(--quote-neon-2) color-mix(in oklab, currentColor 60%, transparent),
          0 0 var(--quote-neon-3) color-mix(in oklab, currentColor 50%, transparent);
        filter: drop-shadow(
          0 0 var(--quote-neon-drop) color-mix(in oklab, currentColor 45%, transparent)
        );
      }

      .quote.rainbow {
        background: linear-gradient(
          90deg,
          red,
          orange,
          yellow,
          green,
          cyan,
          blue,
          violet
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow 3s linear infinite;
      }

      /* Background Effects */
      .bg.night::after {
        content: "";
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 50, 0.4);
        mix-blend-mode: multiply;
      }

      .bg.rain::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: url("/static/effects/rain.gif");
        background-size: cover;
        opacity: 0.4;
        pointer-events: none;
      }

      .bg.snow::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: url("/static/effects/snow.gif");
        background-size: cover;
        opacity: 0.5;
        pointer-events: none;
      }

      /* Cursor Effects */
      .cursor-glow {
        position: fixed;
        left: 0;
        top: 0;
        width: var(--cursor-fx-size, 28px);
        height: var(--cursor-fx-size, 28px);
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 8;
        opacity: 0;
        transition: opacity 0.2s ease;
        mix-blend-mode: screen;
      }

      .cursor-glow.circle {
        border-radius: 50%;
        background: radial-gradient(
          circle,
          color-mix(in oklab, var(--cursor-fx-color, #85a3ff) 65%, transparent),
          transparent 70%
        );
        box-shadow:
          0 0 18px
            color-mix(
              in oklab,
              var(--cursor-fx-color, #85a3ff) 55%,
              transparent
            ),
          0 0 42px
            color-mix(
              in oklab,
              var(--cursor-fx-color, #85a3ff) 35%,
              transparent
            );
      }

      .cursor-glow.shape {
        border-radius: 0;
        background: color-mix(
          in oklab,
          var(--cursor-fx-color, #85a3ff) 32%,
          transparent
        );
        -webkit-mask-image: var(--cursor-fx-image);
        -webkit-mask-repeat: no-repeat;
        -webkit-mask-size: contain;
        -webkit-mask-position: center;
        mask-image: var(--cursor-fx-image);
        mask-repeat: no-repeat;
        mask-size: contain;
        mask-position: center;
        filter: drop-shadow(
            0 0 12px
              color-mix(
                in oklab,
                var(--cursor-fx-color, #85a3ff) 55%,
                transparent
              )
          )
          drop-shadow(
            0 0 30px
              color-mix(
                in oklab,
                var(--cursor-fx-color, #85a3ff) 35%,
                transparent
              )
          );
      }

      .cursor-fx-canvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 8;
      }

      .card {
        background: rgba(23, 27, 59, var(--card-alpha, 0.8));
        /* Default 80% deckend */
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 2rem 2rem;
        max-width: 600px;
        width: 100%;
        backdrop-filter: blur(12px);
      }

      .card.transparent {
        background: transparent;
        backdrop-filter: none;
        box-shadow: none;
      }

      /* === Mobile Optimierungen === */
      /* Verhindere horizontales Scrollen */
      html,
      body {
        max-width: 100vw;
        overflow-x: hidden;
      }

      body {
        padding: 0;
        margin: 0;
      }

      /* Main Container */
      main {
        padding: 2rem 1rem;
        max-width: 100vw;
        overflow-x: hidden;
        box-sizing: border-box;
      }

      /* Card responsive */
      .card {
        background: rgba(23, 27, 59, var(--card-alpha, 0.8));
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 1.5rem 1rem;
        max-width: 600px;
        width: calc(100% - 2rem);
        /* Berücksichtigt main padding */
        backdrop-filter: blur(12px);
        box-sizing: border-box;
        margin: 0 auto;
      }

      .card.wide {
        max-width: 980px;
        width: min(100%, 980px);
        text-align: left;
      }

      .card.wide .pfp-wrap {
        margin: 0 0 0.6rem;
      }

      .card.wide .links {
        max-width: none;
        margin: 0;
      }

      .card.wide .link {
        justify-content: flex-start;
        text-align: left;
        padding-left: 3rem;
      }

      .card.wide .visit-counter {
        margin: 1rem 0 0;
      }

      .card.canvas {
        position: relative;
        min-height: 0;
        padding: 0;
        max-width: none;
        width: auto;
      }

      .card.canvas .links {
        margin: 0;
        max-width: none;
      }

      .card.canvas .visit-counter {
        margin: 0;
        max-width: none;
      }

      .card.canvas .badges {
        margin-bottom: 0;
        max-width: none;
      }

      .card.canvas .audio-player {
        margin: 0;
        max-width: none;
      }

      .plate-group {
        position: absolute;
        inset: 0 auto auto 0;
      }

      .canvas-plate {
        position: absolute;
        inset: 0 auto auto 0;
      }

      @media (max-width: 900px) {
        .card.wide {
          text-align: center;
        }

        .card.wide .links {
          margin: 0 auto;
        }

        .card.wide .link {
          justify-content: center;
          text-align: center;
          padding-left: 1.2rem;
        }

        .card.wide .visit-counter {
          margin: 1rem auto 0;
        }

        .section-row {
          grid-template-columns: 1fr;
        }
      }

      /* Profilbild */
      .pfp {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        border: 3px solid #fff3;
        box-shadow: var(--shadow);
        object-fit: cover;
        flex-shrink: 0;
      }

      /* Name - lange Namen umbrechen */
      .name {
        font-size: clamp(1.4rem, 5vw, 1.8rem);
        font-weight: 800;
        margin: 1rem 0 0.5rem;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        max-width: 100%;
      }

      /* Location */
      .location {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        justify-content: center;
        color: var(--muted);
        margin-bottom: 1rem;
        flex-wrap: wrap;
        word-wrap: break-word;
        max-width: 100%;
      }

      .location.hidden {
        display: none;
      }

      /* Quote - lange Texte */
      .quote {
        font-style: italic;
        margin-bottom: 1.5rem;
        max-width: 100%;
        word-wrap: break-word;
        overflow-wrap: break-word;
        padding: 0 0.5rem;
        box-sizing: border-box;
      }

      /* Badges responsive */
      .badges {
        display: flex;
        gap: 0.4rem;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 2rem;
        padding: 0 0.5rem;
        max-width: 100%;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        background: #ffffff1a;
        border-radius: 999px;
        padding: 0.28rem;
        border: 1px solid #ffffff26;
        flex-shrink: 0;
      }

      .badge img {
        width: 20px;
        height: 20px;
        object-fit: contain;
        display: block;
      }

      /* Links Container */
      .links {
        display: grid;
        gap: 12px;
        width: 100%;
        max-width: 420px;
        margin: 0 auto;
        padding: 0;
        box-sizing: border-box;
        grid-template-columns: repeat(var(--link-cols, 1), minmax(0, 1fr));
      }

      /* Link Items */
      .link {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        gap: 0.6rem;
        padding: 0.9rem 1.2rem;
        border-radius: var(--radius);
        background: var(--link-bg);
        border: 1px solid #ffffff22;
        box-shadow: var(--shadow);
        transition: 0.2s;
        width: 100%;
        box-sizing: border-box;
        min-height: 48px;
        /* Touch-friendly Mindesthöhe */
        overflow: hidden;
        /* Verhindert Overflow */
        color: var(--link-color);
      }

      .link:hover {
        transform: translateY(-2px);
        background: var(--link-bg-hover);
      }

      /* Link Icon */
      .link img {
        width: 32px;
        height: 32px;
        object-fit: contain;
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        flex-shrink: 0;
      }

      /* Link Text */
      .link span {
        margin: 0 auto;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        max-width: calc(100% - 80px);
        /* Platz für Icon + Padding */
        padding: 0 0.5rem;
      }

      /* Footer */
      footer {
        padding: 1rem;
        text-align: center;
        font-size: 0.85rem;
        color: var(--muted);
        max-width: 100vw;
        overflow-x: hidden;
      }

      /* Sound Toggle Button */
      .sound-toggle {
        position: fixed;
        right: 12px;
        bottom: 14px;
        z-index: 10;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.45rem 0.6rem;
        border-radius: 999px;
        background: #ffffff1a;
        color: var(--ink);
        border: 1px solid #ffffff33;
        box-shadow: var(--shadow);
        font-weight: 700;
        user-select: none;
        cursor: var(--cursor, pointer);
        backdrop-filter: blur(6px) saturate(1.2);
        font-size: 0.85rem;
      }

      /* === Responsive Breakpoints === */
      /* Tablets und kleine Laptops */
      @media (max-width: 768px) {
        main {
          padding: 1.5rem 0.8rem;
        }

        .card {
          padding: 1.2rem 0.8rem;
          width: calc(100% - 1.6rem);
        }

        .name {
          font-size: clamp(1.3rem, 4.5vw, 1.6rem);
        }

        .quote {
          font-size: 0.95rem;
          padding: 0 0.3rem;
        }

        .links {
          max-width: 400px;
          gap: 10px;
        }

        .link {
          padding: 0.8rem 1rem;
        }
      }

      /* Smartphones */
      @media (max-width: 480px) {
        main {
          padding: 1rem 0.5rem;
        }

        .card {
          padding: 1rem 0.6rem;
          width: calc(100% - 1rem);
          border-radius: 12px;
        }

        .pfp {
          width: 90px;
          height: 90px;
        }

        .name {
          font-size: clamp(1.2rem, 6vw, 1.5rem);
          margin: 0.8rem 0 0.4rem;
        }

        .location {
          font-size: 0.9rem;
          margin-bottom: 0.8rem;
        }

        .location svg {
          width: 14px;
          height: 14px;
        }

        .quote {
          font-size: 0.9rem;
          margin-bottom: 1rem;
          padding: 0;
          line-height: 1.5;
        }

        .badges {
          gap: 0.3rem;
          margin-bottom: 1.5rem;
          padding: 0;
        }

        .badge {
          padding: 0.25rem;
        }

        .badge img {
          width: 18px;
          height: 18px;
        }

        .links {
          max-width: 100%;
          gap: 10px;
          padding: 0 0.25rem;
        }

        .link {
          padding: 0.75rem 0.8rem;
          border-radius: 14px;
          min-height: 52px;
        }

        .link img {
          width: 28px;
          height: 28px;
          left: 10px;
        }

        .link span {
          font-size: 0.9rem;
          max-width: calc(100% - 60px);
          padding: 0 0.3rem;
        }

        .sound-toggle {
          right: 10px;
          bottom: 12px;
          padding: 0.4rem 0.5rem;
          font-size: 0.8rem;
        }

        .sound-toggle .dot {
          width: 7px;
          height: 7px;
        }

        .audio-player {
          padding: 0.7rem 0.8rem;
          margin-bottom: 1.2rem;
        }

        .audio-meta {
          font-size: 0.8rem;
        }

        .audio-title {
          font-size: 0.85rem;
        }

        .discord-presence {
          width: 16px;
          height: 16px;
          border-width: 2px;
        }

        footer {
          padding: 0.8rem 0.5rem;
          font-size: 0.8rem;
        }
        .pfp-wrap {
          width: 100px;
          height: 100px;
        }
      }

      /* Sehr kleine Smartphones */
      @media (max-width: 360px) {
        .card {
          padding: 0.8rem 0.5rem;
        }

        .pfp {
          width: 80px;
          height: 80px;
        }

        .name {
          font-size: 1.2rem;
        }

        .quote {
          font-size: 0.85rem;
        }

        .link {
          padding: 0.7rem 0.7rem;
          min-height: 48px;
        }

        .link img {
          width: 24px;
          height: 24px;
        }

        .link span {
          font-size: 0.85rem;
          max-width: calc(100% - 50px);
        }
      }

      /* Landscape-Modus für Smartphones */
      @media (max-height: 500px) and (orientation: landscape) {
        main {
          padding: 1rem 0.5rem;
        }

        .pfp {
          width: 70px;
          height: 70px;
        }

        .name {
          font-size: 1.3rem;
          margin: 0.5rem 0 0.3rem;
        }

        .quote {
          margin-bottom: 0.8rem;
        }

        .badges {
          margin-bottom: 1rem;
        }

        .link {
          padding: 0.6rem 0.8rem;
          min-height: 44px;
        }
      }

      /* Background anpassen */
      .bg {
        position: fixed;
        inset: 0;
        z-index: -1;
        overflow: hidden;
        max-width: 100vw;
      }

      .bg img,
      .bg video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        max-width: 100vw;
      }

      /* Lange URLs in Links kürzen */
      @media (max-width: 480px) {
        .link span {
          overflow: hidden;
          text-overflow: ellipsis;
          display: -webkit-box;
          -webkit-line-clamp: 2;
          line-clamp: 2;
          /* Max 2 Zeilen */
          -webkit-box-orient: vertical;
        }
      }

      .links.icons-only .link {
        justify-content: center;
        text-align: center;
        padding: 0.7rem;
        min-height: calc(var(--link-icons-only-size, 36px) + 28px);
        aspect-ratio: 1 / 1;
      }

      .links.icons-only .link img {
        position: static;
        left: auto;
        top: auto;
        transform: none;
        width: var(--link-icons-only-size, 36px);
        height: var(--link-icons-only-size, 36px);
      }

      .links.icons-only .link span {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .links.icons-only .link.no-icon {
        aspect-ratio: auto;
        padding: 0.8rem 1rem;
        min-height: 48px;
      }

      .links.icons-only .link.no-icon span {
        position: static;
        width: auto;
        height: auto;
        margin: 0;
        overflow: visible;
        clip: auto;
        white-space: normal;
      }

      .links.icons-only .link::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 50%;
        bottom: calc(100% + 8px);
        transform: translateX(-50%) translateY(4px);
        background: rgba(0, 0, 0, 0.7);
        color: var(--ink);
        padding: 0.25rem 0.6rem;
        border-radius: 8px;
        font-size: 0.75rem;
        font-weight: 600;
        white-space: nowrap;
        max-width: min(80vw, 420px);
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 0;
        pointer-events: none;
        transition:
          opacity 0.15s ease,
          transform 0.15s ease;
      }

      .links.icons-only .link:hover::after,
      .links.icons-only .link:focus-visible::after {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      .links.icons-only .link[data-tooltip=""]::after {
        display: none;
      }

      .links.icons-only {
        gap: var(--link-icons-only-gap, 12px);
      }

      .links.icons-only.dir-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        grid-template-columns: none;
      }

      .links.icons-only.dir-row .link {
        width: calc(var(--link-icons-only-size, 36px) + 28px);
      }

      .links.icons-only.dir-row .link.no-icon {
        width: 100%;
      }

      .links.icons-only.dir-column {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        grid-template-columns: none;
      }

      .links.icons-only.icons-grouped {
        background: var(--link-bg);
        border: 1px solid #ffffff22;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 0.6rem;
      }

      .links.icons-only.icons-grouped .link {
        background: transparent;
        box-shadow: none;
        border-color: transparent;
      }

      .links.icons-only.icons-grouped .link:hover {
        background: #ffffff14;
      }

      .links.icons-only.icons-grouped.link-bg-alpha-zero {
        background: transparent;
        border-color: transparent;
        box-shadow: none;
      }

      .links.icons-only.icons-grouped.link-bg-alpha-zero .link:hover {
        background: transparent;
      }

      .card.wide .links.icons-only .link {
        justify-content: center;
        text-align: center;
        padding-left: 0.7rem;
      }
    </style>
  </head>

  <body class="canvas-editor">
    <div class="bg" id="bg"></div>
    <div
      id="enterOverlay"
      class="enter-gate hidden"
      role="button"
      tabindex="0"
      aria-label="Enter site to enable media"
    >
      <div class="enter-box">
          <p id="enterText" class="enter-text">Click to enter</p>
      </div>
    </div>
    <button id="soundBtn" class="sound-toggle hidden" aria-label="Toggle sound">
      <span class="dot" aria-hidden="true"></span>
      <span id="soundLabel">Sound off</span>
    </button>
    <div class="canvas-shell">
      <main class="canvas-stage">
        <div class="card" id="card">
          <div class="pfp-wrap">
            <img
              id="pfp"
              class="pfp"
              src="/static/icon.png"
              loading="lazy"
              decoding="async"
              alt="Profile picture"
            />
            <img
              id="pfpFrame"
              class="pfp-frame"
              src=""
              alt=""
              loading="lazy"
              decoding="async"
              style="display: none"
            />
            <span
              id="discordPresence"
              class="discord-presence hidden"
              role="img"
              aria-label="Discord status"
            ></span>
          </div>
          <div id="name" class="name">User</div>
          <div id="discordStatusLine" class="discord-status hidden">
            <span class="dot" aria-hidden="true"></span>
            <span id="discordStatusText" class="text"></span>
          </div>
          <div id="quote" class="quote">-</div>
          <div class="location" id="loc"></div>
          <div class="discord-badges hidden" id="discordBadges"></div>
          <div class="badges" id="badges"></div>

          <div id="audioPlayer" class="audio-player hidden">
            <div class="audio-meta">
              <div class="audio-title-wrap">
                <img
                  id="audioIcon"
                  class="audio-icon hidden"
                  alt=""
                  loading="lazy"
                  decoding="async"
                />
                <span id="audioTitle" class="audio-title">Audio</span>
              </div>
              <span id="audioTime" class="audio-time">0:00 / 0:00</span>
            </div>
            <input
              id="audioSeek"
              class="audio-seek"
              type="range"
              min="0"
              max="0"
              value="0"
            />
            <div class="audio-controls">
              <button
                id="audioBack"
                class="audio-btn"
                type="button"
                aria-label="Back 10 seconds"
              >
                <svg viewBox="0 0 24 24" aria-hidden="true" fill="currentColor">
                  <path d="M11 18V6l-6 6 6 6zM19 18V6l-6 6 6 6z" />
                </svg>
              </button>
              <button
                id="audioPlay"
                class="audio-btn primary"
                type="button"
                aria-label="Play or pause"
              >
                <svg
                  class="icon-play"
                  viewBox="0 0 24 24"
                  aria-hidden="true"
                  fill="currentColor"
                >
                  <path d="M8 5v14l11-7z" />
                </svg>
                <svg
                  class="icon-pause"
                  viewBox="0 0 24 24"
                  aria-hidden="true"
                  fill="currentColor"
                >
                  <path d="M6 5h4v14H6zm8 0h4v14h-4z" />
                </svg>
              </button>
              <button
                id="audioForward"
                class="audio-btn"
                type="button"
                aria-label="Forward 10 seconds"
              >
                <svg viewBox="0 0 24 24" aria-hidden="true" fill="currentColor">
                  <path d="M13 6v12l6-6-6-6zM5 6v12l6-6-6-6z" />
                </svg>
              </button>
            </div>
          </div>
          <div class="links" id="links"></div>
          <div id="visitCounter" class="visit-counter" style="display: none">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
              />
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
              />
            </svg>
            <span id="visitCounterValue">0</span>
          </div>
        </div>
      </main>

      <aside class="inspector" aria-label="Canvas inspector">
        <div class="inspector-header">
          <div class="field">
            <label for="inDevice">Device</label>
            <select id="inDevice" class="select">
              <option value="pc">Desktop</option>
              <option value="mobile">Mobile</option>
            </select>
          </div>
        </div>
        <div class="inspector-body">
          <div id="inspectorMsg" class="inspector-note"></div>
          <div id="canvasSizePanel">
            <h3>Canvas size</h3>
            <div class="row">
              <div class="field" style="flex: 1">
                <label for="inCanvasW">Width (px)</label>
                <input id="inCanvasW" class="input" type="number" min="10" />
              </div>
              <div class="field" style="flex: 1">
                <label for="inCanvasH">Height (px)</label>
                <input id="inCanvasH" class="input" type="number" min="10" />
              </div>
            </div>
            <div class="field" style="margin-top: 0.5rem">
              <label class="row" style="gap: 0.45rem; align-items: center">
                <input type="checkbox" id="inCanvasAutoFitObjects" />
                <span>Auto-fit canvas background to objects</span>
              </label>
              <div class="inspector-note">
                If enabled, the canvas grows automatically when objects are moved or resized beyond the current canvas size.
              </div>
            </div>
            <div class="field" style="margin-top: 0.5rem">
              <label class="row" style="gap: 0.45rem; align-items: center">
                <input type="checkbox" id="inCanvasAutoFitElementBackgrounds" />
                <span>Auto-fit element backgrounds to object size</span>
              </label>
              <div class="inspector-note">
                If enabled, backgrounds/surfaces of supported elements stretch with the resized object.
              </div>
            </div>
          </div>
          <div class="field">
            <label>Canvas reset</label>
            <button id="btnCanvasReset" class="btn ghost" type="button">
              Reset canvas to linktree
            </button>
            <div class="inspector-note">
              Resets the canvas layout to match the current linktree.
            </div>
          </div>

          <div>
            <h3>Selection</h3>
            <div class="inspector-note" id="selectionLabel">
              Select an element on the canvas.
            </div>
            <div class="row" style="margin-top: 0.6rem">
              <div class="field" style="flex: 1">
                <label for="inSelX">X (px)</label>
                <input id="inSelX" class="input" type="number" />
              </div>
              <div class="field" style="flex: 1">
                <label for="inSelY">Y (px)</label>
                <input id="inSelY" class="input" type="number" />
              </div>
            </div>
            <div class="row">
              <div class="field" style="flex: 1">
                <label for="inSelW">Width (px)</label>
                <input id="inSelW" class="input" type="number" />
              </div>
              <div class="field" style="flex: 1">
                <label for="inSelH">Height (px)</label>
                <input id="inSelH" class="input" type="number" />
              </div>
            </div>
            <div class="field" id="selectionGroupRow">
              <label id="selectionGroupLabel" for="inSelGroup">Group ID</label>
              <input
                id="inSelGroup"
                class="input"
                type="text"
                list="selGroupOptions"
              />
              <datalist id="selGroupOptions"></datalist>
              <div class="inspector-note">
                Leave empty to ungroup. New IDs create a group at the current position.
              </div>
            </div>
            <div id="selectionAttributes">
              <h3>Attributes</h3>
              <div id="selectionAttrEmpty" class="inspector-note">
                Select an element to edit its attributes.
              </div>
              <div id="selectionAttrPfp" hidden>
                <div class="field">
                  <label for="inAttrPfpFile">Upload profile picture</label>
                  <input id="inAttrPfpFile" class="input" type="file" accept="image/*" />
                  <input type="hidden" id="inAttrLinktreePfp" />
                  <div id="attrPfpStatus" class="inspector-note">
                    Using your account profile picture.
                  </div>
                  <div class="row" style="margin-top: 0.4rem">
                    <button class="btn ghost sm" type="button" id="btnAttrRemovePfp">
                      Remove picture
                    </button>
                  </div>
                </div>
                <div class="inspector-divider"></div>
                <div class="field">
                  <label>Discord (optional)</label>
                  <div id="attrDiscordStatusText" class="inspector-note">Not linked</div>
                  <div id="attrDiscordPreview" class="inspector-note">
                    Link Discord to use your profile frame.
                  </div>
                  <div class="row" style="gap: 0.5rem; flex-wrap: wrap">
                    <button class="btn sm" type="button" id="btnAttrDiscordLink">
                      Link Discord
                    </button>
                    <button
                      class="btn sm ghost"
                      type="button"
                      id="btnAttrDiscordUnlink"
                      style="display: none"
                    >
                      Unlink
                    </button>
                  </div>
                </div>
                <div class="field">
                  <label class="row" style="gap: 0.4rem; align-items: center">
                    <input type="checkbox" id="inAttrDiscordFrame" />
                    <span>Show my Discord profile frame around my avatar</span>
                  </label>
                  <div class="inspector-note">
                    Optional. Uses your current Discord profile frame if available.
                  </div>
                </div>
                <div class="field">
                  <label class="row" style="gap: 0.4rem; align-items: center">
                    <input type="checkbox" id="inAttrDiscordPresence" />
                    <span>Show my Discord activity status on my avatar</span>
                  </label>
                  <div class="inspector-note">
                    Status is read automatically from Discord (last known).
                  </div>
                </div>
              </div>

              <div id="selectionAttrName" hidden>
                <div class="field">
                  <label for="inAttrDisplayName">Display Name</label>
                  <select id="inAttrDisplayName" class="select">
                    <option value="slug">Slug</option>
                    <option value="username">Username</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
                <div class="field">
                  <label for="inAttrCustomName">Custom Name</label>
                  <input
                    id="inAttrCustomName"
                    class="input"
                    placeholder="Your name/nickname"
                    maxlength="64"
                  />
                  <div class="inspector-note">
                    Used when Display Name is set to Custom.
                  </div>
                </div>
                <div class="inspector-divider"></div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrNameColor">Name color</label>
                    <input id="inAttrNameColor" class="input" type="color" />
                  </div>
                  <div class="field" style="flex: 1">
                    <label for="inAttrNameEffect">Name effect</label>
                    <select id="inAttrNameEffect" class="select">
                      <option value="none">none</option>
                      <option value="glow">glow</option>
                      <option value="neon">neon</option>
                      <option value="rainbow">rainbow</option>
                    </select>
                  </div>
                </div>
                <div class="field">
                  <label for="inAttrNameFont">Name font</label>
                  <select id="inAttrNameFont" class="select">
                    <option value="default">default</option>
                    <option value="serif">serif</option>
                    <option value="mono">mono</option>
                    <option value="script">script</option>
                    <option value="display">display</option>
                  </select>
                </div>
              </div>

              <div id="selectionAttrDiscordStatus" hidden>
                <div class="field">
                  <label class="row" style="gap: 0.4rem; align-items: center">
                    <input type="checkbox" id="inAttrDiscordStatus" />
                    <span>Show my Discord status line on the linktree</span>
                  </label>
                  <div class="inspector-note">
                    Custom status text is pulled from Discord automatically.
                  </div>
                </div>
              </div>

              <div id="selectionAttrQuote" hidden>
                <div class="field">
                  <label for="inAttrQuote">Quote</label>
                  <textarea
                    id="inAttrQuote"
                    class="input"
                    rows="3"
                    placeholder="Write your bio/quote…"
                  ></textarea>
                </div>
                <div class="field">
                  <label class="row" style="gap: 0.4rem; align-items: center">
                    <input type="checkbox" id="inAttrQuoteTyping" />
                    <span>Typewriter quote (cycle up to 3 texts)</span>
                  </label>
                </div>
                <div id="attrQuoteTypingFields" class="grid-2">
                  <div class="field">
                    <label for="inAttrQuoteAlt1">Quote text 2</label>
                    <input
                      id="inAttrQuoteAlt1"
                      class="input"
                      placeholder="Second quote text"
                    />
                  </div>
                  <div class="field">
                    <label for="inAttrQuoteAlt2">Quote text 3</label>
                    <input
                      id="inAttrQuoteAlt2"
                      class="input"
                      placeholder="Third quote text"
                    />
                  </div>
                </div>
                <div class="field" id="attrQuoteTypingSpeedWrap">
                  <label for="inAttrQuoteSpeed">Typewriter speed (ms per char)</label>
                  <input id="inAttrQuoteSpeed" class="input" type="number" min="20" max="200" />
                </div>
                <div class="field" id="attrQuoteTypingPauseWrap">
                  <label for="inAttrQuotePause">Pause before next quote (ms)</label>
                  <input id="inAttrQuotePause" class="input" type="number" min="200" max="10000" />
                </div>
                <div class="inspector-divider"></div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrQuoteColor">Quote color</label>
                    <input id="inAttrQuoteColor" class="input" type="color" />
                  </div>
                  <div class="field" style="flex: 1">
                    <label for="inAttrQuoteEffect">Quote effect</label>
                    <select id="inAttrQuoteEffect" class="select">
                      <option value="none">none</option>
                      <option value="glow">glow</option>
                      <option value="neon">neon</option>
                      <option value="rainbow">rainbow</option>
                    </select>
                  </div>
                </div>
                <div class="field">
                  <label for="inAttrQuoteFont">Quote font</label>
                  <select id="inAttrQuoteFont" class="select">
                    <option value="default">default</option>
                    <option value="serif">serif</option>
                    <option value="mono">mono</option>
                    <option value="script">script</option>
                    <option value="display">display</option>
                  </select>
                </div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrQuoteSize">Quote font size (px)</label>
                    <input
                      id="inAttrQuoteSize"
                      class="input"
                      type="number"
                      min="10"
                      max="40"
                    />
                  </div>
                  <div class="field" style="flex: 1">
                    <label for="inAttrQuoteEffectStrength"
                      >Quote effect strength (0-100)</label
                    >
                    <input
                      id="inAttrQuoteEffectStrength"
                      class="input"
                      type="number"
                      min="0"
                      max="100"
                    />
                  </div>
                </div>
              </div>

              <div id="selectionAttrLocation" hidden>
                <div class="field">
                  <label for="inAttrLocation">Location</label>
                  <input
                    id="inAttrLocation"
                    class="input"
                    placeholder="Switzerland"
                  />
                </div>
                <div class="field">
                  <label for="inAttrLocationColor">Location Color</label>
                  <input id="inAttrLocationColor" class="input" type="color" />
                </div>
              </div>

              <div id="selectionAttrBadges" hidden>
                <div class="field">
                  <label class="row" style="gap: 0.4rem; align-items: center">
                    <input type="checkbox" id="inAttrDiscordBadges" />
                    <span>Show my Discord badges</span>
                  </label>
                </div>
                <div id="attrDiscordBadgesList" class="badge-grid"></div>
                <div id="attrDiscordBadgesHint" class="inspector-note"></div>
                <div class="inspector-divider"></div>
                <div class="field">
                  <label>Badges</label>
                </div>
                <div id="attrBadgesList" class="badge-grid"></div>
              </div>

              <div id="selectionAttrAudio" hidden>
                <div class="field">
                  <label for="inAttrSongFile">Upload Song</label>
                  <input type="file" id="inAttrSongFile" class="input" accept="audio/*" />
                  <input type="hidden" id="inAttrSong" />
                  <input type="hidden" id="inAttrSongName" />
                  <div id="attrSongStatus" class="inspector-note">
                    No song uploaded yet.
                  </div>
                  <div class="row" style="margin-top: 0.4rem">
                    <button class="btn ghost sm" type="button" id="btnAttrRemoveSong">
                      Remove Song
                    </button>
                  </div>
                </div>
                <div class="field">
                  <label for="inAttrSongIconFile">Upload Song Icon</label>
                  <input type="file" id="inAttrSongIconFile" class="input" accept="image/*" />
                  <input type="hidden" id="inAttrSongIcon" />
                  <div id="attrSongIconStatus" class="inspector-note">
                    No icon uploaded.
                  </div>
                  <div class="row" style="margin-top: 0.4rem">
                    <button
                      class="btn ghost sm"
                      type="button"
                      id="btnAttrRemoveSongIcon"
                    >
                      Remove Icon
                    </button>
                  </div>
                </div>
                <div class="field">
                  <label class="row" style="gap: 0.4rem; align-items: center">
                    <input type="checkbox" id="inAttrAudioPlayer" />
                    <span>Show audio player controls</span>
                  </label>
                  <div class="inspector-note">
                    Shows the player when a song is uploaded.
                  </div>
                </div>
                <div class="inspector-divider"></div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrAudioBgColor">Audio player background</label>
                    <input
                      id="inAttrAudioBgColor"
                      class="input"
                      type="color"
                    />
                  </div>
                  <div class="field" style="flex: 1">
                    <label for="inAttrAudioBgAlpha"
                      >Audio player transparency (0-100)</label
                    >
                    <input
                      id="inAttrAudioBgAlpha"
                      class="input"
                      type="number"
                      min="0"
                      max="100"
                    />
                  </div>
                </div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrAudioTextColor">Audio player text color</label>
                    <input
                      id="inAttrAudioTextColor"
                      class="input"
                      type="color"
                    />
                  </div>
                  <div class="field" style="flex: 1">
                    <label for="inAttrAudioAccentColor">Audio player accent color</label>
                    <input
                      id="inAttrAudioAccentColor"
                      class="input"
                      type="color"
                    />
                  </div>
                </div>
              </div>

              <div id="selectionAttrLinks" hidden>
                <div id="attrLinksMsg" class="inspector-note"></div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrLinkColor">Link Text Color</label>
                    <input id="inAttrLinkColor" class="input" type="color" />
                  </div>
                  <div class="field" style="flex: 1">
                    <label for="inAttrLinkBgColor">Link Background Color</label>
                    <input id="inAttrLinkBgColor" class="input" type="color" />
                  </div>
                </div>
                <div class="field">
                  <label for="inAttrLinkBgAlpha"
                    >Link Background Opacity (0 = unsichtbar, 100 = sichtbar)</label
                  >
                  <input
                    id="inAttrLinkBgAlpha"
                    class="input"
                    type="number"
                    min="0"
                    max="100"
                  />
                </div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrLinkColumns">Links per row (1-8)</label>
                    <input
                      id="inAttrLinkColumns"
                      class="input"
                      type="number"
                      min="1"
                      max="8"
                      placeholder="auto"
                    />
                    <div class="inspector-note">
                      1 = untereinander, 2 = zwei nebeneinander …
                    </div>
                  </div>
                  <div class="field" style="flex: 1">
                    <label class="row" style="gap: 0.4rem; align-items: center">
                      <input type="checkbox" id="inAttrLinkIconsOnly" />
                      <span>Icons only (URL on hover)</span>
                    </label>
                  </div>
                </div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrLinkIconsOnlySize">Icon size (px)</label>
                    <input
                      id="inAttrLinkIconsOnlySize"
                      class="input"
                      type="number"
                      min="16"
                      max="128"
                      value="36"
                    />
                  </div>
                  <div class="field" style="flex: 1">
                    <label for="inAttrLinkIconsOnlyGap">Icon gap (px)</label>
                    <input
                      id="inAttrLinkIconsOnlyGap"
                      class="input"
                      type="number"
                      min="0"
                      max="64"
                      value="12"
                    />
                  </div>
                </div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrLinkIconsOnlyGrouped">Icon surface</label>
                    <select id="inAttrLinkIconsOnlyGrouped" class="select">
                      <option value="separate">Einzeln</option>
                      <option value="grouped">Auf einem</option>
                    </select>
                  </div>
                  <div class="field" style="flex: 1">
                    <label for="inAttrLinkIconsOnlyDirection">Direction</label>
                    <select id="inAttrLinkIconsOnlyDirection" class="select">
                      <option value="row">Links nach rechts</option>
                      <option value="column">Oben nach unten</option>
                    </select>
                  </div>
                </div>
                <div class="inspector-divider"></div>
                <div class="field">
                  <label for="inAttrLinkUrl">URL</label>
                  <input id="inAttrLinkUrl" class="input" placeholder="https://…" />
                </div>
                <div class="field">
                  <label for="inAttrLinkLabel">Label</label>
                  <input id="inAttrLinkLabel" class="input" placeholder="My Link" />
                </div>
                <div class="field">
                  <label for="inAttrLinkIconFile">Upload Link Icon</label>
                  <input type="file" id="inAttrLinkIconFile" class="input" accept="image/*" />
                  <input type="hidden" id="inAttrLinkIcon" />
                  <div id="attrLinkIconStatus" class="inspector-note">
                    No icon uploaded.
                  </div>
                  <div class="row" style="margin-top: 0.4rem">
                    <button
                      class="btn ghost sm"
                      type="button"
                      id="btnAttrRemoveLinkIcon"
                    >
                      Remove Icon
                    </button>
                  </div>
                </div>
                <div class="field">
                  <label for="inAttrLinkActive">Active</label>
                  <select id="inAttrLinkActive" class="select">
                    <option value="true">Yes</option>
                    <option value="false">No</option>
                  </select>
                </div>
                <div class="row">
                  <button class="btn sm" type="button" id="btnAttrAddLink">
                    Add Link
                  </button>
                </div>
                <div class="inspector-divider"></div>
                <div class="links-list" id="attrLinksList" aria-live="polite"></div>
              </div>

              <div id="selectionAttrCounter" hidden>
                <div class="field">
                  <label class="row" style="gap: 0.4rem; align-items: center">
                    <input type="checkbox" id="inAttrShowCounter" />
                    <span>Show visitor counter on my profile</span>
                  </label>
                  <div class="inspector-note">
                    Counts unique visitors. Current: <strong id="attrVisitCount">0</strong>
                  </div>
                </div>
                <div class="row">
                  <div class="field" style="flex: 1">
                    <label for="inAttrCounterColor">Counter Text/Icon Color</label>
                    <input id="inAttrCounterColor" class="input" type="color" />
                  </div>
                  <div class="field" style="flex: 1">
                    <label for="inAttrCounterBgColor">Counter Background Color</label>
                    <input id="inAttrCounterBgColor" class="input" type="color" />
                  </div>
                </div>
                <div class="field">
                  <label for="inAttrCounterBgAlpha"
                    >Counter Background Transparency (0-100)</label
                  >
                  <input
                    id="inAttrCounterBgAlpha"
                    class="input"
                    type="number"
                    min="0"
                    max="100"
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-footer">
          <button id="btnSaveCanvas" class="btn" type="button">
            Save canvas
          </button>
        </div>
      </aside>
    </div>

    <footer>© <span id="year"></span> TAOMA™</footer>

    <script>
      async function resizeCursorImage(url, size = 32) {
        return new Promise((resolve, reject) => {
          const img = new Image();

          img.crossOrigin = "anonymous"; // Wichtig, falls das PNG von deiner Domain kommt
          img.onload = () => {
            // Canvas erstellen
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;

            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, size, size);

            // Bild proportional skalieren
            const scale = Math.min(size / img.width, size / img.height);
            const w = img.width * scale;
            const h = img.height * scale;

            const x = (size - w) / 2;
            const y = (size - h) / 2;

            ctx.drawImage(img, x, y, w, h);

            // Base64 URL erzeugen
            const resizedUrl = canvas.toDataURL("image/png");
            resolve(resizedUrl);
          };

          img.onerror = reject;
          img.src = url;
        });
      }

      (() => {
        "use strict";

        const yearEl = document.getElementById("year");
        if (yearEl) yearEl.textContent = new Date().getFullYear();

        const soundBtn = document.getElementById("soundBtn");
        const soundLabel = document.getElementById("soundLabel");
        const audioPlayer = document.getElementById("audioPlayer");
        const audioIcon = document.getElementById("audioIcon");
        const audioTitle = document.getElementById("audioTitle");
        const audioTime = document.getElementById("audioTime");
        const audioSeek = document.getElementById("audioSeek");
        const audioPlayBtn = document.getElementById("audioPlay");
        const audioBackBtn = document.getElementById("audioBack");
        const audioForwardBtn = document.getElementById("audioForward");
        let bgVideo = null;
        let bgAudio = null;
        let soundOn = false;
        let gateActive = false;
        let audioSeekActive = false;
        let audioCleanup = null;
        let quoteTypingToken = 0;

        function safeUrl(
          raw,
          { allowRelative = true, allowedProtocols = ["http:", "https:"] } = {},
        ) {
          if (typeof raw !== "string") return "";
          const trimmed = raw.trim();
          if (!trimmed) return "";
          if (/^javascript:/i.test(trimmed)) return "";
          try {
            const parsed = new URL(trimmed, window.location.origin);
            if (allowedProtocols.includes(parsed.protocol)) {
              if (
                (parsed.protocol === "http:" || parsed.protocol === "https:") &&
                !trimmed.startsWith("http") &&
                allowRelative
              ) {
                return trimmed;
              }
              return parsed.href;
            }
          } catch (_) {
            if (
              allowRelative &&
              trimmed.startsWith("/") &&
              !trimmed.startsWith("//")
            ) {
              return trimmed;
            }
          }
          if (
            allowRelative &&
            trimmed.startsWith("/") &&
            !trimmed.startsWith("//")
          ) {
            return trimmed;
          }
          return "";
        }

        const safeMediaUrl = (raw) =>
          safeUrl(raw, {
            allowRelative: true,
            allowedProtocols: ["http:", "https:"],
          });

        function escapeHtml(value) {
          return String(value || "")
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\"/g, "&quot;")
            .replace(/'/g, "&#39;");
        }

        const hashedFileCache = new WeakMap();
        async function withHashedFile(file) {
          if (!file) return null;
          if (hashedFileCache.has(file)) return hashedFileCache.get(file);
          const name = file.name || "upload";
          const dot = name.lastIndexOf(".");
          const base = dot > 0 ? name.slice(0, dot) : name;
          const ext = dot > 0 ? name.slice(dot) : "";
          let hash = "";
          try {
            const buf = await file.arrayBuffer();
            const digest = await crypto.subtle.digest("SHA-256", buf);
            hash = Array.from(new Uint8Array(digest))
              .map((b) => b.toString(16).padStart(2, "0"))
              .join("")
              .slice(0, 16);
          } catch (_) {
            hash = Math.random().toString(16).slice(2, 10);
          }
          const safeBase = base.replace(/[^a-zA-Z0-9._-]/g, "_");
          const hashedName = `${safeBase}--${hash}${ext}`;
          const hashed = new File([file], hashedName, {
            type: file.type,
            lastModified: file.lastModified,
          });
          hashedFileCache.set(file, hashed);
          return hashed;
        }

        function fileNameFromUrl(raw) {
          if (!raw) return "";
          try {
            const url = new URL(raw, window.location.origin);
            const name = url.pathname.split("/").pop() || "";
            return decodeURIComponent(name);
          } catch (_) {
            const trimmed = String(raw);
            const parts = trimmed.split("/");
            return parts[parts.length - 1] || trimmed;
          }
        }

        function setUploadStatus(id, url, emptyText, name) {
          const el = document.getElementById(id);
          if (!el) return;
          if (url) {
            const label = name || fileNameFromUrl(url);
            el.textContent = label ? `Uploaded: ${label}` : "Uploaded.";
          } else {
            el.textContent = emptyText || "";
          }
        }

        async function uploadFile(inputId, endpoint) {
          const inputEl = document.getElementById(inputId);
          if (!inputEl || !inputEl.files || !inputEl.files[0]) return null;
          const raw = inputEl.files[0];
          const f = (await withHashedFile(raw)) || raw;
          if (!currentUser) await fetchSessionUser();
          const fd = new FormData();
          fd.append("file", f);
          const r = await fetch(endpoint, {
            method: "POST",
            credentials: "include",
            body: fd,
          });
          if (!r.ok) throw new Error(await r.text());
          const data = await r.json();
          if (!data) return { url: "" };
          if (typeof data === "string") return { url: data };
          if (typeof data === "object") {
            return {
              url: typeof data.url === "string" ? data.url : "",
              name: typeof data.name === "string" ? data.name : "",
            };
          }
          return { url: "" };
        }

        async function uploadInlineFile(inputEl, endpoint) {
          if (!inputEl || !inputEl.files || !inputEl.files[0]) return null;
          const raw = inputEl.files[0];
          const f = (await withHashedFile(raw)) || raw;
          if (!currentUser) await fetchSessionUser();
          const fd = new FormData();
          fd.append("file", f);
          const r = await fetch(endpoint, {
            method: "POST",
            credentials: "include",
            body: fd,
          });
          if (!r.ok) throw new Error(await r.text());
          const data = await r.json();
          if (!data) return "";
          if (typeof data === "string") return data;
          if (typeof data === "object" && typeof data.url === "string") {
            return data.url;
          }
          return "";
        }

        function hashString(input) {
          let h = 2166136261;
          const str = String(input || "");
          for (let i = 0; i < str.length; i += 1) {
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619);
          }
          return (h >>> 0).toString(16);
        }

        function hexToRgba(hex, alpha = 1) {
          const m = /^#?([a-fA-F0-9]{3}|[a-fA-F0-9]{6})$/.exec(
            (hex || "").trim(),
          );
          if (!m) return null;
          let h = m[1];
          if (h.length === 3)
            h = h
              .split("")
              .map((c) => c + c)
              .join("");
          const int = parseInt(h, 16);
          const r = (int >> 16) & 255;
          const g = (int >> 8) & 255;
          const b = int & 255;
          const a = Math.min(1, Math.max(0, alpha));
          return `rgba(${r}, ${g}, ${b}, ${a})`;
        }
        const safeLinkUrl = (raw) =>
          safeUrl(raw, {
            allowRelative: false,
            allowedProtocols: ["http:", "https:", "mailto:", "tel:"],
          });

        const VIDEO_EXTENSIONS = [".mp4", ".webm", ".m4v", ".mov"];
        const looksLikeVideo = (url) =>
          VIDEO_EXTENSIONS.some((ext) =>
            (url || "").toLowerCase().includes(ext),
          );

        function pickBackgroundSource(data, preferLite) {
          const primary = safeMediaUrl(data.background_url);
          const low =
            preferLite &&
            (safeMediaUrl(data.background_low_url) ||
              safeMediaUrl(data.background_preview_url) ||
              null);
          const chosen = (low || primary || "").trim();
          const isVideo = looksLikeVideo(chosen) || !!data.background_is_video;
          const useVideo =
            isVideo && !(preferLite && low && !looksLikeVideo(low));
          return { url: chosen, isVideo: useVideo };
        }

        function cleanMetaText(value, maxLen = 180) {
          if (value === undefined || value === null) return "";
          const text = String(value).replace(/\s+/g, " ").trim();
          if (!text) return "";
          return text.length > maxLen ? `${text.slice(0, maxLen - 1)}…` : text;
        }

        function resolveDisplayName(data) {
          const mode = (data && data.display_name_mode) || "slug";
          if (mode === "username") {
            return (data.user_username || data.slug || "").trim();
          }
          if (mode === "custom" && data.custom_display_name) {
            return String(data.custom_display_name).trim();
          }
          return (data.slug || data.user_username || "").trim();
        }

        function resolveQuoteText(data) {
          const list = Array.isArray(data?.quote_typing_texts)
            ? data.quote_typing_texts
            : [];
          for (const entry of list) {
            const text = String(entry || "").trim();
            if (text) return text;
          }
          const fallback = String(data?.quote || "").trim();
          return fallback;
        }

        function toAbsoluteUrl(raw) {
          if (!raw) return "";
          try {
            return new URL(raw, window.location.origin).href;
          } catch (_) {
            return raw;
          }
        }

        function setMetaProperty(prop, content) {
          if (!prop || !content) return;
          let el = document.querySelector(`meta[property="${prop}"]`);
          if (!el) {
            el = document.createElement("meta");
            el.setAttribute("property", prop);
            document.head.appendChild(el);
          }
          el.setAttribute("content", content);
        }

        function setMetaName(name, content) {
          if (!name || !content) return;
          let el = document.querySelector(`meta[name="${name}"]`);
          if (!el) {
            el = document.createElement("meta");
            el.setAttribute("name", name);
            document.head.appendChild(el);
          }
          el.setAttribute("content", content);
        }

        function setCanonical(url) {
          if (!url) return;
          let el = document.querySelector('link[rel="canonical"]');
          if (!el) {
            el = document.createElement("link");
            el.setAttribute("rel", "canonical");
            document.head.appendChild(el);
          }
          el.setAttribute("href", url);
        }

        function applyMeta(data, { bgUrl, bgIsVideo } = {}) {
          if (!data) return;
          const name = cleanMetaText(resolveDisplayName(data)) || "Custom Linktree";
          const title = `TAOMA™ – ${name}`;
          const quote = cleanMetaText(resolveQuoteText(data));
          const loc = cleanMetaText(data?.location);
          const description =
            quote || (loc ? `Location: ${loc}` : "Build your own powerful, customizable linktree");

          const url =
            data.is_template_demo || !data.slug
              ? window.location.href
              : new URL(
                  `/tree/${encodeURIComponent(data.slug)}`,
                  window.location.origin,
                ).href;

          let image = "";
          if (bgUrl && !bgIsVideo) image = bgUrl;
          if (!image) {
            image =
              safeMediaUrl(data.linktree_profile_picture) ||
              safeMediaUrl(data.profile_picture) ||
              safeMediaUrl(currentUser && currentUser.profile_picture) ||
              "/static/icon.png";
          }
          const ogImage = toAbsoluteUrl(image);

          document.title = title;
          setCanonical(url);
          setMetaProperty("og:title", title);
          setMetaProperty("og:description", description);
          setMetaProperty("og:image", ogImage);
          setMetaProperty("og:url", url);
          setMetaName("twitter:card", "summary_large_image");
          setMetaName("twitter:title", title);
          setMetaName("twitter:description", description);
          setMetaName("twitter:image", ogImage);
        }

        const DEFAULT_LINK_COLOR = "#e9ebff";
        const DEFAULT_LINK_BG = "#171b3b";
        const DEFAULT_CARD_COLOR = "#171b3b";
        const DEFAULT_TEXT_COLOR = "#e9ebff";
        const DEFAULT_NAME_COLOR = "#e9ebff";
        const DEFAULT_LOCATION_COLOR = "#a2a9c8";
        const DEFAULT_QUOTE_COLOR = "#e9ebff";
        const DEFAULT_ENTRY_BG_COLOR = "#0f1223";
        const DEFAULT_ENTRY_BG_ALPHA = 85;
        const DEFAULT_ENTRY_OVERLAY_ALPHA = 35;
        const DEFAULT_ENTRY_TEXT_COLOR = "#e9ebff";
        const DEFAULT_ENTRY_FONT_SIZE = 16;
        const DEFAULT_AUDIO_BG_COLOR = "#171b3b";
        const DEFAULT_AUDIO_BG_ALPHA = 60;
        const DEFAULT_AUDIO_TEXT_COLOR = "#e9ebff";
        const DEFAULT_AUDIO_ACCENT_COLOR = "#85a3ff";
        const DEFAULT_CURSOR_FX_ALPHA = 0.7;
        const LINK_COLUMNS_MIN = 1;
        const LINK_COLUMNS_MAX = 8;
        const LINK_ICONS_ONLY_SIZE_MIN = 16;
        const LINK_ICONS_ONLY_SIZE_MAX = 128;
        const LINK_ICONS_ONLY_SIZE_DEFAULT = 36;
        const LINK_ICONS_ONLY_GAP_MIN = 0;
        const LINK_ICONS_ONLY_GAP_MAX = 64;
        const LINK_ICONS_ONLY_GAP_DEFAULT = 12;
        const CURSOR_IMAGE_SIZE = 32;
        const EDITOR_MODE = true;
        const SECTION_ORDER_DEFAULT = [
          "pfp",
          "name",
          "discord_status",
          "quote",
          "location",
          "badges",
          "audio",
          "links",
          "visit_counter",
        ];
        const FONT_FAMILY_OPTIONS = ["default", "serif", "mono", "script", "display"];
        const EFFECT_OPTIONS = ["none", "glow", "neon", "rainbow"];
        const SECTION_KEY_ALIASES = {
          discord_badges: "badges",
        };
        const SECTION_LABELS = {
          pfp: "Profile picture",
          name: "Display name",
          discord_status: "Discord status",
          quote: "Quote",
          location: "Location",
          badges: "Badges",
          audio: "Audio player",
          links: "Links",
          visit_counter: "Visit counter",
        };
        const SECTION_ORDER_ALLOWED = new Set(SECTION_ORDER_DEFAULT);
        const CANVAS_PLATE_MIN_W = 1;
        const CANVAS_PLATE_MIN_H = 1;
        const CANVAS_PLATE_MAX_W = 20000;
        const CANVAS_PLATE_MAX_H = 20000;
        const CANVAS_SIZE_MIN_W = 1;
        const CANVAS_SIZE_MIN_H = 1;
        const CANVAS_LEGACY_GRID_DEFAULT = 8;
        let canvasLayout = null;
        let canvasSelection = null;
        let canvasDragState = null;
        let canvasStageBound = false;
        let canvasDirty = false;
        let metaDirtyFields = new Set();
        let pfpSizeOffsets = null;
        let currentDevice = "pc";
        let linktreeId = null;
        let currentLinks = [];
        let discordBadgeCodes = null;
        let dragStartOrder = "";

        function defaultPlateUnits(key) {
          switch (key) {
            case "pfp":
              return { w: 14, h: 14 };
            case "name":
              return { w: 24, h: 6 };
            case "discord_status":
              return { w: 24, h: 6 };
            case "quote":
              return { w: 32, h: 10 };
            case "location":
              return { w: 20, h: 5 };
            case "badges":
              return { w: 24, h: 8 };
            case "audio":
              return { w: 28, h: 8 };
            case "links":
              return { w: 32, h: 26 };
            case "visit_counter":
              return { w: 20, h: 6 };
            default:
              return { w: 18, h: 6 };
          }
        }

        function defaultPlatePixels(key) {
          const el = getSectionElement(key);
          if (el) {
            const rect = el.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              return { w: Math.round(rect.width), h: Math.round(rect.height) };
            }
          }
          const units = defaultPlateUnits(key);
          return {
            w: units.w * CANVAS_LEGACY_GRID_DEFAULT,
            h: units.h * CANVAS_LEGACY_GRID_DEFAULT,
          };
        }

        function computeCanvasContentBounds(layout) {
          const plates = layout?.plates || {};
          const groups = layout?.groups || {};
          let maxX = 0;
          let maxY = 0;
          Object.entries(plates).forEach(([key, plate]) => {
            if (!plate) return;
            const w = Number.isFinite(plate.w)
              ? plate.w
              : defaultPlatePixels(key).w;
            const h = Number.isFinite(plate.h)
              ? plate.h
              : defaultPlatePixels(key).h;
            const group =
              plate.group && groups[plate.group] ? groups[plate.group] : null;
            const offsetX = group ? group.x : 0;
            const offsetY = group ? group.y : 0;
            const x = (Number.isFinite(plate.x) ? plate.x : 0) + offsetX;
            const y = (Number.isFinite(plate.y) ? plate.y : 0) + offsetY;
            maxX = Math.max(maxX, x + w);
            maxY = Math.max(maxY, y + h);
          });
          return {
            w: Math.max(CANVAS_SIZE_MIN_W, maxX + 2),
            h: Math.max(CANVAS_SIZE_MIN_H, maxY + 2),
          };
        }

        function normalizeSectionOrder(raw) {
          let items = [];
          if (Array.isArray(raw)) {
            items = raw;
          } else if (typeof raw === "string") {
            try {
              const parsed = JSON.parse(raw);
              if (Array.isArray(parsed)) items = parsed;
            } catch (_) {
              items = [raw];
            }
          }
          const out = [];
          const seen = new Set();
          items.forEach((item) => {
            if (item === null || item === undefined) return;
            if (Array.isArray(item)) {
              const row = [];
              item.forEach((sub) => {
                const rawKey = String(sub || "").trim().toLowerCase();
                const key = SECTION_KEY_ALIASES[rawKey] || rawKey;
                if (!key || !SECTION_ORDER_ALLOWED.has(key)) return;
                if (seen.has(key)) return;
                seen.add(key);
                row.push(key);
              });
              if (row.length === 1) {
                out.push(row[0]);
              } else if (row.length > 1) {
                out.push(row.slice(0, 2));
              }
              return;
            }
            const rawKey = String(item || "").trim().toLowerCase();
            const key = SECTION_KEY_ALIASES[rawKey] || rawKey;
            if (!key || !SECTION_ORDER_ALLOWED.has(key)) return;
            if (seen.has(key)) return;
            seen.add(key);
            out.push(key);
          });
          SECTION_ORDER_DEFAULT.forEach((key) => {
            if (!seen.has(key)) {
              out.push(key);
              seen.add(key);
            }
          });
          return out;
        }

        function getSectionElement(key) {
          switch (key) {
            case "pfp":
              return document.querySelector(".pfp-wrap");
            case "name":
              return document.getElementById("name");
            case "discord_status":
              return document.getElementById("discordStatusLine");
            case "quote":
              return document.getElementById("quote");
            case "location":
              return document.getElementById("loc");
            case "badges":
              return document.getElementById("badges");
            case "discord_badges":
              return document.getElementById("badges");
            case "audio":
              return document.getElementById("audioPlayer");
            case "links":
              return document.getElementById("links");
            case "visit_counter":
              return document.getElementById("visitCounter");
            default:
              return null;
          }
        }

        function clearSectionRows(card) {
          const existingRows = card.querySelectorAll(".section-row");
          existingRows.forEach((row) => {
            while (row.firstChild) {
              card.insertBefore(row.firstChild, row);
            }
            row.remove();
          });
        }

        function resetCanvasLayout(card) {
          if (!card) return;
          clearSectionRows(card);
          card.classList.remove("canvas");
          card.style.removeProperty("min-height");
          card.style.removeProperty("width");
          card.style.removeProperty("height");
          card.style.removeProperty("max-width");
          card.style.removeProperty("padding");
          const groups = card.querySelectorAll(".plate-group");
          groups.forEach((group) => {
            while (group.firstChild) {
              card.insertBefore(group.firstChild, group);
            }
            group.remove();
          });
          SECTION_ORDER_DEFAULT.forEach((key) => {
            const el = getSectionElement(key);
            if (!el) return;
            el.classList.remove("canvas-plate");
            el.style.removeProperty("position");
            el.style.removeProperty("left");
            el.style.removeProperty("top");
            el.style.removeProperty("transform");
            el.style.removeProperty("margin");
            el.style.removeProperty("width");
            el.style.removeProperty("height");
            el.style.removeProperty("max-width");
            el.style.removeProperty("max-height");
            el.onmousedown = null;
            el.onclick = null;
            el.removeAttribute("data-key");
            el.querySelectorAll(".resize-handle").forEach((n) => n.remove());
            if (key === "pfp") {
              const img = el.querySelector(".pfp");
              if (img) {
                img.style.removeProperty("width");
                img.style.removeProperty("height");
              }
            }
          });
        }

        function flattenSectionOrder(order) {
          const list = [];
          (order || SECTION_ORDER_DEFAULT).forEach((item) => {
            if (Array.isArray(item)) {
              item.forEach((key) => list.push(key));
            } else {
              list.push(item);
            }
          });
          return list;
        }

        function buildDefaultCanvasLayout(order) {
          const plates = {};
          let y = 24;
          flattenSectionOrder(order).forEach((key) => {
            const size = defaultPlatePixels(key);
            plates[key] = { x: 24, y, w: size.w, h: size.h, group: null };
            y += size.h + 24;
          });
          const bounds = computeCanvasContentBounds({
            plates,
            groups: {},
          });
          return {
            enabled: true,
            grid: 1,
            auto_fit_canvas_to_objects: false,
            auto_fit_element_backgrounds: false,
            size: { w: bounds.w, h: bounds.h },
            plates,
            groups: {},
          };
        }

        function buildCanvasLayoutFromDom(order) {
          const card = document.getElementById("card");
          const layout = buildDefaultCanvasLayout(order);
          if (!card) return layout;
          const cardRect = card.getBoundingClientRect();
          const nextPlates = { ...layout.plates };
          flattenSectionOrder(order).forEach((key) => {
            const el = getSectionElement(key);
            if (!el) return;
            const rect = el.getBoundingClientRect();
            if (!rect.width && !rect.height) return;
            const x = Math.round(rect.left - cardRect.left);
            const y = Math.round(rect.top - cardRect.top);
            const w = Math.round(rect.width);
            const h = Math.round(rect.height);
            nextPlates[key] = {
              x: Math.max(0, x),
              y: Math.max(0, y),
              w: Math.min(
                CANVAS_PLATE_MAX_W,
                Math.max(CANVAS_PLATE_MIN_W, w || defaultPlatePixels(key).w),
              ),
              h: Math.min(
                CANVAS_PLATE_MAX_H,
                Math.max(CANVAS_PLATE_MIN_H, h || defaultPlatePixels(key).h),
              ),
              group: null,
            };
          });
          const sizeW = Math.round(cardRect.width);
          const sizeH = Math.round(cardRect.height);
          layout.plates = nextPlates;
          layout.size = {
            w: Math.max(CANVAS_SIZE_MIN_W, sizeW),
            h: Math.max(CANVAS_SIZE_MIN_H, sizeH),
          };
          return layout;
        }

        function normalizeCanvasLayout(raw, order) {
          if (!raw) return null;
          let data = raw;
          if (typeof raw === "string") {
            try {
              data = JSON.parse(raw);
            } catch (_) {
              return null;
            }
          }
          if (!data || typeof data !== "object") return null;
          const gridRaw = parseInt(data.grid ?? 1, 10);
          const legacyGrid = Number.isFinite(gridRaw) && gridRaw > 1 ? gridRaw : 1;
          const scale = legacyGrid;
          const fallback = buildDefaultCanvasLayout(order);
          const plates = {};
          const groups = {};
          let size = null;
          if (data.size && typeof data.size === "object") {
            const sw = parseInt(data.size.w ?? 0, 10);
            const sh = parseInt(data.size.h ?? 0, 10);
            if (Number.isFinite(sw) && Number.isFinite(sh)) {
              size = {
                w: Math.min(
                  CANVAS_PLATE_MAX_W,
                  Math.max(CANVAS_SIZE_MIN_W, sw * scale),
                ),
                h: Math.min(
                  CANVAS_PLATE_MAX_H,
                  Math.max(CANVAS_SIZE_MIN_H, sh * scale),
                ),
              };
            }
          }
          if (data.groups && typeof data.groups === "object") {
            Object.entries(data.groups).forEach(([gid, g]) => {
              if (!g || typeof g !== "object") return;
              const gx = parseInt(g.x ?? 0, 10);
              const gy = parseInt(g.y ?? 0, 10);
              if (!Number.isFinite(gx) || !Number.isFinite(gy)) return;
              groups[String(gid)] = { x: gx * scale, y: gy * scale };
            });
          }
          if (data.plates && typeof data.plates === "object") {
            Object.entries(data.plates).forEach(([key, plate]) => {
              const rawKey = String(key || "").trim().toLowerCase();
              const k = SECTION_KEY_ALIASES[rawKey] || rawKey;
            if (!k || !SECTION_ORDER_ALLOWED.has(k)) return;
            if (!plate || typeof plate !== "object") return;
            const px = parseInt(plate.x ?? 0, 10);
            const py = parseInt(plate.y ?? 0, 10);
            if (!Number.isFinite(px) || !Number.isFinite(py)) return;
            const entry = { x: px * scale, y: py * scale };
            const pw = parseInt(plate.w ?? 0, 10);
            const ph = parseInt(plate.h ?? 0, 10);
            if (Number.isFinite(pw) && pw > 0) {
              entry.w = Math.min(
                CANVAS_PLATE_MAX_W,
                Math.max(CANVAS_PLATE_MIN_W, pw * scale),
              );
            }
            if (Number.isFinite(ph) && ph > 0) {
              entry.h = Math.min(
                CANVAS_PLATE_MAX_H,
                Math.max(CANVAS_PLATE_MIN_H, ph * scale),
              );
            }
            if (plate.group && groups[plate.group]) {
              entry.group = plate.group;
            }
            plates[k] = entry;
          });
        }
        Object.keys(fallback.plates).forEach((key) => {
          if (!plates[key]) plates[key] = { ...fallback.plates[key] };
        });
        if (!size) {
          const bounds = computeCanvasContentBounds({ plates, groups });
          size = { w: bounds.w, h: bounds.h };
        }
        return {
          enabled: true,
          grid: 1,
          auto_fit_canvas_to_objects: !!data.auto_fit_canvas_to_objects,
          auto_fit_element_backgrounds: !!data.auto_fit_element_backgrounds,
          size,
          plates,
          groups,
        };
      }

        function ensureCanvasLayoutSize(layout) {
          if (!layout) return;
          const bounds = computeCanvasContentBounds(layout);
          if (!layout.size) {
            layout.size = { w: bounds.w, h: bounds.h };
            return;
          }
          if (!Number.isFinite(layout.size.w)) layout.size.w = bounds.w;
          if (!Number.isFinite(layout.size.h)) layout.size.h = bounds.h;
          if (!layout.auto_fit_canvas_to_objects) return;
          if (layout.size.w < bounds.w) layout.size.w = bounds.w;
          if (layout.size.h < bounds.h) layout.size.h = bounds.h;
        }

        function updateCanvasCardSize(layout) {
          const card = document.getElementById("card");
          if (!card || !layout || !layout.size) return;
          card.style.width = `${layout.size.w}px`;
          card.style.height = `${layout.size.h}px`;
        }

        function updateCanvasGridStyle(layout) {
          const card = document.getElementById("card");
          if (!card) return;
          card.style.setProperty("--canvas-grid", "1px");
        }

        function capturePfpOffsets() {
          const wrap = document.querySelector(".pfp-wrap");
          const img = document.querySelector(".pfp");
          if (!wrap || !img) {
            pfpSizeOffsets = { imgW: 0, imgH: 0 };
            return;
          }
          const wrapRect = wrap.getBoundingClientRect();
          const imgRect = img.getBoundingClientRect();
          pfpSizeOffsets = {
            imgW: Math.round(imgRect.width - wrapRect.width),
            imgH: Math.round(imgRect.height - wrapRect.height),
          };
        }

        function getPlateElement(key) {
          return getSectionElement(key);
        }

        function applyPlateBackgroundFitMode(key, plate) {
          const el = getPlateElement(key);
          if (!el) return;
          const enabled = !!canvasLayout?.auto_fit_element_backgrounds;
          const supported = key === "audio" || key === "visit_counter" || key === "links";
          el.classList.toggle("fit-element-bg", enabled && supported);
          if (!(enabled && supported)) {
            if (key === "links") el.style.removeProperty("align-content");
            return;
          }
          // Keep link object backgrounds aligned to the resized plate surface.
          if (key === "links" && Number.isFinite(plate?.h)) {
            el.style.alignContent = "center";
          }
        }

        function applyPlateStyles(key, plate) {
          const el = getPlateElement(key);
          if (!el || !plate) return;
          el.style.transform = `translate(${plate.x}px, ${plate.y}px)`;
          el.style.margin = "0";
          if (Number.isFinite(plate.w)) {
            const width = plate.w;
            el.style.width = `${width}px`;
            el.style.maxWidth = "none";
            if (key === "pfp") {
              const img = el.querySelector(".pfp");
              if (img && pfpSizeOffsets) {
                img.style.width = `${width + pfpSizeOffsets.imgW}px`;
              }
            }
          }
          if (Number.isFinite(plate.h)) {
            const height = plate.h;
            el.style.height = `${height}px`;
            el.style.maxHeight = "none";
            if (key === "pfp") {
              const img = el.querySelector(".pfp");
              if (img && pfpSizeOffsets) {
                img.style.height = `${height + pfpSizeOffsets.imgH}px`;
              }
            }
          }
          applyPlateBackgroundFitMode(key, plate);
        }

        function updateGroupBounds(groupEl, groupId, layout) {
          if (!groupEl || !layout) return;
          const plates = Object.entries(layout.plates || {}).filter(
            ([, plate]) => plate && plate.group === groupId,
          );
          if (!plates.length) {
            groupEl.style.width = "0px";
            groupEl.style.height = "0px";
            return;
          }
          let maxX = 0;
          let maxY = 0;
          plates.forEach(([key, plate]) => {
            const wUnits = Number.isFinite(plate.w)
              ? plate.w
              : defaultPlatePixels(key).w;
            const hUnits = Number.isFinite(plate.h)
              ? plate.h
              : defaultPlatePixels(key).h;
            const px = plate.x;
            const py = plate.y;
            maxX = Math.max(maxX, px + wUnits);
            maxY = Math.max(maxY, py + hUnits);
          });
          groupEl.style.width = `${maxX}px`;
          groupEl.style.height = `${maxY}px`;
        }

        function attachResizeHandles(el, key) {
          if (!el) return;
          el.querySelectorAll(".resize-handle").forEach((n) => n.remove());
          const handleE = document.createElement("div");
          handleE.className = "resize-handle resize-e";
          handleE.addEventListener("mousedown", (evt) => {
            evt.stopPropagation();
            startCanvasDrag(evt, { type: "resize", key, dir: "e", el });
          });
          const handleS = document.createElement("div");
          handleS.className = "resize-handle resize-s";
          handleS.addEventListener("mousedown", (evt) => {
            evt.stopPropagation();
            startCanvasDrag(evt, { type: "resize", key, dir: "s", el });
          });
          const handleSE = document.createElement("div");
          handleSE.className = "resize-handle resize-se";
          handleSE.addEventListener("mousedown", (evt) => {
            evt.stopPropagation();
            startCanvasDrag(evt, { type: "resize", key, dir: "se", el });
          });
          el.appendChild(handleE);
          el.appendChild(handleS);
          el.appendChild(handleSE);
        }

        function ensurePlateSizesFromDom() {
          if (!canvasLayout) return;
          let changed = false;
          SECTION_ORDER_DEFAULT.forEach((key) => {
            const plate = canvasLayout.plates?.[key];
            const el = getPlateElement(key);
            if (!plate || !el) return;
            if (Number.isFinite(plate.w) && Number.isFinite(plate.h)) return;
            const rect = el.getBoundingClientRect();
            if (!Number.isFinite(plate.w)) {
              const wUnits = Math.round(rect.width);
              plate.w = Math.min(
                CANVAS_PLATE_MAX_W,
                Math.max(CANVAS_PLATE_MIN_W, wUnits || defaultPlatePixels(key).w),
              );
              changed = true;
            }
            if (!Number.isFinite(plate.h)) {
              const hUnits = Math.round(rect.height);
              plate.h = Math.min(
                CANVAS_PLATE_MAX_H,
                Math.max(CANVAS_PLATE_MIN_H, hUnits || defaultPlatePixels(key).h),
              );
              changed = true;
            }
            if (changed) applyPlateStyles(key, plate);
          });
          if (changed) {
            ensureCanvasLayoutSize(canvasLayout);
            updateCanvasCardSize(canvasLayout);
            syncCanvasControls();
          }
        }

        function applyCanvasLayout(
          rawLayout,
          rawOrder,
          { isMobile, forceCanvas = false, forEditor = false, layoutOverride } = {},
        ) {
          const card = document.getElementById("card");
          if (!card) return false;
          const layout = layoutOverride || normalizeCanvasLayout(rawLayout, rawOrder);
          if (!layout) return false;
          resetCanvasLayout(card);
          card.classList.add("canvas");
          card.style.maxWidth = "none";
          if (!pfpSizeOffsets) capturePfpOffsets();
          const groupEls = {};
          Object.entries(layout.groups || {}).forEach(([gid, g]) => {
            const groupEl = document.createElement("div");
            groupEl.className = "plate-group";
            groupEl.dataset.groupId = gid;
            groupEl.style.transform = `translate(${g.x}px, ${g.y}px)`;
            if (forEditor) {
              const handle = document.createElement("div");
              handle.className = "group-handle";
              handle.textContent = "Group";
              handle.onmousedown = (evt) =>
                startCanvasDrag(evt, { type: "group", id: gid, el: groupEl });
              handle.onclick = (evt) => {
                evt.stopPropagation();
                setCanvasSelection({ type: "group", id: gid });
              };
              groupEl.appendChild(handle);
            }
            card.appendChild(groupEl);
            groupEls[gid] = groupEl;
          });

          SECTION_ORDER_DEFAULT.forEach((key) => {
            const el = getSectionElement(key);
            if (!el) return;
            const plate = layout.plates[key];
            if (!plate) return;
            const parent = plate.group ? groupEls[plate.group] : card;
            if (!parent) return;
            el.classList.add("canvas-plate");
            el.style.position = "absolute";
            el.style.left = "0";
            el.style.top = "0";
            el.style.transform = `translate(${plate.x}px, ${plate.y}px)`;
            el.style.margin = "0";
            if (Number.isFinite(plate.w)) {
              const width = plate.w;
              el.style.width = `${width}px`;
              el.style.maxWidth = "none";
              if (key === "pfp") {
                const img = el.querySelector(".pfp");
                if (img && pfpSizeOffsets) {
                  img.style.width = `${width + pfpSizeOffsets.imgW}px`;
                }
              }
            }
            if (Number.isFinite(plate.h)) {
              const height = plate.h;
              el.style.height = `${height}px`;
              el.style.maxHeight = "none";
              if (key === "pfp") {
                const img = el.querySelector(".pfp");
                if (img && pfpSizeOffsets) {
                  img.style.height = `${height + pfpSizeOffsets.imgH}px`;
                }
              }
            }
            applyPlateBackgroundFitMode(key, plate);
            if (forEditor) {
              el.dataset.key = key;
              el.onmousedown = (evt) =>
                startCanvasDrag(evt, { type: "plate", key, el });
              el.onclick = (evt) => {
                evt.stopPropagation();
                setCanvasSelection({ type: "plate", key });
              };
              attachResizeHandles(el, key);
            }
            parent.appendChild(el);
          });

          if (layout.size && Number.isFinite(layout.size.w) && Number.isFinite(layout.size.h)) {
            card.style.width = `${layout.size.w}px`;
            card.style.height = `${layout.size.h}px`;
            card.style.minHeight = "";
          } else {
            const cardRect = card.getBoundingClientRect();
            let maxBottom = 0;
            let maxRight = 0;
            SECTION_ORDER_DEFAULT.forEach((key) => {
              const el = getSectionElement(key);
              if (!el) return;
              const rect = el.getBoundingClientRect();
              maxBottom = Math.max(maxBottom, rect.bottom - cardRect.top);
              maxRight = Math.max(maxRight, rect.right - cardRect.left);
            });
            if (maxBottom > 0) {
              card.style.minHeight = `${Math.ceil(maxBottom + 24)}px`;
            }
            if (maxRight > 0) {
              card.style.minWidth = "";
            }
          }
          Object.entries(groupEls).forEach(([gid, groupEl]) => {
            updateGroupBounds(groupEl, gid, layout);
          });
          if (forEditor) {
            card.querySelectorAll(".canvas-resize-handle").forEach((n) => n.remove());
            const resizeHandle = document.createElement("div");
            resizeHandle.className = "canvas-resize-handle";
            resizeHandle.onmousedown = (evt) => {
              evt.stopPropagation();
              startCanvasDrag(evt, { type: "canvas-resize", el: card });
            };
            card.appendChild(resizeHandle);
          }
          return true;
        }

        function clearCanvasSelection() {
          canvasSelection = null;
          document
            .querySelectorAll(".canvas-plate.selected, .plate-group.selected")
            .forEach((el) => el.classList.remove("selected"));
          syncSelectionPanel();
        }

        function setCanvasSelection(target) {
          canvasSelection = target;
          document
            .querySelectorAll(".canvas-plate.selected, .plate-group.selected")
            .forEach((el) => el.classList.remove("selected"));
          if (target && target.type === "plate") {
            const el = getPlateElement(target.key);
            if (el) el.classList.add("selected");
          }
          if (target && target.type === "group") {
            const el = document.querySelector(
              `.plate-group[data-group-id="${target.id}"]`,
            );
            if (el) el.classList.add("selected");
          }
          syncSelectionPanel();
        }

        function getGroupOffset(groupId) {
          if (!canvasLayout || !groupId) return { x: 0, y: 0 };
          const group = canvasLayout.groups?.[groupId];
          return {
            x: Number.isFinite(group?.x) ? group.x : 0,
            y: Number.isFinite(group?.y) ? group.y : 0,
          };
        }

        function ensureGroupEntry(groupId, initial = null) {
          if (!canvasLayout || !groupId) return null;
          canvasLayout.groups = canvasLayout.groups || {};
          if (!canvasLayout.groups[groupId]) {
            const x = Number.isFinite(initial?.x) ? initial.x : 0;
            const y = Number.isFinite(initial?.y) ? initial.y : 0;
            canvasLayout.groups[groupId] = { x, y };
          }
          return canvasLayout.groups[groupId];
        }

        function ensureGroupElement(groupId) {
          if (!groupId) return null;
          let groupEl = document.querySelector(
            `.plate-group[data-group-id="${groupId}"]`,
          );
          if (groupEl) return groupEl;
          const card = document.getElementById("card");
          if (!card) return null;
          const group = ensureGroupEntry(groupId);
          if (!group) return null;
          groupEl = document.createElement("div");
          groupEl.className = "plate-group";
          groupEl.dataset.groupId = groupId;
          groupEl.style.transform = `translate(${group.x}px, ${group.y}px)`;
          if (EDITOR_MODE) {
            const handle = document.createElement("div");
            handle.className = "group-handle";
            handle.textContent = "Group";
            handle.onmousedown = (evt) =>
              startCanvasDrag(evt, { type: "group", id: groupId, el: groupEl });
            handle.onclick = (evt) => {
              evt.stopPropagation();
              setCanvasSelection({ type: "group", id: groupId });
            };
            groupEl.appendChild(handle);
          }
          card.appendChild(groupEl);
          return groupEl;
        }

        function refreshGroupOptions() {
          const list = document.getElementById("selGroupOptions");
          if (!list) return;
          list.textContent = "";
          if (!canvasLayout || !canvasLayout.groups) return;
          Object.keys(canvasLayout.groups)
            .sort()
            .forEach((gid) => {
              const opt = document.createElement("option");
              opt.value = gid;
              list.appendChild(opt);
            });
        }

        function renameCanvasGroup(oldId, newId) {
          if (!canvasLayout || !oldId || !newId) return false;
          if (oldId === newId) return true;
          if (canvasLayout.groups?.[newId]) {
            showEditorMessage("Group ID already exists.", false);
            return false;
          }
          const group = canvasLayout.groups?.[oldId];
          if (!group) return false;
          canvasLayout.groups[newId] = group;
          delete canvasLayout.groups[oldId];
          Object.values(canvasLayout.plates || {}).forEach((plate) => {
            if (plate && plate.group === oldId) plate.group = newId;
          });
          const groupEl = document.querySelector(
            `.plate-group[data-group-id="${oldId}"]`,
          );
          if (groupEl) groupEl.dataset.groupId = newId;
          if (canvasSelection?.type === "group" && canvasSelection.id === oldId) {
            canvasSelection.id = newId;
          }
          refreshGroupOptions();
          return true;
        }

        function assignPlateToGroup(key, nextGroupIdRaw) {
          if (!canvasLayout) return;
          const plate = canvasLayout.plates?.[key];
          if (!plate) return;
          const nextGroupId = (nextGroupIdRaw || "").trim();
          const oldGroupId = plate.group || "";
          if (nextGroupId === oldGroupId) return;
          const oldOffset = getGroupOffset(oldGroupId);
          const absX = plate.x + oldOffset.x;
          const absY = plate.y + oldOffset.y;
          if (!nextGroupId) {
            plate.group = null;
            plate.x = absX;
            plate.y = absY;
          } else {
            const isNew = !canvasLayout.groups?.[nextGroupId];
            if (isNew) {
              ensureGroupEntry(nextGroupId, { x: absX, y: absY });
              plate.x = 0;
              plate.y = 0;
            } else {
              const nextOffset = getGroupOffset(nextGroupId);
              plate.x = absX - nextOffset.x;
              plate.y = absY - nextOffset.y;
            }
            plate.group = nextGroupId;
          }
          const plateEl = getPlateElement(key);
          const card = document.getElementById("card");
          const nextParent = nextGroupId
            ? ensureGroupElement(nextGroupId)
            : card;
          if (plateEl && nextParent && plateEl.parentElement !== nextParent) {
            nextParent.appendChild(plateEl);
          }
          applyPlateStyles(key, plate);
          if (oldGroupId) {
            const oldGroupEl = document.querySelector(
              `.plate-group[data-group-id="${oldGroupId}"]`,
            );
            updateGroupBounds(oldGroupEl, oldGroupId, canvasLayout);
          }
          if (nextGroupId) {
            const nextGroupEl = document.querySelector(
              `.plate-group[data-group-id="${nextGroupId}"]`,
            );
            updateGroupBounds(nextGroupEl, nextGroupId, canvasLayout);
          }
          canvasDirty = true;
          ensureCanvasLayoutSize(canvasLayout);
          updateCanvasCardSize(canvasLayout);
          syncCanvasControls();
          syncSelectionPanel();
        }

        function syncCanvasControls() {
          const canvasW = document.getElementById("inCanvasW");
          const canvasH = document.getElementById("inCanvasH");
          const autoFit = document.getElementById("inCanvasAutoFitObjects");
          const autoFitElementBgs = document.getElementById(
            "inCanvasAutoFitElementBackgrounds",
          );
          if (!canvasLayout) return;
          ensureCanvasLayoutSize(canvasLayout);
          if (canvasW && canvasLayout.size) canvasW.value = canvasLayout.size.w;
          if (canvasH && canvasLayout.size) canvasH.value = canvasLayout.size.h;
          if (autoFit) autoFit.checked = !!canvasLayout.auto_fit_canvas_to_objects;
          if (autoFitElementBgs) {
            autoFitElementBgs.checked = !!canvasLayout.auto_fit_element_backgrounds;
          }
        }

        function syncSelectionPanel() {
          const canvasSizePanel = document.getElementById("canvasSizePanel");
          const label = document.getElementById("selectionLabel");
          const xInput = document.getElementById("inSelX");
          const yInput = document.getElementById("inSelY");
          const wInput = document.getElementById("inSelW");
          const hInput = document.getElementById("inSelH");
          const groupRow = document.getElementById("selectionGroupRow");
          const groupInput = document.getElementById("inSelGroup");
          const groupLabel = document.getElementById("selectionGroupLabel");
          const attrEmpty = document.getElementById("selectionAttrEmpty");
          const panels = {
            pfp: document.getElementById("selectionAttrPfp"),
            name: document.getElementById("selectionAttrName"),
            discord_status: document.getElementById("selectionAttrDiscordStatus"),
            quote: document.getElementById("selectionAttrQuote"),
            location: document.getElementById("selectionAttrLocation"),
            badges: document.getElementById("selectionAttrBadges"),
            audio: document.getElementById("selectionAttrAudio"),
            links: document.getElementById("selectionAttrLinks"),
            visit_counter: document.getElementById("selectionAttrCounter"),
          };
          if (
            !label ||
            !xInput ||
            !yInput ||
            !wInput ||
            !hInput ||
            !groupInput ||
            !groupLabel ||
            !attrEmpty
          )
            return;
          if (canvasSizePanel) canvasSizePanel.hidden = !!canvasSelection;
          if (groupRow) groupRow.hidden = !canvasSelection;
          refreshGroupOptions();
          Object.values(panels).forEach((panel) => {
            if (panel) panel.hidden = true;
          });
          attrEmpty.hidden = false;
          xInput.disabled = true;
          yInput.disabled = true;
          wInput.disabled = true;
          hInput.disabled = true;
          groupInput.disabled = true;
          if (!canvasLayout || !canvasSelection) {
            label.textContent = "Select an element on the canvas.";
            xInput.value = "";
            yInput.value = "";
            wInput.value = "";
            hInput.value = "";
            groupInput.value = "";
            attrEmpty.textContent = "Select an element to edit its attributes.";
            return;
          }
          if (canvasSelection.type === "group") {
            const group = canvasLayout.groups?.[canvasSelection.id];
            if (!group) return;
            label.textContent = `Group ${canvasSelection.id}`;
            xInput.value = group.x;
            yInput.value = group.y;
            wInput.value = "";
            hInput.value = "";
            xInput.disabled = false;
            yInput.disabled = false;
            wInput.disabled = true;
            hInput.disabled = true;
            groupLabel.textContent = "Group ID";
            groupInput.value = canvasSelection.id;
            groupInput.disabled = false;
            attrEmpty.textContent = "Groups do not have editable attributes.";
            return;
          }
          const key = canvasSelection.key;
          const plate = canvasLayout.plates?.[key];
          if (!plate) return;
          label.textContent = SECTION_LABELS[key] || key;
          xInput.value = plate.x;
          yInput.value = plate.y;
          wInput.value = Number.isFinite(plate.w)
            ? plate.w
            : defaultPlatePixels(key).w;
          hInput.value = Number.isFinite(plate.h)
            ? plate.h
            : defaultPlatePixels(key).h;
          xInput.disabled = false;
          yInput.disabled = false;
          wInput.disabled = false;
          hInput.disabled = false;
          groupLabel.textContent = "Group ID";
          groupInput.value = plate.group || "";
          groupInput.disabled = false;
          const panelKey = SECTION_KEY_ALIASES[key] || key;
          const activePanel = panels[panelKey];
          if (!activePanel) {
            attrEmpty.textContent = "No editable attributes for this element yet.";
            return;
          }
          if (!lastData) {
            attrEmpty.textContent = "No data loaded.";
            return;
          }
          activePanel.hidden = false;
          attrEmpty.hidden = true;
          if (panelKey === "pfp") {
            const pfpInput = document.getElementById("inAttrLinktreePfp");
            if (pfpInput)
              pfpInput.value = lastData.linktree_profile_picture || "";
            setUploadStatus(
              "attrPfpStatus",
              lastData.linktree_profile_picture,
              "Using your account profile picture.",
            );
            const frameToggle = document.getElementById("inAttrDiscordFrame");
            const presenceToggle = document.getElementById("inAttrDiscordPresence");
            if (frameToggle)
              frameToggle.checked = !!lastData.discord_frame_enabled;
            if (presenceToggle)
              presenceToggle.checked = !!lastData.discord_presence_enabled;
            updateAttrDiscordUI(lastData);
            return;
          }
          if (panelKey === "name") {
            const nameColorInput = document.getElementById("inAttrNameColor");
            const nameEffectInput = document.getElementById("inAttrNameEffect");
            const nameFontInput = document.getElementById("inAttrNameFont");
            const displayNameInput = document.getElementById("inAttrDisplayName");
            const customNameInput = document.getElementById("inAttrCustomName");
            if (displayNameInput)
              displayNameInput.value = lastData.display_name_mode || "slug";
            if (customNameInput) {
              customNameInput.value = lastData.custom_display_name || "";
              customNameInput.disabled =
                (displayNameInput?.value || "slug") !== "custom";
            }
            if (nameColorInput) {
              nameColorInput.value =
                sanitizeHexColor(lastData.name_color) ||
                sanitizeHexColor(lastData.link_color) ||
                DEFAULT_NAME_COLOR;
            }
            if (nameEffectInput)
              nameEffectInput.value = normalizeEffectName(lastData.name_effect);
            if (nameFontInput)
              nameFontInput.value = normalizeFontFamily(
                lastData.name_font_family,
              );
            return;
          }
          if (panelKey === "discord_status") {
            const statusToggle = document.getElementById("inAttrDiscordStatus");
            if (statusToggle)
              statusToggle.checked = !!lastData.discord_status_enabled;
            updateAttrDiscordUI(lastData);
            return;
          }
          if (panelKey === "quote") {
            const quoteInput = document.getElementById("inAttrQuote");
            const alt1 = document.getElementById("inAttrQuoteAlt1");
            const alt2 = document.getElementById("inAttrQuoteAlt2");
            const typingToggle = document.getElementById("inAttrQuoteTyping");
            const speedInput = document.getElementById("inAttrQuoteSpeed");
            const pauseInput = document.getElementById("inAttrQuotePause");
            const quoteColorInput = document.getElementById("inAttrQuoteColor");
            const quoteEffectInput = document.getElementById("inAttrQuoteEffect");
            const quoteFontInput = document.getElementById("inAttrQuoteFont");
            const quoteSizeInput = document.getElementById("inAttrQuoteSize");
            const quoteStrengthInput = document.getElementById(
              "inAttrQuoteEffectStrength",
            );
            const texts = Array.isArray(lastData.quote_typing_texts)
              ? lastData.quote_typing_texts
              : [];
            const baseText = texts[0] || lastData.quote || "";
            if (quoteInput) quoteInput.value = baseText;
            if (alt1) alt1.value = texts[1] || "";
            if (alt2) alt2.value = texts[2] || "";
            if (typingToggle)
              typingToggle.checked = !!lastData.quote_typing_enabled;
            if (speedInput)
              speedInput.value = Number.isFinite(Number(lastData.quote_typing_speed))
                ? lastData.quote_typing_speed
                : 42;
            if (pauseInput)
              pauseInput.value = Number.isFinite(Number(lastData.quote_typing_pause))
                ? lastData.quote_typing_pause
                : 1200;
            if (quoteColorInput)
              quoteColorInput.value =
                sanitizeHexColor(lastData.quote_color) ||
                sanitizeHexColor(lastData.text_color) ||
                DEFAULT_QUOTE_COLOR;
            if (quoteEffectInput)
              quoteEffectInput.value = normalizeEffectName(lastData.quote_effect);
            if (quoteFontInput)
              quoteFontInput.value = normalizeFontFamily(
                lastData.quote_font_family,
              );
            if (quoteSizeInput)
              quoteSizeInput.value = Number.isFinite(Number(lastData.quote_font_size))
                ? lastData.quote_font_size
                : 15;
            if (quoteStrengthInput)
              quoteStrengthInput.value = Number.isFinite(
                Number(lastData.quote_effect_strength),
              )
                ? lastData.quote_effect_strength
                : 70;
            toggleAttrQuoteTypingFields();
            return;
          }
          if (panelKey === "location") {
            const locInput = document.getElementById("inAttrLocation");
            const locColorInput = document.getElementById("inAttrLocationColor");
            if (locInput) locInput.value = lastData.location || "";
            if (locColorInput)
              locColorInput.value =
                sanitizeHexColor(lastData.location_color) ||
                sanitizeHexColor(lastData.text_color) ||
                DEFAULT_LOCATION_COLOR;
            return;
          }
          if (panelKey === "badges") {
            const discordBadgesToggle = document.getElementById(
              "inAttrDiscordBadges",
            );
            if (discordBadgesToggle)
              discordBadgesToggle.checked = !!lastData.discord_badges_enabled;
            if (Array.isArray(lastData.discord_badge_codes)) {
              discordBadgeCodes = lastData.discord_badge_codes.slice();
            } else if (!Array.isArray(discordBadgeCodes)) {
              const list = Array.isArray(lastData.discord_badges)
                ? lastData.discord_badges
                : [];
              discordBadgeCodes = list
                .map((b) => b && b.code)
                .filter(Boolean);
            }
            updateAttrDiscordUI(lastData);
            renderAttrDiscordBadges();
            renderAttrBadges();
            return;
          }
          if (panelKey === "audio") {
            const songInput = document.getElementById("inAttrSong");
            const songNameInput = document.getElementById("inAttrSongName");
            const songIconInput = document.getElementById("inAttrSongIcon");
            const audioToggle = document.getElementById("inAttrAudioPlayer");
            const audioBg = document.getElementById("inAttrAudioBgColor");
            const audioAlpha = document.getElementById("inAttrAudioBgAlpha");
            const audioText = document.getElementById("inAttrAudioTextColor");
            const audioAccent = document.getElementById("inAttrAudioAccentColor");
            if (songInput) songInput.value = lastData.song_url || "";
            if (songNameInput) songNameInput.value = lastData.song_name || "";
            if (songIconInput)
              songIconInput.value = lastData.song_icon_url || "";
            setUploadStatus(
              "attrSongStatus",
              lastData.song_url,
              "No song uploaded yet.",
              lastData.song_name || "",
            );
            setUploadStatus(
              "attrSongIconStatus",
              lastData.song_icon_url,
              "No icon uploaded.",
            );
            if (audioToggle)
              audioToggle.checked = !!lastData.show_audio_player;
            if (audioBg)
              audioBg.value =
                sanitizeHexColor(lastData.audio_player_bg_color) ||
                DEFAULT_AUDIO_BG_COLOR;
            if (audioAlpha)
              audioAlpha.value = Number.isFinite(
                Number(lastData.audio_player_bg_alpha),
              )
                ? lastData.audio_player_bg_alpha
                : DEFAULT_AUDIO_BG_ALPHA;
            if (audioText)
              audioText.value =
                sanitizeHexColor(lastData.audio_player_text_color) ||
                sanitizeHexColor(lastData.text_color) ||
                DEFAULT_AUDIO_TEXT_COLOR;
            if (audioAccent)
              audioAccent.value =
                sanitizeHexColor(lastData.audio_player_accent_color) ||
                sanitizeHexColor(lastData.link_color) ||
                DEFAULT_AUDIO_ACCENT_COLOR;
            return;
          }
          if (panelKey === "links") {
            const linkColor = document.getElementById("inAttrLinkColor");
            const linkBg = document.getElementById("inAttrLinkBgColor");
            const linkAlpha = document.getElementById("inAttrLinkBgAlpha");
            const linkColumns = document.getElementById("inAttrLinkColumns");
            const linkIconsOnly = document.getElementById(
              "inAttrLinkIconsOnly",
            );
            const linkIconsOnlySize = document.getElementById(
              "inAttrLinkIconsOnlySize",
            );
            const linkIconsOnlyGap = document.getElementById(
              "inAttrLinkIconsOnlyGap",
            );
            const linkIconsOnlyGrouped = document.getElementById(
              "inAttrLinkIconsOnlyGrouped",
            );
            const linkIconsOnlyDirection = document.getElementById(
              "inAttrLinkIconsOnlyDirection",
            );
            const iconInput = document.getElementById("inAttrLinkIcon");
            if (linkColor)
              linkColor.value =
                sanitizeHexColor(lastData.link_color) || DEFAULT_LINK_COLOR;
            if (linkBg)
              linkBg.value =
                sanitizeHexColor(lastData.link_bg_color) || DEFAULT_LINK_BG;
            if (linkAlpha)
              linkAlpha.value = clampPercent(lastData.link_bg_alpha ?? 100, 100);
            if (linkColumns)
              linkColumns.value =
                lastData.link_columns !== undefined && lastData.link_columns !== null
                  ? lastData.link_columns
                  : "";
            if (linkIconsOnly)
              linkIconsOnly.checked = !!lastData.link_icons_only;
            if (linkIconsOnlySize)
              linkIconsOnlySize.value = normalizeLinkIconsOnlySize(
                lastData.link_icons_only_size,
              );
            if (linkIconsOnlyGap)
              linkIconsOnlyGap.value = normalizeLinkIconsOnlyGap(
                lastData.link_icons_only_gap,
              );
            if (linkIconsOnlyGrouped)
              linkIconsOnlyGrouped.value = lastData.link_icons_only_grouped
                ? "grouped"
                : "separate";
            if (linkIconsOnlyDirection)
              linkIconsOnlyDirection.value = normalizeLinkIconsOnlyDirection(
                lastData.link_icons_only_direction,
              );
            if (iconInput) {
              iconInput.value = iconInput.value || "";
            }
            setUploadStatus("attrLinkIconStatus", iconInput?.value, "No icon uploaded.");
            renderAttrLinks(lastData.links || []);
            return;
          }
          if (panelKey === "visit_counter") {
            const showToggle = document.getElementById("inAttrShowCounter");
            const countEl = document.getElementById("attrVisitCount");
            const colorInput = document.getElementById("inAttrCounterColor");
            const bgInput = document.getElementById("inAttrCounterBgColor");
            const alphaInput = document.getElementById("inAttrCounterBgAlpha");
            if (showToggle)
              showToggle.checked = !!lastData.show_visit_counter;
            if (countEl)
              countEl.textContent = Number(lastData.visit_count || 0).toLocaleString();
            if (colorInput)
              colorInput.value =
                sanitizeHexColor(lastData.visit_counter_color) ||
                sanitizeHexColor(lastData.text_color) ||
                DEFAULT_TEXT_COLOR;
            if (bgInput)
              bgInput.value =
                sanitizeHexColor(lastData.visit_counter_bg_color) || "#ffffff";
            if (alphaInput)
              alphaInput.value = clampPercent(
                lastData.visit_counter_bg_alpha ?? 20,
                20,
              );
            return;
          }
        }

        function bindCanvasStageEvents() {
          const card = document.getElementById("card");
          if (!card || canvasStageBound) return;
          card.addEventListener("click", (evt) => {
            if (evt.target === card) {
              clearCanvasSelection();
            }
          });
          canvasStageBound = true;
        }

        function startCanvasDrag(evt, target) {
          if (!canvasLayout || evt.button !== 0) return;
          evt.preventDefault();
          if (target.type === "plate") {
            const plate = canvasLayout.plates[target.key];
            if (!plate) return;
            canvasDragState = {
              type: "plate",
              key: target.key,
              el: target.el,
              startX: evt.clientX,
              startY: evt.clientY,
              originX: plate.x,
              originY: plate.y,
            };
          } else if (target.type === "resize") {
            const plate = canvasLayout.plates[target.key];
            if (!plate) return;
            const fallback = defaultPlatePixels(target.key);
            canvasDragState = {
              type: "resize",
              key: target.key,
              dir: target.dir,
              el: target.el,
              startX: evt.clientX,
              startY: evt.clientY,
              originW: Number.isFinite(plate.w) ? plate.w : fallback.w,
              originH: Number.isFinite(plate.h) ? plate.h : fallback.h,
            };
          } else if (target.type === "group") {
            const group = canvasLayout.groups[target.id];
            if (!group) return;
            canvasDragState = {
              type: "group",
              id: target.id,
              el: target.el,
              startX: evt.clientX,
              startY: evt.clientY,
              originX: group.x,
              originY: group.y,
            };
          } else if (target.type === "canvas-resize") {
            ensureCanvasLayoutSize(canvasLayout);
            const size = canvasLayout.size || {
              w: CANVAS_SIZE_MIN_W,
              h: CANVAS_SIZE_MIN_H,
            };
            canvasDragState = {
              type: "canvas-resize",
              el: target.el,
              startX: evt.clientX,
              startY: evt.clientY,
              originW: size.w,
              originH: size.h,
            };
          }
          document.addEventListener("mousemove", onCanvasDrag);
          document.addEventListener("mouseup", stopCanvasDrag);
        }

        function onCanvasDrag(evt) {
          if (!canvasLayout || !canvasDragState) return;
          const dx = Math.round(evt.clientX - canvasDragState.startX);
          const dy = Math.round(evt.clientY - canvasDragState.startY);
          if (canvasDragState.type === "plate") {
            const plate = canvasLayout.plates[canvasDragState.key];
            if (!plate) return;
            plate.x = canvasDragState.originX + dx;
            plate.y = canvasDragState.originY + dy;
            if (plate.group) {
              plate.x = Math.max(0, plate.x);
              plate.y = Math.max(0, plate.y);
            }
            applyPlateStyles(canvasDragState.key, plate);
            if (plate.group) {
              const groupEl = document.querySelector(
                `.plate-group[data-group-id="${plate.group}"]`,
              );
              updateGroupBounds(groupEl, plate.group, canvasLayout);
            }
          } else if (canvasDragState.type === "resize") {
            const plate = canvasLayout.plates[canvasDragState.key];
            if (!plate) return;
            let nextW = canvasDragState.originW;
            let nextH = canvasDragState.originH;
            if (canvasDragState.dir.includes("e")) {
              nextW = canvasDragState.originW + dx;
            }
            if (canvasDragState.dir.includes("s")) {
              nextH = canvasDragState.originH + dy;
            }
            nextW = Math.min(
              CANVAS_PLATE_MAX_W,
              Math.max(CANVAS_PLATE_MIN_W, nextW),
            );
            nextH = Math.min(
              CANVAS_PLATE_MAX_H,
              Math.max(CANVAS_PLATE_MIN_H, nextH),
            );
            plate.w = nextW;
            plate.h = nextH;
            applyPlateStyles(canvasDragState.key, plate);
            if (plate.group) {
              const groupEl = document.querySelector(
                `.plate-group[data-group-id="${plate.group}"]`,
              );
              updateGroupBounds(groupEl, plate.group, canvasLayout);
            }
          } else if (canvasDragState.type === "group") {
            const group = canvasLayout.groups[canvasDragState.id];
            if (!group) return;
            group.x = canvasDragState.originX + dx;
            group.y = canvasDragState.originY + dy;
            canvasDragState.el.style.transform = `translate(${group.x}px, ${group.y}px)`;
          } else if (canvasDragState.type === "canvas-resize") {
            const bounds = computeCanvasContentBounds(canvasLayout);
            let nextW = canvasDragState.originW + dx;
            let nextH = canvasDragState.originH + dy;
            nextW = Math.max(CANVAS_SIZE_MIN_W, Math.max(bounds.w, nextW));
            nextH = Math.max(CANVAS_SIZE_MIN_H, Math.max(bounds.h, nextH));
            canvasLayout.size = {
              w: Math.min(CANVAS_PLATE_MAX_W, nextW),
              h: Math.min(CANVAS_PLATE_MAX_H, nextH),
            };
          }
          canvasDirty = true;
          ensureCanvasLayoutSize(canvasLayout);
          updateCanvasCardSize(canvasLayout);
          syncCanvasControls();
          syncSelectionPanel();
        }

        function stopCanvasDrag() {
          canvasDragState = null;
          document.removeEventListener("mousemove", onCanvasDrag);
          document.removeEventListener("mouseup", stopCanvasDrag);
        }

        function applySectionOrder(rawOrder) {
          const card = document.getElementById("card");
          if (!card) return false;
          resetCanvasLayout(card);
          const order = normalizeSectionOrder(rawOrder);
          let hasSideBySide = false;
          order.forEach((entry) => {
            if (Array.isArray(entry)) {
              const row = document.createElement("div");
              row.className = "section-row";
              entry.forEach((key) => {
                const el = getSectionElement(key);
                if (el) row.appendChild(el);
              });
              if (row.children.length > 1) {
                hasSideBySide = true;
                card.appendChild(row);
              } else if (row.children.length === 1) {
                card.appendChild(row.firstElementChild);
              }
            } else {
              const el = getSectionElement(entry);
              if (el) card.appendChild(el);
            }
          });
          return hasSideBySide;
        }

        function applySectionLayout(rawOrder, rawCanvas, { isMobile } = {}) {
          const usedCanvas = applyCanvasLayout(rawCanvas, rawOrder, {
            isMobile,
            forceCanvas: false,
            forEditor: EDITOR_MODE,
            layoutOverride: EDITOR_MODE ? canvasLayout : null,
          });
          if (usedCanvas) {
            return { usedCanvas: true, hasSideBySide: false };
          }
          const hasSideBySide = applySectionOrder(rawOrder);
          return { usedCanvas: false, hasSideBySide };
        }

        function sanitizeHexColor(raw) {
          if (typeof raw !== "string") return "";
          const trimmed = raw.trim();
          return /^#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(trimmed)
            ? trimmed
            : "";
        }

        function normalizeLinkColumns(raw, fallback) {
          if (raw === undefined || raw === null || raw === "") return fallback;
          const n = parseInt(raw, 10);
          if (Number.isNaN(n)) return fallback;
          return Math.min(LINK_COLUMNS_MAX, Math.max(LINK_COLUMNS_MIN, n));
        }

        function normalizeLinkIconsOnlySize(raw, fallback = LINK_ICONS_ONLY_SIZE_DEFAULT) {
          const n = parseInt(raw, 10);
          if (Number.isNaN(n)) return fallback;
          return Math.min(LINK_ICONS_ONLY_SIZE_MAX, Math.max(LINK_ICONS_ONLY_SIZE_MIN, n));
        }

        function normalizeLinkIconsOnlyGap(raw, fallback = LINK_ICONS_ONLY_GAP_DEFAULT) {
          const n = parseInt(raw, 10);
          if (Number.isNaN(n)) return fallback;
          return Math.min(LINK_ICONS_ONLY_GAP_MAX, Math.max(LINK_ICONS_ONLY_GAP_MIN, n));
        }

        function normalizeLinkIconsOnlyDirection(raw) {
          return String(raw || "row").toLowerCase() === "column" ? "column" : "row";
        }

        function clampPercent(val, fallback = 0) {
          const n = parseInt(val ?? fallback, 10);
          if (Number.isNaN(n)) return Math.min(100, Math.max(0, fallback));
          return Math.min(100, Math.max(0, n));
        }

        function hexToRgb(hex) {
          const clean = sanitizeHexColor(hex);
          if (!clean) return null;
          const raw = clean.slice(1);
          const parts =
            raw.length === 3
              ? raw.split("").map((ch) => ch + ch)
              : [raw.slice(0, 2), raw.slice(2, 4), raw.slice(4, 6)];
          const [r, g, b] = parts.map((p) => parseInt(p, 16));
          return { r, g, b };
        }

        function rgbToRgba(rgb, alpha = 1) {
          if (!rgb) return "";
          const a = Math.min(1, Math.max(0, alpha));
          return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})`;
        }

        function lightenRgb(rgb, amount = 0.08) {
          const t = Math.min(1, Math.max(0, amount));
          return {
            r: Math.round(rgb.r + (255 - rgb.r) * t),
            g: Math.round(rgb.g + (255 - rgb.g) * t),
            b: Math.round(rgb.b + (255 - rgb.b) * t),
          };
        }

        function applyLinkStyles(linkColorRaw, linkBgRaw, linkBgAlphaRaw) {
          const rootStyle = document.documentElement.style;
          const linksEl = document.getElementById("links");
          const linkColor =
            sanitizeHexColor(linkColorRaw) || DEFAULT_LINK_COLOR;
          const bgHex = sanitizeHexColor(linkBgRaw) || DEFAULT_LINK_BG;
          const bgRgb = hexToRgb(bgHex) || hexToRgb(DEFAULT_LINK_BG);
          const alpha =
            Math.min(100, Math.max(0, Number(linkBgAlphaRaw ?? 100))) / 100;
          const base = rgbToRgba(bgRgb, alpha);
          const hover = rgbToRgba(lightenRgb(bgRgb, 0.07), alpha);
          rootStyle.setProperty("--link-color", linkColor);
          rootStyle.setProperty("--link-bg", base || DEFAULT_LINK_BG);
          rootStyle.setProperty(
            "--link-bg-hover",
            hover || base || DEFAULT_LINK_BG,
          );
          if (linksEl) {
            linksEl.classList.toggle("link-bg-alpha-zero", alpha <= 0.001);
          }
        }

        function applyLinkLayout(data, { isMobile, wantsWide } = {}) {
          const linksEl = document.getElementById("links");
          if (!linksEl) return;
          const defaultCols = !isMobile && wantsWide ? 2 : 1;
          const cols = normalizeLinkColumns(data?.link_columns, defaultCols);
          if (Number.isFinite(cols)) {
            linksEl.style.setProperty("--link-cols", String(cols));
          } else {
            linksEl.style.removeProperty("--link-cols");
          }
          const iconsOnly = !!data?.link_icons_only;
          linksEl.classList.toggle("icons-only", iconsOnly);
          linksEl.style.setProperty(
            "--link-icons-only-size",
            `${normalizeLinkIconsOnlySize(data?.link_icons_only_size)}px`,
          );
          linksEl.style.setProperty(
            "--link-icons-only-gap",
            `${normalizeLinkIconsOnlyGap(data?.link_icons_only_gap)}px`,
          );
          const direction = normalizeLinkIconsOnlyDirection(
            data?.link_icons_only_direction,
          );
          linksEl.classList.toggle(
            "icons-grouped",
            iconsOnly && !!data?.link_icons_only_grouped,
          );
          linksEl.classList.toggle("dir-row", iconsOnly && direction === "row");
          linksEl.classList.toggle(
            "dir-column",
            iconsOnly && direction === "column",
          );
        }

        function applyTextColors(data) {
          const rootStyle = document.documentElement.style;
          const base = sanitizeHexColor(data?.text_color) || DEFAULT_TEXT_COLOR;
          const location =
            sanitizeHexColor(data?.location_color) ||
            sanitizeHexColor(data?.text_color) ||
            DEFAULT_LOCATION_COLOR;
          const name =
            sanitizeHexColor(data?.name_color) ||
            sanitizeHexColor(data?.link_color) ||
            DEFAULT_NAME_COLOR;
          const quote =
            sanitizeHexColor(data?.quote_color) || base || DEFAULT_QUOTE_COLOR;

          rootStyle.setProperty("--ink", base);
          rootStyle.setProperty("--muted", location);
          rootStyle.setProperty("--name-color", name);
          rootStyle.setProperty("--location-color", location);
          rootStyle.setProperty("--quote-color", quote);
        }

        function applyQuoteEffectStrength(data) {
          const rootStyle = document.documentElement.style;
          const raw = Number(data?.quote_effect_strength);
          const strength = Number.isFinite(raw)
            ? Math.min(100, Math.max(0, raw))
            : 70;
          const scale = strength / 70;
          const clampPx = (val) => Math.max(0, Math.round(val));
          const glow = [8, 12, 18].map((v) => clampPx(v * scale));
          const neon = [6, 14, 24].map((v) => clampPx(v * scale));
          const drop = clampPx(10 * scale);
          rootStyle.setProperty("--quote-glow-1", `${glow[0]}px`);
          rootStyle.setProperty("--quote-glow-2", `${glow[1]}px`);
          rootStyle.setProperty("--quote-glow-3", `${glow[2]}px`);
          rootStyle.setProperty("--quote-neon-1", `${neon[0]}px`);
          rootStyle.setProperty("--quote-neon-2", `${neon[1]}px`);
          rootStyle.setProperty("--quote-neon-3", `${neon[2]}px`);
          rootStyle.setProperty("--quote-neon-drop", `${drop}px`);
        }

        function normalizeFontFamily(raw) {
          const value = String(raw || "default").toLowerCase();
          return FONT_FAMILY_OPTIONS.includes(value) ? value : "default";
        }

        function normalizeEffectName(raw) {
          const value = String(raw || "none").toLowerCase();
          return EFFECT_OPTIONS.includes(value) ? value : "none";
        }

        function markMetaDirty(field) {
          if (!field) return;
          metaDirtyFields.add(field);
        }

        function applyNameStyles(data) {
          const nameEl = document.getElementById("name");
          if (!nameEl || !data) return;
          const mode = data.display_name_mode || "slug";
          if (mode === "username") {
            nameEl.textContent = data.user_username || data.slug || "User";
          } else if (mode === "custom" && data.custom_display_name) {
            nameEl.textContent = data.custom_display_name;
          } else {
            nameEl.textContent = data.slug || "User";
          }

          nameEl.classList.remove(
            "glow",
            "neon",
            "rainbow",
            "font-serif",
            "font-mono",
            "font-script",
            "font-display",
          );
          const fx = normalizeEffectName(data.name_effect);
          if (fx !== "none") nameEl.classList.add(fx);
          const fontFamily = normalizeFontFamily(data.name_font_family);
          if (fontFamily !== "default") {
            nameEl.classList.add(`font-${fontFamily}`);
          }
          if (data.user_id) {
            nameEl.dataset.id = `ID: ${data.user_id}`;
            nameEl.classList.add("has-id");
            nameEl.title = `ID: ${data.user_id}`;
          } else {
            nameEl.classList.remove("has-id");
            nameEl.removeAttribute("data-id");
            nameEl.removeAttribute("title");
          }
        }

        function applyQuoteStyles(data) {
          const quoteEl = document.getElementById("quote");
          if (!quoteEl || !data) return;
          quoteEl.classList.remove(
            "glow",
            "neon",
            "rainbow",
            "font-serif",
            "font-mono",
            "font-script",
            "font-display",
          );
          const fx = normalizeEffectName(data.quote_effect);
          if (fx !== "none") quoteEl.classList.add(fx);
          const fontFamily = normalizeFontFamily(data.quote_font_family);
          if (fontFamily !== "default") {
            quoteEl.classList.add(`font-${fontFamily}`);
          }
        }

        function stopQuoteTyping() {
          quoteTypingToken += 1;
        }

        function setQuoteCursorState(el, { active, blink } = {}) {
          if (!el) return;
          el.classList.toggle("quote-cursor", !!active);
          el.classList.toggle("cursor-blink", !!blink);
        }

        function startQuoteTyping(el, texts, opts = {}) {
          if (!el) return;
          const list = (texts || []).filter((t) => typeof t === "string");
          if (!list.length) {
            el.textContent = "";
            return;
          }
          const token = ++quoteTypingToken;
          const typeDelay =
            Number.isFinite(Number(opts.typeDelay)) &&
            Number(opts.typeDelay) > 0
              ? Number(opts.typeDelay)
              : 42;
          const eraseDelay =
            Number.isFinite(Number(opts.eraseDelay)) &&
            Number(opts.eraseDelay) > 0
              ? Number(opts.eraseDelay)
              : Math.max(20, Math.round(typeDelay * 0.7));
          const holdDelay =
            Number.isFinite(Number(opts.holdDelay)) &&
            Number(opts.holdDelay) >= 0
              ? Number(opts.holdDelay)
              : 1200;
          const gapDelay =
            Number.isFinite(Number(opts.gapDelay)) && Number(opts.gapDelay) >= 0
              ? Number(opts.gapDelay)
              : 320;
          let idx = 0;
          let pos = 0;
          let deleting = false;

          const tick = () => {
            if (token !== quoteTypingToken) return;
            const full = list[idx] || "";
            if (!deleting) {
              setQuoteCursorState(el, { active: true, blink: false });
              pos = Math.min(full.length, pos + 1);
              el.textContent = full.slice(0, pos);
              if (pos >= full.length) {
                deleting = true;
                setQuoteCursorState(el, { active: true, blink: true });
                setTimeout(tick, holdDelay);
                return;
              }
              setTimeout(tick, typeDelay);
            } else {
              setQuoteCursorState(el, { active: true, blink: false });
              pos = Math.max(0, pos - 1);
              el.textContent = full.slice(0, pos);
              if (pos <= 0) {
                deleting = false;
                idx = (idx + 1) % list.length;
                setQuoteCursorState(el, { active: true, blink: true });
                setTimeout(tick, gapDelay);
                return;
              }
              setTimeout(tick, eraseDelay);
            }
          };
          tick();
        }

        function toggleAttrQuoteTypingFields() {
          const toggle = document.getElementById("inAttrQuoteTyping");
          const wrap = document.getElementById("attrQuoteTypingFields");
          const speedWrap = document.getElementById("attrQuoteTypingSpeedWrap");
          const pauseWrap = document.getElementById("attrQuoteTypingPauseWrap");
          const enabled = !!(toggle && toggle.checked);
          if (wrap) wrap.style.display = enabled ? "grid" : "none";
          if (speedWrap) speedWrap.style.display = enabled ? "block" : "none";
          if (pauseWrap) pauseWrap.style.display = enabled ? "block" : "none";
        }

        function collectAttrQuoteTexts() {
          const main = document.getElementById("inAttrQuote");
          const alt1 = document.getElementById("inAttrQuoteAlt1");
          const alt2 = document.getElementById("inAttrQuoteAlt2");
          const list = [
            main ? main.value.trim() : "",
            alt1 ? alt1.value.trim() : "",
            alt2 ? alt2.value.trim() : "",
          ].filter(Boolean);
          return list.slice(0, 3);
        }

        function updateQuoteDisplay(data) {
          const quoteEl = document.getElementById("quote");
          if (!quoteEl) return false;
          const texts = Array.isArray(data?.quote_typing_texts)
            ? data.quote_typing_texts
            : [];
          const quoteSize = Number(data?.quote_font_size);
          if (Number.isFinite(quoteSize) && quoteSize > 0) {
            const clamped = Math.min(40, Math.max(10, quoteSize));
            quoteEl.style.fontSize = `${clamped}px`;
          } else {
            quoteEl.style.removeProperty("font-size");
          }
          const cleaned = texts
            .map((t) => String(t || "").trim())
            .filter(Boolean)
            .slice(0, 3);
          if (!cleaned.length && data?.quote) {
            cleaned.push(String(data.quote).trim());
          }
          if (!cleaned.length) {
            stopQuoteTyping();
            setQuoteCursorState(quoteEl, { active: false, blink: false });
            quoteEl.textContent = "";
            return false;
          }
          const wantsTyping = !!data?.quote_typing_enabled;
          if (!wantsTyping || prefersReducedMotion()) {
            stopQuoteTyping();
            setQuoteCursorState(quoteEl, { active: false, blink: false });
            quoteEl.textContent = cleaned[0];
            return true;
          }
          setQuoteCursorState(quoteEl, { active: true, blink: false });
          const rawSpeed = Number(data?.quote_typing_speed);
          const speed = Number.isFinite(rawSpeed)
            ? Math.min(200, Math.max(20, rawSpeed))
            : 42;
          const rawPause = Number(data?.quote_typing_pause);
          const pause = Number.isFinite(rawPause)
            ? Math.min(10000, Math.max(200, rawPause))
            : 1200;
          startQuoteTyping(quoteEl, cleaned, {
            typeDelay: speed,
            eraseDelay: Math.max(20, Math.round(speed * 0.7)),
            holdDelay: pause,
          });
          return true;
        }

        function applyAudioPlayerStyles(data) {
          if (!audioPlayer) return;
          const bgHex =
            sanitizeHexColor(data?.audio_player_bg_color) ||
            DEFAULT_AUDIO_BG_COLOR;
          const bgRgb = hexToRgb(bgHex) || hexToRgb(DEFAULT_AUDIO_BG_COLOR);
          const rawAlpha = Number(data?.audio_player_bg_alpha);
          const alpha = Number.isFinite(rawAlpha)
            ? Math.min(100, Math.max(0, rawAlpha))
            : DEFAULT_AUDIO_BG_ALPHA;
          const bg = bgRgb ? rgbToRgba(bgRgb, alpha / 100) : "";
          const border = bgRgb
            ? rgbToRgba(
                lightenRgb(bgRgb, 0.12),
                Math.min(1, alpha / 100 + 0.12),
              )
            : "";
          const btnBg = bgRgb
            ? rgbToRgba(lightenRgb(bgRgb, 0.08), Math.min(1, alpha / 100 + 0.1))
            : "";
          const textHex =
            sanitizeHexColor(data?.audio_player_text_color) ||
            sanitizeHexColor(data?.text_color) ||
            DEFAULT_AUDIO_TEXT_COLOR;
          const textRgb =
            hexToRgb(textHex) || hexToRgb(DEFAULT_AUDIO_TEXT_COLOR);
          const muted = textRgb ? rgbToRgba(textRgb, 0.72) : "";
          const accentHex =
            sanitizeHexColor(data?.audio_player_accent_color) ||
            sanitizeHexColor(data?.link_color) ||
            DEFAULT_AUDIO_ACCENT_COLOR;

          if (bg) audioPlayer.style.setProperty("--audio-bg", bg);
          if (border) audioPlayer.style.setProperty("--audio-border", border);
          if (btnBg) audioPlayer.style.setProperty("--audio-btn-bg", btnBg);
          if (textHex) audioPlayer.style.setProperty("--audio-text", textHex);
          if (muted) audioPlayer.style.setProperty("--audio-muted", muted);
          if (accentHex)
            audioPlayer.style.setProperty("--audio-accent", accentHex);
        }

        function updateLocationDisplay(data) {
          const locEl = document.getElementById("loc");
          if (!locEl) return;
          locEl.textContent = "";
          const locText =
            typeof data?.location === "string" ? data.location.trim() : "";
          locEl.classList.toggle("hidden", !locText);
          if (locText) {
            const icon = createLocationIcon();
            const text = document.createElement("span");
            text.textContent = ` ${locText}`;
            locEl.appendChild(icon);
            locEl.appendChild(text);
          }
        }

        function renderBadgesDisplay(data) {
          const badgesEl = document.getElementById("badges");
          if (!badgesEl) return;
          badgesEl.innerHTML = "";
          const frag = document.createDocumentFragment();
          let badgeCount = 0;
          (data?.icons || []).forEach((ic) => {
            if (!ic || !ic.displayed) return;
            const desc = ic.description || ic.code || "badge";
            const wrap = document.createElement("span");
            wrap.className = "badge";
            wrap.title = desc;
            wrap.setAttribute("aria-label", desc);

            const img = document.createElement("img");
            const iconUrl = safeMediaUrl(ic.image_url);
            if (!iconUrl) return;
            img.src = iconUrl;
            img.alt = desc;
            img.width = 20;
            img.height = 20;
            img.loading = "lazy";
            img.decoding = "async";

            wrap.appendChild(img);
            frag.appendChild(wrap);
            badgeCount += 1;
          });

          const discordLinked = !!data?.discord_linked;
          if (discordLinked && data?.discord_badges_enabled) {
            let discordList = Array.isArray(data.discord_badges)
              ? data.discord_badges
              : [];
            const filterCodes = Array.isArray(data.discord_badge_codes)
              ? data.discord_badge_codes
              : null;
            if (filterCodes) {
              discordList = discordList.filter((b) =>
                filterCodes.includes(b && b.code),
              );
            }
            discordList.forEach((badge) => {
              if (!badge) return;
              const desc = badge.label || badge.code || "badge";
              const wrap = document.createElement("span");
              wrap.className = "badge";
              wrap.title = desc;
              wrap.setAttribute("aria-label", desc);

              const img = document.createElement("img");
              const iconUrl = safeMediaUrl(badge.icon_url);
              if (!iconUrl) return;
              img.src = iconUrl;
              img.alt = desc;
              img.width = 20;
              img.height = 20;
              img.loading = "lazy";
              img.decoding = "async";

              wrap.appendChild(img);
              frag.appendChild(wrap);
              badgeCount += 1;
            });
          }
          badgesEl.appendChild(frag);
          badgesEl.classList.toggle("hidden", badgeCount === 0);
        }

        function renderLinksDisplay(data) {
          const linksEl = document.getElementById("links");
          if (!linksEl) return;
          linksEl.textContent = "";
          const frag = document.createDocumentFragment();
          const rawLinks = Array.isArray(data?.links) ? data.links : [];
          let linkItems = rawLinks;
          if (data?.is_template_demo && data?.demo_show_links) {
            const label = (data.demo_link_label || "").trim() || "Example Link";
            let url = (data.demo_link_url || "").trim();
            if (!url) url = "https://example.com";
            const iconUrl = (data.demo_link_icon_url || "").trim() || null;
            const demoLink = {
              label,
              url,
              icon_url: iconUrl,
              is_active: true,
            };
            linkItems = rawLinks.length ? rawLinks : [demoLink];
          }
          const iconsOnly = !!data?.link_icons_only;
          linksEl.classList.toggle("icons-only", iconsOnly);
          let linkCount = 0;
          (linkItems || []).forEach((l) => {
            if (!l || !l.is_active) return;
            const href = safeLinkUrl(l.url);
            if (!href) return;
            const a = document.createElement("a");
            a.className = "link";
            a.href = href;
            a.target = "_blank";
            a.rel = "noreferrer noopener";
            const labelText = (l.label || l.url || "").trim();
            if (labelText) {
              a.dataset.label = labelText;
              a.setAttribute("aria-label", labelText);
            } else {
              a.dataset.label = "";
            }
            const hoverTarget = (l.url || href || "").trim();
            const hoverText = iconsOnly ? hoverTarget || labelText : labelText || "";
            a.dataset.tooltip = hoverText;
            if (hoverText) a.title = hoverText;
            const iconUrl = safeMediaUrl(l.icon_url);
            if (iconUrl) {
              const img = document.createElement("img");
              img.src = iconUrl;
              img.alt = "";
              img.loading = "lazy";
              img.decoding = "async";
              a.appendChild(img);
            } else if (iconsOnly) {
              a.classList.add("no-icon");
            }
            const span = document.createElement("span");
            span.textContent = labelText || l.url;
            if (iconsOnly && iconUrl) span.classList.add("sr-only");
            a.appendChild(span);
            frag.appendChild(a);
            linkCount += 1;
          });
          linksEl.appendChild(frag);
          linksEl.classList.toggle("hidden", linkCount === 0);
        }

        function updateVisitCounterDisplay(data) {
          const visitBox = document.getElementById("visitCounter");
          const visitValue = document.getElementById("visitCounterValue");
          if (!visitBox || !visitValue) return;
          if (data?.show_visit_counter) {
            visitValue.textContent = Number(data.visit_count || 0).toLocaleString();
            const textColor =
              hexToRgba(data.visit_counter_color, 1) ||
              hexToRgba(data.text_color, 1) ||
              null;
            if (textColor) visitBox.style.color = textColor;
            const bgAlpha = Number.isFinite(
              Number(data.visit_counter_bg_alpha),
            )
              ? Number(data.visit_counter_bg_alpha)
              : 20;
            const bgColor =
              hexToRgba(
                data.visit_counter_bg_color || "#ffffff",
                Math.min(1, Math.max(0, bgAlpha / 100)),
              ) || "rgba(255,255,255,0.14)";
            visitBox.style.backgroundColor = bgColor;
            visitBox.style.display = "inline-flex";
          } else {
            visitBox.style.display = "none";
          }
        }

        function updatePfpDisplay(data) {
          const pfp = document.getElementById("pfp");
          const pfpFrame = document.getElementById("pfpFrame");
          if (pfp) {
            const prefersUserPfp =
              data?.is_template_demo &&
              currentUser &&
              currentUser.profile_picture;
            const linktreePfp = safeMediaUrl(data?.linktree_profile_picture);
            const primaryPfp = prefersUserPfp
              ? currentUser.profile_picture
              : linktreePfp || data?.profile_picture;
            const profileUrl =
              safeMediaUrl(primaryPfp) ||
              safeMediaUrl(currentUser && currentUser.profile_picture) ||
              "/static/icon.png";
            pfp.src = profileUrl;
          }
          if (pfpFrame) {
            const frameUrl = safeMediaUrl(data?.discord_decoration_url);
            if (data?.discord_frame_enabled && frameUrl) {
              pfpFrame.src = frameUrl;
              pfpFrame.style.display = "block";
            } else {
              pfpFrame.style.display = "none";
            }
          }
        }

        function updateDiscordStatusDisplay(data) {
          const presence = normalizePresence(data?.discord_presence);
          const presenceLabel = PRESENCE_LABELS[presence] || "Online";
          const presenceEl = document.getElementById("discordPresence");
          const statusLine = document.getElementById("discordStatusLine");
          const statusTextEl = document.getElementById("discordStatusText");
          const discordLinked = !!data?.discord_linked;
          if (presenceEl) {
            const showPresence = discordLinked && data?.discord_presence_enabled;
            presenceEl.classList.toggle("hidden", !showPresence);
            applyPresenceClass(presenceEl, presence);
            presenceEl.setAttribute(
              "aria-label",
              `Discord status: ${presenceLabel}`,
            );
          }
          if (statusLine && statusTextEl) {
            const showStatus = discordLinked && data?.discord_status_enabled;
            statusLine.classList.toggle("hidden", !showStatus);
            if (showStatus) {
              applyPresenceClass(statusLine, presence);
              const statusText = (data?.discord_status_text || "").trim();
              statusTextEl.textContent = statusText || presenceLabel;
            } else {
              statusTextEl.textContent = "";
            }
          }
        }

        function refreshTreeFromData({ preserveSelection = true } = {}) {
          if (!lastData) return;
          const selection = preserveSelection ? canvasSelection : null;
          const preferLite =
            lastMediaMode === "lite" ? true : shouldUseLiteMedia();
          renderTree(lastData, {
            preferLite,
            fromCache: true,
            device: currentDevice,
          });
          if (selection) {
            requestAnimationFrame(() => setCanvasSelection(selection));
          }
        }

        function updateAttrDiscordUI(data) {
          const statusEl = document.getElementById("attrDiscordStatusText");
          const previewEl = document.getElementById("attrDiscordPreview");
          const linkBtn = document.getElementById("btnAttrDiscordLink");
          const unlinkBtn = document.getElementById("btnAttrDiscordUnlink");
          const frameToggle = document.getElementById("inAttrDiscordFrame");
          const presenceToggle = document.getElementById("inAttrDiscordPresence");
          const statusToggle = document.getElementById("inAttrDiscordStatus");
          const badgesToggle = document.getElementById("inAttrDiscordBadges");
          const linked = !!data?.discord_linked;

          if (statusEl) {
            statusEl.textContent = linked ? "Discord linked" : "Not linked";
          }
          if (linkBtn && unlinkBtn) {
            linkBtn.style.display = linked ? "none" : "inline-flex";
            unlinkBtn.style.display = linked ? "inline-flex" : "none";
          }
          const disableToggle = (toggleEl, field) => {
            if (!toggleEl) return;
            if (!linked) {
              if (toggleEl.checked) toggleEl.checked = false;
              if (data && data[field]) {
                data[field] = false;
                markMetaDirty(field);
              }
              toggleEl.disabled = true;
            } else {
              toggleEl.disabled = false;
            }
          };
          disableToggle(frameToggle, "discord_frame_enabled");
          disableToggle(presenceToggle, "discord_presence_enabled");
          disableToggle(statusToggle, "discord_status_enabled");
          disableToggle(badgesToggle, "discord_badges_enabled");

          if (previewEl) {
            previewEl.innerHTML = "";
            previewEl.classList.remove("muted");
            const frameUrl = safeMediaUrl(data?.discord_decoration_url);
            if (linked && frameUrl) {
              const wrap = document.createElement("div");
              wrap.className = "pfp-preview";
              const img = document.createElement("img");
              img.src = frameUrl;
              img.alt = "Discord profile frame";
              img.loading = "lazy";
              wrap.appendChild(img);
              previewEl.appendChild(wrap);
            } else {
              previewEl.classList.add("muted");
              previewEl.textContent = linked
                ? "No Discord profile frame detected on your account."
                : "Link Discord to use your Discord profile frame.";
            }
          }
        }

        function renderAttrDiscordBadges() {
          const box = document.getElementById("attrDiscordBadgesList");
          const hint = document.getElementById("attrDiscordBadgesHint");
          if (!box) return;
          box.innerHTML = "";
          if (hint) hint.textContent = "";
          if (!lastData) return;
          const linked = !!lastData.discord_linked;
          if (!linked) {
            if (hint)
              hint.textContent = "Link Discord to manage your Discord badges.";
            return;
          }
          const list = Array.isArray(lastData.discord_badges)
            ? lastData.discord_badges
            : [];
          if (!list.length) {
            if (hint) hint.textContent = "No Discord badges found on your account.";
            return;
          }
          if (!Array.isArray(discordBadgeCodes)) {
            discordBadgeCodes = Array.isArray(lastData.discord_badge_codes)
              ? lastData.discord_badge_codes.slice()
              : list.map((b) => b && b.code).filter(Boolean);
          }
          list.forEach((badge) => {
            if (!badge) return;
            const item = document.createElement("div");
            item.className = "badge-item";
            const label = badge.label || badge.code || "badge";
            const icon = safeMediaUrl(badge.icon_url ? String(badge.icon_url) : "");
            const checked =
              Array.isArray(discordBadgeCodes) &&
              discordBadgeCodes.includes(badge.code);
            item.innerHTML = `
              <div class="badge-row">
                ${
                  icon
                    ? `<img src="${icon}" alt="${badge.code || ""}">`
                    : `<span></span>`
                }
                <div>
                  <strong>${escapeHtml(badge.code || "badge")}</strong>
                  <div class="muted">${escapeHtml(label)}</div>
                </div>
                <label class="row" style="gap:0.35rem">
                  <span class="muted">Displayed</span>
                  <input type="checkbox" data-code="${escapeHtml(
                    badge.code || "",
                  )}" ${checked ? "checked" : ""} aria-label="Displayed">
                </label>
              </div>
            `;
            const chk = item.querySelector('input[type="checkbox"][data-code]');
            chk.addEventListener("change", () => {
              const codes = Array.from(
                box.querySelectorAll('input[type="checkbox"][data-code]'),
              )
                .filter((input) => input.checked)
                .map((input) => input.getAttribute("data-code"))
                .filter(Boolean);
              discordBadgeCodes = codes;
              if (lastData) {
                lastData.discord_badge_codes = codes;
                markMetaDirty("discord_badge_codes");
              }
              renderBadgesDisplay(lastData);
            });
            box.appendChild(item);
          });
        }

        function renderAttrBadges() {
          const box = document.getElementById("attrBadgesList");
          if (!box) return;
          box.innerHTML = "";
          if (!lastData || !Array.isArray(lastData.icons)) return;
          lastData.icons.forEach((ic) => {
            if (!ic) return;
            const item = document.createElement("div");
            item.className = "badge-item";
            const desc = ic.description || ic.code || "badge";
            const icon = safeMediaUrl(ic.image_url ? String(ic.image_url) : "");
            const acquired = ic.acquired_at
              ? new Date(ic.acquired_at).toLocaleDateString()
              : "";
            item.innerHTML = `
              <div class="badge-row">
                ${
                  icon
                    ? `<img src="${icon}" alt="${escapeHtml(ic.code || "")}">`
                    : `<span></span>`
                }
                <div>
                  <strong>${escapeHtml(ic.code || "badge")}</strong>
                  <div class="muted">${escapeHtml(desc || "")}</div>
                </div>
                <label class="row" style="gap:0.35rem">
                  <span class="muted">Displayed</span>
                  <input type="checkbox" ${
                    ic.displayed ? "checked" : ""
                  } aria-label="Displayed">
                </label>
              </div>
              ${
                acquired
                  ? `<div class="muted" style="font-size:0.75rem">Acquired ${acquired}</div>`
                  : ""
              }
            `;
            const chk = item.querySelector('input[type="checkbox"]');
            chk.addEventListener("change", async () => {
              const ok = await apiToggleMyIcon(ic.code, chk.checked);
              if (!ok) {
                chk.checked = !chk.checked;
                return;
              }
              if (lastData && Array.isArray(lastData.icons)) {
                const target = lastData.icons.find((b) => b.code === ic.code);
                if (target) target.displayed = chk.checked;
              }
              renderBadgesDisplay(lastData);
            });
            box.appendChild(item);
          });
        }

        function domOrderKey(container) {
          return Array.from(container.querySelectorAll(".link-item"))
            .map((el) => el.dataset.id || "")
            .join("|");
        }

        function getDragAfterElement(container, y) {
          const els = Array.from(
            container.querySelectorAll(".link-item:not(.dragging)"),
          );
          let closest = { offset: Number.NEGATIVE_INFINITY, el: null };
          els.forEach((el) => {
            const box = el.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
              closest = { offset, el };
            }
          });
          return closest.el;
        }

        function ensureLinksDrag(container) {
          if (!container || container.dataset.dragBound === "1") return;
          container.dataset.dragBound = "1";
          container.addEventListener("dragover", (e) => {
            e.preventDefault();
            const after = getDragAfterElement(container, e.clientY);
            const dragging = container.querySelector(".dragging");
            if (!dragging) return;
            if (!after) {
              container.appendChild(dragging);
            } else {
              container.insertBefore(dragging, after);
            }
          });
        }

        async function persistLinkOrder(container) {
          const wrap = container || document.getElementById("attrLinksList");
          if (!wrap) return;
          const rows = Array.from(wrap.querySelectorAll(".link-item"));
          if (!rows.length) return;
          const results = await Promise.all(
            rows.map((row, idx) =>
              apiUpdateLink(
                Number(row.dataset.id),
                { position: idx },
                { silent: true },
              ),
            ),
          );
          if (results.some((ok) => ok === false)) {
            showAttrMessage(
              document.getElementById("attrLinksMsg"),
              "Reorder failed",
              false,
            );
            return;
          }
          if (lastData && Array.isArray(lastData.links)) {
            rows.forEach((row, idx) => {
              const link = lastData.links.find(
                (l) => String(l.id) === String(row.dataset.id),
              );
              if (link) link.position = idx;
            });
            lastData.links.sort(
              (a, b) => (a.position || 0) - (b.position || 0),
            );
          }
          renderLinksDisplay(lastData);
          showAttrMessage(
            document.getElementById("attrLinksMsg"),
            "Order updated",
            true,
          );
        }

        function moveLinkRow(row, direction = 0) {
          if (!direction || !row || !row.parentElement) return;
          const wrap = row.parentElement;
          if (direction < 0 && row.previousElementSibling) {
            wrap.insertBefore(row, row.previousElementSibling);
          } else if (direction > 0 && row.nextElementSibling) {
            wrap.insertBefore(row.nextElementSibling, row);
          } else {
            return;
          }
          persistLinkOrder(wrap);
        }

        function renderAttrLinks(links) {
          const wrap = document.getElementById("attrLinksList");
          currentLinks = Array.isArray(links) ? links.slice() : [];
          if (!wrap) return;
          wrap.innerHTML = "";
          ensureLinksDrag(wrap);
          const ordered = Array.isArray(links) ? links.slice() : [];
          ordered.sort((a, b) => (a.position || 0) - (b.position || 0));
          ordered.forEach((l) => {
            const row = document.createElement("div");
            row.className = "link-item";
            row.dataset.id = l.id;
            row.draggable = true;
            row.innerHTML = `
              <span class="handle" title="Move" aria-hidden="true">☰</span>
              <input class="input" data-k="label" placeholder="Label" value="${escapeHtml(
                l.label || "",
              )}">
              <input class="input" data-k="url" placeholder="https://…" value="${escapeHtml(
                l.url || "",
              )}">
              <div class="link-icon-upload">
                <input type="file" class="input" data-k="icon_file" accept="image/*">
                <input type="hidden" data-k="icon_url" value="${escapeHtml(
                  l.icon_url || "",
                )}">
                <div class="muted" data-k="icon_status"></div>
                <button class="btn sm ghost" type="button" data-act="icon-remove">
                  Remove Icon
                </button>
              </div>
              <select class="select" data-k="is_active">
                <option value="true"${l.is_active ? " selected" : ""}>Active</option>
                <option value="false"${
                  !l.is_active ? " selected" : ""
                }>Hidden</option>
              </select>
              <div class="row" style="gap:0.35rem; flex-wrap: wrap">
                <button class="btn sm ghost" data-act="up" title="Up">▲</button>
                <button class="btn sm ghost" data-act="down" title="Down">▼</button>
                <button class="btn sm" data-act="save">Save</button>
                <button class="btn sm danger" data-act="del">Delete</button>
              </div>
            `;
            const iconUrlInput = row.querySelector('[data-k="icon_url"]');
            const iconStatus = row.querySelector('[data-k="icon_status"]');
            if (iconStatus) {
              iconStatus.textContent =
                fileNameFromUrl(l.icon_url || "") || "No icon uploaded.";
            }
            const iconFile = row.querySelector('[data-k="icon_file"]');
            if (iconFile) {
              iconFile.addEventListener("change", async () => {
                try {
                  const url = await uploadInlineFile(
                    iconFile,
                    "/api/users/me/linkicon",
                  );
                  if (!url) return;
                  if (iconUrlInput) iconUrlInput.value = url;
                  if (iconStatus) {
                    iconStatus.textContent =
                      fileNameFromUrl(url) || "No icon uploaded.";
                  }
                  const ok = await apiUpdateLink(
                    l.id,
                    { icon_url: url },
                    { silent: true },
                  );
                  if (!ok) {
                    showAttrMessage(
                      document.getElementById("attrLinksMsg"),
                      "Icon upload failed",
                      false,
                    );
                    return;
                  }
                  if (lastData && Array.isArray(lastData.links)) {
                    const target = lastData.links.find((link) => link.id === l.id);
                    if (target) target.icon_url = url;
                  }
                  renderLinksDisplay(lastData);
                  showAttrMessage(
                    document.getElementById("attrLinksMsg"),
                    "Icon uploaded",
                    true,
                  );
                } catch (e) {
                  showAttrMessage(
                    document.getElementById("attrLinksMsg"),
                    "Icon upload failed",
                    false,
                  );
                }
              });
            }
            const iconRemove = row.querySelector('[data-act="icon-remove"]');
            if (iconRemove) {
              iconRemove.addEventListener("click", async () => {
                if (iconUrlInput) iconUrlInput.value = "";
                if (iconFile) iconFile.value = "";
                if (iconStatus) iconStatus.textContent = "No icon uploaded.";
                const ok = await apiUpdateLink(
                  l.id,
                  { icon_url: null },
                  { silent: true },
                );
                if (!ok) {
                  showAttrMessage(
                    document.getElementById("attrLinksMsg"),
                    "Icon remove failed",
                    false,
                  );
                  return;
                }
                if (lastData && Array.isArray(lastData.links)) {
                  const target = lastData.links.find((link) => link.id === l.id);
                  if (target) target.icon_url = null;
                }
                renderLinksDisplay(lastData);
                showAttrMessage(
                  document.getElementById("attrLinksMsg"),
                  "Icon removed",
                  true,
                );
              });
            }
            row
              .querySelector('[data-act="save"]')
              .addEventListener("click", async () => {
                const currentPosition = Array.from(wrap.children).indexOf(row);
                const body = {
                  label:
                    row.querySelector('[data-k="label"]').value.trim() || null,
                  url: row.querySelector('[data-k="url"]').value.trim(),
                  icon_url:
                    row.querySelector('[data-k="icon_url"]').value.trim() || null,
                  is_active:
                    row.querySelector('[data-k="is_active"]').value === "true",
                  position: currentPosition,
                };
                const ok = await apiUpdateLink(l.id, body);
                if (ok && lastData && Array.isArray(lastData.links)) {
                  const target = lastData.links.find((link) => link.id === l.id);
                  if (target) Object.assign(target, body);
                  renderLinksDisplay(lastData);
                }
              });
            row
              .querySelector('[data-act="del"]')
              .addEventListener("click", async () => {
                if (!confirm("Delete this link?")) return;
                const ok = await apiDeleteLink(l.id);
                if (ok && lastData && Array.isArray(lastData.links)) {
                  lastData.links = lastData.links.filter((link) => link.id !== l.id);
                  renderLinksDisplay(lastData);
                  renderAttrLinks(lastData.links);
                }
              });
            row
              .querySelector('[data-act="up"]')
              .addEventListener("click", async () => {
                moveLinkRow(row, -1);
              });
            row
              .querySelector('[data-act="down"]')
              .addEventListener("click", async () => {
                moveLinkRow(row, 1);
              });
            row.addEventListener("dragstart", (evt) => {
              dragStartOrder = domOrderKey(wrap);
              row.classList.add("dragging");
              if (evt.dataTransfer) {
                evt.dataTransfer.effectAllowed = "move";
                evt.dataTransfer.setData("text/plain", String(l.id));
              }
            });
            row.addEventListener("dragend", async () => {
              row.classList.remove("dragging");
              const orderAfter = domOrderKey(wrap);
              if (orderAfter !== dragStartOrder) {
                await persistLinkOrder(wrap);
              }
            });
            wrap.appendChild(row);
          });
        }

        async function apiAddLink(body) {
          const msgEl = document.getElementById("attrLinksMsg");
          if (!linktreeId) {
            showAttrMessage(msgEl, "Create the Linktree first", false);
            return null;
          }
          const r = await fetch(`/api/linktrees/${linktreeId}/links`, {
            method: "POST",
            headers: headers(),
            credentials: "include",
            body: JSON.stringify(body),
          });
          if (!r.ok) {
            showAttrMessage(msgEl, "Add link failed", false);
            return null;
          }
          const data = await r.json();
          showAttrMessage(msgEl, "Link added", true);
          return data;
        }

        async function apiUpdateLink(linkId, body, opts = {}) {
          const msgEl = document.getElementById("attrLinksMsg");
          const { silent = false } = opts;
          const r = await fetch(`/api/links/${linkId}`, {
            method: "PATCH",
            headers: headers(),
            credentials: "include",
            body: JSON.stringify(body),
          });
          if (!r.ok) {
            if (!silent) showAttrMessage(msgEl, "Save failed", false);
            return false;
          }
          if (!silent) showAttrMessage(msgEl, "Saved", true);
          return true;
        }

        async function apiDeleteLink(linkId) {
          const msgEl = document.getElementById("attrLinksMsg");
          const r = await fetch(`/api/links/${linkId}`, {
            method: "DELETE",
            headers: headers(),
            credentials: "include",
          });
          if (!r.ok) {
            showAttrMessage(msgEl, "Delete failed", false);
            return false;
          }
          showAttrMessage(msgEl, "Deleted", true);
          return true;
        }

        async function apiToggleMyIcon(code, displayed) {
          const r = await fetch(
            `/api/users/me/icons/${encodeURIComponent(code)}`,
            {
              method: "PATCH",
              headers: headers(),
              credentials: "include",
              body: JSON.stringify({ displayed }),
            },
          );
          if (!r.ok) {
            showEditorMessage("Icon toggle failed", false);
            return false;
          }
          showEditorMessage("Icon updated", true);
          return true;
        }

        let cursorFxMode = "none";
        let cursorFxColor = DEFAULT_AUDIO_ACCENT_COLOR;
        let cursorFxRgb = hexToRgb(DEFAULT_AUDIO_ACCENT_COLOR);
        let cursorFxAlpha = DEFAULT_CURSOR_FX_ALPHA;
        let cursorFxOffsetX = 0;
        let cursorFxOffsetY = 0;
        let cursorGlowEl = null;
        let cursorFxCanvas = null;
        let cursorFxCtx = null;
        let cursorFxParticles = [];
        let cursorFxRaf = null;
        let cursorFxLastTime = 0;
        let cursorFxLastSpawn = 0;
        let cursorFxLastX = 0;
        let cursorFxLastY = 0;
        let cursorFxSize = { width: 0, height: 0, dpr: 1 };
        let cursorFxMoveHandler = null;
        let cursorFxLeaveHandler = null;
        let cursorFxResizeHandler = null;
        let cursorFxImage = "";
        let cursorFxImageSrc = "";
        let cursorFxHasImage = false;

        function setCursorFxSettings({ color, alpha } = {}) {
          const clean = sanitizeHexColor(color) || DEFAULT_AUDIO_ACCENT_COLOR;
          cursorFxColor = clean;
          cursorFxRgb = hexToRgb(clean) || hexToRgb(DEFAULT_AUDIO_ACCENT_COLOR);
          const rawAlpha = Number(alpha);
          cursorFxAlpha = Number.isFinite(rawAlpha)
            ? Math.min(100, Math.max(0, rawAlpha)) / 100
            : DEFAULT_CURSOR_FX_ALPHA;
          document.documentElement.style.setProperty(
            "--cursor-fx-color",
            clean,
          );
        }

        function setCursorFxOffset(px) {
          const offset = Number.isFinite(px) ? px : 0;
          cursorFxOffsetX = offset;
          cursorFxOffsetY = offset;
        }

        function setCursorGlowImage(imageUrl, size = CURSOR_IMAGE_SIZE) {
          const root = document.documentElement;
          const hasImage = !!imageUrl;
          cursorFxHasImage = hasImage;
          if (hasImage) {
            root.style.setProperty("--cursor-fx-image", `url("${imageUrl}")`);
            root.style.setProperty("--cursor-fx-size", `${size}px`);
          } else {
            root.style.removeProperty("--cursor-fx-image");
            root.style.removeProperty("--cursor-fx-size");
          }
          if (cursorGlowEl) {
            cursorGlowEl.classList.toggle("shape", hasImage);
            cursorGlowEl.classList.toggle("circle", !hasImage);
          }
        }

        function prefersReducedMotion() {
          return (
            typeof window.matchMedia === "function" &&
            window.matchMedia("(prefers-reduced-motion: reduce)").matches
          );
        }

        function ensureCursorGlow() {
          if (cursorGlowEl) return cursorGlowEl;
          const el = document.createElement("div");
          el.className = cursorFxHasImage
            ? "cursor-glow shape"
            : "cursor-glow circle";
          el.setAttribute("aria-hidden", "true");
          document.body.appendChild(el);
          cursorGlowEl = el;
          return el;
        }

        function ensureCursorCanvas() {
          if (cursorFxCanvas && cursorFxCtx) return cursorFxCanvas;
          const canvas = document.createElement("canvas");
          canvas.className = "cursor-fx-canvas";
          canvas.setAttribute("aria-hidden", "true");
          document.body.appendChild(canvas);
          cursorFxCanvas = canvas;
          cursorFxCtx = canvas.getContext("2d");
          resizeCursorCanvas();
          return canvas;
        }

        function resizeCursorCanvas() {
          if (!cursorFxCanvas || !cursorFxCtx) return;
          const dpr = window.devicePixelRatio || 1;
          const width = window.innerWidth;
          const height = window.innerHeight;
          cursorFxSize = { width, height, dpr };
          cursorFxCanvas.width = Math.round(width * dpr);
          cursorFxCanvas.height = Math.round(height * dpr);
          cursorFxCanvas.style.width = `${width}px`;
          cursorFxCanvas.style.height = `${height}px`;
          cursorFxCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function spawnCursorParticles(x, y, speed) {
          const count = Math.min(6, Math.max(2, Math.round(speed / 8)));
          for (let i = 0; i < count; i += 1) {
            const life = 520 + Math.random() * 520;
            cursorFxParticles.push({
              x,
              y,
              vx: (Math.random() - 0.5) * 0.08,
              vy: 0.06 + Math.random() * 0.09,
              life,
              maxLife: life,
              size: 1 + Math.random() * 2.6,
            });
          }
          if (cursorFxParticles.length > 180) {
            cursorFxParticles.splice(0, cursorFxParticles.length - 180);
          }
        }

        function tickCursorParticles(now) {
          if (!cursorFxCtx) return;
          const dt = Math.min(32, now - cursorFxLastTime);
          cursorFxLastTime = now;
          cursorFxCtx.clearRect(0, 0, cursorFxSize.width, cursorFxSize.height);
          const rgb = cursorFxRgb || { r: 133, g: 163, b: 255 };
          for (let i = cursorFxParticles.length - 1; i >= 0; i -= 1) {
            const p = cursorFxParticles[i];
            p.life -= dt;
            if (p.life <= 0) {
              cursorFxParticles.splice(i, 1);
              continue;
            }
            p.vy += 0.0005 * dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            const alpha = (p.life / p.maxLife) * 0.85 * cursorFxAlpha;
            cursorFxCtx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            cursorFxCtx.beginPath();
            cursorFxCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            cursorFxCtx.fill();
          }
          if (cursorFxParticles.length || now - cursorFxLastSpawn < 140) {
            cursorFxRaf = requestAnimationFrame(tickCursorParticles);
          } else {
            cursorFxRaf = null;
          }
        }

        function startCursorGlow() {
          const el = ensureCursorGlow();
          el.style.display = "block";
          cursorFxMoveHandler = (event) => {
            el.style.left = `${event.clientX + cursorFxOffsetX}px`;
            el.style.top = `${event.clientY + cursorFxOffsetY}px`;
            el.style.opacity = String(cursorFxAlpha);
          };
          cursorFxLeaveHandler = (event) => {
            if (event.type === "mouseout" && event.relatedTarget) return;
            el.style.opacity = "0";
          };
          document.addEventListener("pointermove", cursorFxMoveHandler, {
            passive: true,
          });
          document.addEventListener("mouseout", cursorFxLeaveHandler, {
            passive: true,
          });
        }

        function startCursorParticles() {
          ensureCursorCanvas();
          if (cursorFxCanvas) cursorFxCanvas.style.display = "block";
          cursorFxParticles = [];
          cursorFxLastTime = performance.now();
          cursorFxLastSpawn = 0;
          cursorFxLastX = 0;
          cursorFxLastY = 0;
          cursorFxMoveHandler = (event) => {
            const x = event.clientX + cursorFxOffsetX;
            const y = event.clientY + cursorFxOffsetY;
            const speed = Math.hypot(x - cursorFxLastX, y - cursorFxLastY);
            cursorFxLastX = x;
            cursorFxLastY = y;
            const now = performance.now();
            if (now - cursorFxLastSpawn < 16) return;
            cursorFxLastSpawn = now;
            spawnCursorParticles(x, y, speed);
            if (!cursorFxRaf) {
              cursorFxLastTime = now;
              cursorFxRaf = requestAnimationFrame(tickCursorParticles);
            }
          };
          cursorFxResizeHandler = () => resizeCursorCanvas();
          document.addEventListener("pointermove", cursorFxMoveHandler, {
            passive: true,
          });
          window.addEventListener("resize", cursorFxResizeHandler, {
            passive: true,
          });
        }

        function stopCursorFx() {
          if (cursorFxMoveHandler) {
            document.removeEventListener("pointermove", cursorFxMoveHandler);
            cursorFxMoveHandler = null;
          }
          if (cursorFxLeaveHandler) {
            document.removeEventListener("mouseout", cursorFxLeaveHandler);
            cursorFxLeaveHandler = null;
          }
          if (cursorFxResizeHandler) {
            window.removeEventListener("resize", cursorFxResizeHandler);
            cursorFxResizeHandler = null;
          }
          if (cursorFxRaf) {
            cancelAnimationFrame(cursorFxRaf);
            cursorFxRaf = null;
          }
          cursorFxParticles = [];
          if (cursorFxCtx && cursorFxSize.width && cursorFxSize.height) {
            cursorFxCtx.clearRect(
              0,
              0,
              cursorFxSize.width,
              cursorFxSize.height,
            );
          }
          if (cursorFxCanvas) cursorFxCanvas.style.display = "none";
          if (cursorGlowEl) cursorGlowEl.style.opacity = "0";
          cursorFxMode = "none";
        }

        function applyCursorEffect(mode, { isMobile } = {}) {
          const normalized = String(mode || "none").toLowerCase();
          const allowed =
            normalized === "glow" || normalized === "particles"
              ? normalized
              : "none";
          const next =
            allowed === "none" || isMobile || prefersReducedMotion()
              ? "none"
              : allowed;
          if (next === cursorFxMode) return;
          stopCursorFx();
          if (next === "glow") startCursorGlow();
          if (next === "particles") startCursorParticles();
          cursorFxMode = next;
        }

        function createLocationIcon() {
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg",
          );
          svg.setAttribute("width", "16");
          svg.setAttribute("height", "16");
          svg.setAttribute("viewBox", "0 0 24 24");
          svg.setAttribute("fill", "currentColor");
          svg.setAttribute("aria-hidden", "true");
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );
          path.setAttribute(
            "d",
            "M12 2C7.6 2 4 5.6 4 10c0 5.3 8 12 8 12s8-6.7 8-12c0-4.4-3.6-8-8-8zm0 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6z",
          );
          svg.appendChild(path);
          return svg;
        }

        const PRESENCE_LABELS = {
          online: "Online",
          idle: "Idle",
          dnd: "Do not disturb",
          offline: "Offline",
        };
        const PRESENCE_CLASSES = [
          "status-online",
          "status-idle",
          "status-dnd",
          "status-offline",
        ];

        function normalizePresence(raw) {
          const key = String(raw || "online").toLowerCase();
          return ["online", "idle", "dnd", "offline"].includes(key)
            ? key
            : "online";
        }

        function applyPresenceClass(el, presence) {
          if (!el) return;
          PRESENCE_CLASSES.forEach((cls) => el.classList.remove(cls));
          el.classList.add(`status-${normalizePresence(presence)}`);
        }

        function formatTime(seconds) {
          if (!Number.isFinite(seconds) || seconds <= 0) return "0:00";
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${String(secs).padStart(2, "0")}`;
        }

        function stripFileExtension(name) {
          if (!name) return "";
          const base = String(name).trim();
          const dot = base.lastIndexOf(".");
          if (dot <= 0) return base;
          return base.slice(0, dot);
        }

        function getAudioTitle(url) {
          if (!url) return "Audio";
          try {
            const u = new URL(url, window.location.origin);
            const name = (u.pathname || "").split("/").pop();
            if (name) return stripFileExtension(decodeURIComponent(name));
          } catch (_) {}
          return "Audio";
        }

        function syncAudioUI() {
          if (!audioPlayer || !audioSeek || !audioTime || !audioPlayBtn) return;
          if (!bgAudio) {
            audioTime.textContent = "0:00 / 0:00";
            audioSeek.value = "0";
            audioSeek.max = "0";
            audioPlayBtn.classList.remove("is-playing");
            audioPlayBtn.setAttribute("aria-label", "Play");
            return;
          }
          const duration = Number.isFinite(bgAudio.duration)
            ? bgAudio.duration
            : 0;
          const current = Number.isFinite(bgAudio.currentTime)
            ? bgAudio.currentTime
            : 0;
          if (!audioSeekActive) {
            audioSeek.max = duration ? String(duration) : "0";
            audioSeek.value = String(
              Math.min(current, duration || current || 0),
            );
          }
          audioTime.textContent = `${formatTime(current)} / ${formatTime(
            duration,
          )}`;
          const playing = !bgAudio.paused;
          audioPlayBtn.classList.toggle("is-playing", playing);
          audioPlayBtn.setAttribute("aria-label", playing ? "Pause" : "Play");
        }

        function bindAudioPlayer(audio) {
          if (!audio) return () => {};
          const update = () => syncAudioUI();
          const onPlay = () => syncAudioUI();
          const onPause = () => syncAudioUI();
          audio.addEventListener("timeupdate", update);
          audio.addEventListener("loadedmetadata", update);
          audio.addEventListener("play", onPlay);
          audio.addEventListener("pause", onPause);
          audio.addEventListener("ended", onPause);
          return () => {
            audio.removeEventListener("timeupdate", update);
            audio.removeEventListener("loadedmetadata", update);
            audio.removeEventListener("play", onPlay);
            audio.removeEventListener("pause", onPause);
            audio.removeEventListener("ended", onPause);
          };
        }

        function updateSoundUI() {
          if (!soundBtn) return;
          soundBtn.classList.toggle("on", soundOn);
          soundLabel.textContent = soundOn ? "Sound on" : "Sound off";
        }

        function showGate(show) {
          const gate = document.getElementById("enterOverlay");
          if (!gate) return;
          if (show) {
            gate.classList.remove("hidden");
            gateActive = true;
            gate.focus({ preventScroll: true });
          } else {
            gate.classList.add("hidden");
            gateActive = false;
          }
        }

        async function turnSoundOn() {
          try {
            if (bgAudio) {
              bgAudio.muted = false;
              await bgAudio.play().catch(() => {});
            } else if (bgVideo) {
              bgVideo.muted = false;
              await bgVideo.play().catch(() => {});
            } else {
              return;
            }
            soundOn = true;
            updateSoundUI();
            soundBtn.classList.remove("hidden");
            syncAudioUI();
          } catch (_) {
            // bleibt off
          }
        }

        function turnSoundOff() {
          try {
            if (bgAudio) {
              bgAudio.muted = true;
            }
            if (bgVideo) {
              bgVideo.muted = true;
            }
            soundOn = false;
            updateSoundUI();
            syncAudioUI();
          } catch (_) {}
        }

        async function playBackgroundVideo(unmute) {
          if (!bgVideo) return false;
          const tryPlay = async (mute) => {
            bgVideo.muted = mute;
            try {
              await bgVideo.play();
              return true;
            } catch (_) {
              return false;
            }
          };
          if (unmute) {
            if (await tryPlay(false)) return true;
            if (await tryPlay(true)) return true;
          } else if (await tryPlay(true)) {
            return true;
          }
          return false;
        }

        if (soundBtn) {
          soundBtn.addEventListener("click", () => {
            if (soundOn) turnSoundOff();
            else turnSoundOn();
          });
        }

        if (audioSeek) {
          audioSeek.addEventListener("pointerdown", () => {
            audioSeekActive = true;
          });
          audioSeek.addEventListener("pointerup", () => {
            audioSeekActive = false;
            syncAudioUI();
          });
          audioSeek.addEventListener("pointercancel", () => {
            audioSeekActive = false;
            syncAudioUI();
          });
          audioSeek.addEventListener("input", () => {
            if (!bgAudio) return;
            const nextTime = Number(audioSeek.value || 0);
            if (Number.isFinite(nextTime)) bgAudio.currentTime = nextTime;
          });
        }

        if (audioPlayBtn) {
          audioPlayBtn.addEventListener("click", async () => {
            if (!bgAudio) return;
            if (bgAudio.paused) {
              await turnSoundOn();
            } else {
              bgAudio.pause();
            }
            syncAudioUI();
          });
        }

        if (audioBackBtn) {
          audioBackBtn.addEventListener("click", () => {
            if (!bgAudio) return;
            bgAudio.currentTime = Math.max(0, bgAudio.currentTime - 10);
            syncAudioUI();
          });
        }

        if (audioForwardBtn) {
          audioForwardBtn.addEventListener("click", () => {
            if (!bgAudio || !Number.isFinite(bgAudio.duration)) return;
            bgAudio.currentTime = Math.min(
              bgAudio.duration,
              bgAudio.currentTime + 10,
            );
            syncAudioUI();
          });
        }

        async function enterExperience() {
          showGate(false);
          if (gateCacheKey) {
            try {
              sessionStorage.setItem(gateCacheKey, "1");
            } catch (_) {}
          }
          if (bgVideo) {
            bgVideo.dataset.userReady = "1";
            bgVideo.dataset.wantSound = bgAudio ? "0" : "1";
            const ok = await playBackgroundVideo(!bgAudio);
            if (ok && !bgAudio) {
              soundOn = !bgVideo.muted;
              updateSoundUI();
            }
          }
          if (bgAudio) {
            bgAudio.muted = false;
            bgAudio
              .play()
              .then(() => {
                soundOn = true;
                updateSoundUI();
                syncAudioUI();
              })
              .catch(() => {});
          }
        }

        const gate = document.getElementById("enterOverlay");
        if (gate) {
          gate.addEventListener("click", enterExperience);
          gate.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              enterExperience();
            }
          });
        }

        // Ein “erster User-Input” schaltet optional sofort Ton an
        const firstGesture = () => {
          turnSoundOn();
          window.removeEventListener("pointerdown", firstGesture);
        };
        window.addEventListener("pointerdown", firstGesture, { once: true });

        const CACHE_PREFIX = "taoma:linktree:v1:";
        const CACHE_MS = 90 * 1000; // short-lived cache to speed up repeat visits
        let lastData = null;
        let initialRenderDone = false;
        let lastMediaMode = null;
        let lastDevice = null;
        let lastMediaSig = null;
        let lastBgSig = null;
        let lastAudioSig = null;
        let lastCursorSig = null;
        let gateCacheKey = null;
        let discordStatusCache = null;
        let discordStatusPromise = null;

        function getConnectionProfile() {
          const conn =
            navigator.connection ||
            navigator.mozConnection ||
            navigator.webkitConnection;
          const downlink =
            conn && typeof conn.downlink === "number" ? conn.downlink : null;
          return {
            saveData:
              !!(conn && conn.saveData) ||
              (typeof window.matchMedia === "function" &&
                window.matchMedia("(prefers-reduced-data: reduce)").matches),
            effectiveType: (conn && conn.effectiveType) || "",
            downlink,
          };
        }

        function shouldUseLiteMedia(profile = getConnectionProfile()) {
          const dl =
            typeof profile.downlink === "number" ? profile.downlink : null;
          const slow =
            profile.saveData ||
            ["slow-2g", "2g", "3g"].includes(profile.effectiveType || "") ||
            (dl !== null && dl < 1.5);
          return !!slow;
        }

        function makeCacheKey({ slug, templateId, device }) {
          if (templateId) return `${CACHE_PREFIX}tpl:${templateId}:${device}`;
          return `${CACHE_PREFIX}slug:${slug || "anon"}:${device}`;
        }

        function readCachedTree(key) {
          try {
            const raw = sessionStorage.getItem(key);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed.savedAt !== "number" || !parsed.data)
              return null;
            if (Date.now() - parsed.savedAt > CACHE_MS) {
              sessionStorage.removeItem(key);
              return null;
            }
            return parsed.data;
          } catch (_) {
            return null;
          }
        }

        function writeCachedTree(key, data) {
          try {
            sessionStorage.setItem(
              key,
              JSON.stringify({ savedAt: Date.now(), data: data || null }),
            );
          } catch (_) {}
        }

        async function fetchDiscordStatus() {
          if (discordStatusCache !== null) return discordStatusCache;
          if (discordStatusPromise) return discordStatusPromise;
          discordStatusPromise = (async () => {
            try {
              const r = await fetch("/api/discord/status", {
                credentials: "include",
              });
              if (!r.ok) throw new Error("discord status failed");
              const json = await r.json();
              discordStatusCache = json || { linked: false };
            } catch (_) {
              discordStatusCache = { linked: false };
            } finally {
              discordStatusPromise = null;
            }
            return discordStatusCache;
          })();
          return discordStatusPromise;
        }

        async function loadDiscordStatusIntoData() {
          discordStatusCache = null;
          const status = await fetchDiscordStatus();
          discordBadgeCodes = null;
          if (!lastData) return status;
          if (status && status.linked) {
            lastData.discord_linked = true;
            if (status.presence) lastData.discord_presence = status.presence;
            if (status.status_text) lastData.discord_status_text = status.status_text;
            if (Array.isArray(status.badges)) lastData.discord_badges = status.badges;
            if (status.decoration_url)
              lastData.discord_decoration_url = status.decoration_url;
          } else {
            lastData.discord_linked = false;
            lastData.discord_status_text = "";
            lastData.discord_badges = [];
            lastData.discord_decoration_url = null;
          }
          updateAttrDiscordUI(lastData);
          updateDiscordStatusDisplay(lastData);
          renderBadgesDisplay(lastData);
          updatePfpDisplay(lastData);
          renderAttrDiscordBadges();
          return status;
        }

        async function startDiscordLink() {
          try {
            const r = await fetch("/api/discord/oauth-url", {
              credentials: "include",
            });
            if (!r.ok) {
              showEditorMessage("Discord linking unavailable", false);
              return;
            }
            const { url, configured, reason } = await r.json();
            if (!configured || !url) {
              showEditorMessage(reason || "Discord linking not configured", false);
              return;
            }
            const w = window.open(url, "discord_link", "width=520,height=720");
            if (!w) showEditorMessage("Allow popups to link Discord", false);
          } catch (e) {
            showEditorMessage("Discord link failed", false);
          }
        }

        async function unlinkDiscord() {
          try {
            const r = await fetch("/api/discord/account", {
              method: "DELETE",
              credentials: "include",
            });
            if (!r.ok) throw new Error(await r.text());
            if (lastData) {
              lastData.discord_linked = false;
              lastData.discord_status_text = "";
              lastData.discord_badges = [];
              lastData.discord_decoration_url = null;
            }
            updateAttrDiscordUI(lastData);
            updateDiscordStatusDisplay(lastData);
            renderBadgesDisplay(lastData);
            updatePfpDisplay(lastData);
            renderAttrDiscordBadges();
            showEditorMessage("Discord disconnected", true);
          } catch (e) {
            showEditorMessage("Unlink failed", false);
          }
        }

        const MOCK_DISCORD_BADGES = [
          {
            code: "nitro",
            label: "Discord Nitro",
            icon_url: "/static/discord-badges/discordnitro.svg",
          },
          {
            code: "hypesquad",
            label: "HypeSquad Brilliance",
            icon_url: "/static/discord-badges/hypesquadbrilliance.svg",
          },
          {
            code: "early_supporter",
            label: "Early Supporter",
            icon_url: "/static/discord-badges/discordearlysupporter.svg",
          },
          {
            code: "bug_hunter",
            label: "Bug Hunter",
            icon_url: "/static/discord-badges/discordbughunter1.svg",
          },
        ];
        const MOCK_STATUS_TEXTS = [
          "Building something new",
          "Open for collabs",
          "On the grind",
          "Ideas in motion",
          "Be right back",
        ];
        const MOCK_USERNAMES = ["DemoUser", "TemplateUser", "LinktreeFan"];

        function seededInt(seed, max) {
          const mod = Number(max) || 0;
          if (mod <= 0) return 0;
          const raw = parseInt(hashString(seed), 16);
          if (!Number.isFinite(raw)) return 0;
          return Math.abs(raw) % mod;
        }

        function seededRange(seed, min, max) {
          const lo = Number(min) || 0;
          const hi = Number(max) || 0;
          if (hi <= lo) return lo;
          return lo + seededInt(seed, hi - lo + 1);
        }

        function getDemoSeed(data, user) {
          const base = (data && (data.template_id || data.slug)) || "template";
          const userPart = user && user.id ? `u${user.id}` : "anon";
          return `${base}|${userPart}`;
        }

        function pickMockBadges(seed, count) {
          const list = MOCK_DISCORD_BADGES.slice();
          if (!list.length) return [];
          const take = Math.min(Math.max(1, count || 1), list.length);
          const start = seededInt(seed, list.length);
          const out = [];
          for (let i = 0; i < take; i += 1) {
            out.push(list[(start + i) % list.length]);
          }
          return out;
        }

        function buildMockDiscordData(seed) {
          const presenceOptions = ["online", "idle", "dnd"];
          const presence =
            presenceOptions[
              seededInt(`${seed}:presence`, presenceOptions.length)
            ];
          const statusText =
            MOCK_STATUS_TEXTS[
              seededInt(`${seed}:status`, MOCK_STATUS_TEXTS.length)
            ];
          const badgeCount = seededRange(`${seed}:badgeCount`, 2, 3);
          const badges = pickMockBadges(`${seed}:badges`, badgeCount);
          const decoration =
            badges[0] && badges[0].icon_url
              ? badges[0].icon_url
              : "/static/discord-badges/discordnitro.svg";
          return {
            linked: true,
            presence,
            status_text: statusText,
            badges,
            decoration_url: decoration,
          };
        }

        function buildMockVisitCount(seed) {
          return seededRange(`${seed}:visits`, 1200, 58900);
        }

        function buildMockUsername(seed) {
          return (
            MOCK_USERNAMES[seededInt(`${seed}:user`, MOCK_USERNAMES.length)] ||
            "DemoUser"
          );
        }

        function buildMockProfilePicture() {
          return "/static/icon.png";
        }

        async function fetchUserLinktreeForDemo(user, device) {
          if (!user) return null;
          const slug = String(user.linktree_slug || "").trim();
          if (slug) {
            try {
              const r = await fetch(
                `/api/linktrees/by-slug/${encodeURIComponent(
                  slug,
                )}/manage?device=${encodeURIComponent(device || "pc")}`,
                { credentials: "include" },
              );
              if (r.ok) return await r.json();
            } catch (_) {}
          }
          if (user.linktree_id) {
            try {
              const r = await fetch(
                `/api/linktrees/${encodeURIComponent(user.linktree_id)}/manage`,
                { credentials: "include" },
              );
              if (r.ok) return await r.json();
            } catch (_) {}
          }
          return null;
        }

        async function hydrateTemplateDemoData(baseData, device, userPromise) {
          if (!baseData || !baseData.is_template_demo)
            return { data: baseData, changed: false };
          const data = { ...baseData };
          let changed = false;
          let user = null;
          try {
            user = await userPromise.catch(() => null);
          } catch (_) {
            user = null;
          }
          if (user) currentUser = currentUser || user;

          const seed = getDemoSeed(data, user);
          const userName = user && user.username ? user.username : null;
          const userPfp =
            user && user.profile_picture ? user.profile_picture : null;

          if (userName) {
            if (data.user_username !== userName) {
              data.user_username = userName;
              changed = true;
            }
          } else {
            const mockName = buildMockUsername(seed);
            if (data.user_username !== mockName) {
              data.user_username = mockName;
              changed = true;
            }
          }

          const resolvedPfp = userPfp || buildMockProfilePicture();
          if (data.profile_picture !== resolvedPfp) {
            data.profile_picture = resolvedPfp;
            changed = true;
          }

          const needsDiscord =
            data.discord_frame_enabled ||
            data.discord_presence_enabled ||
            data.discord_status_enabled ||
            data.discord_badges_enabled;
          const needsVisit = !!data.show_visit_counter;

          let userLinktree = null;
          if ((needsDiscord || needsVisit) && user) {
            userLinktree = await fetchUserLinktreeForDemo(user, device);
          }

          if (needsVisit) {
            let visitCount = null;
            if (
              userLinktree &&
              Number.isFinite(Number(userLinktree.visit_count))
            ) {
              visitCount = Number(userLinktree.visit_count);
            }
            if (
              visitCount === null &&
              Number.isFinite(Number(data.visit_count)) &&
              Number(data.visit_count) > 0
            ) {
              visitCount = Number(data.visit_count);
            }
            if (visitCount === null) {
              visitCount = buildMockVisitCount(seed);
            }
            if (data.visit_count !== visitCount) {
              data.visit_count = visitCount;
              changed = true;
            }
          }

          if (needsDiscord) {
            let discordSource = null;
            if (userLinktree && userLinktree.discord_linked) {
              discordSource = {
                linked: true,
                presence: userLinktree.discord_presence,
                status_text: userLinktree.discord_status_text,
                badges: userLinktree.discord_badges,
                decoration_url: userLinktree.discord_decoration_url,
              };
            } else if (!userLinktree) {
              const status = await fetchDiscordStatus();
              if (status && status.linked) {
                discordSource = status;
              }
            }

            if (discordSource && discordSource.linked) {
              data.discord_linked = true;
              if (discordSource.presence)
                data.discord_presence = discordSource.presence;
              if (discordSource.status_text)
                data.discord_status_text = discordSource.status_text;
              if (Array.isArray(discordSource.badges))
                data.discord_badges = discordSource.badges;
              if (discordSource.decoration_url)
                data.discord_decoration_url = discordSource.decoration_url;
              changed = true;
            } else {
              const mock = buildMockDiscordData(seed);
              data.discord_linked = true;
              if (data.discord_presence_enabled && !data.discord_presence) {
                data.discord_presence = mock.presence;
              } else if (data.discord_presence_enabled) {
                data.discord_presence = data.discord_presence || mock.presence;
              }
              if (data.discord_status_enabled && !data.discord_status_text) {
                data.discord_status_text = mock.status_text;
              }
              if (data.discord_badges_enabled) {
                data.discord_badges = mock.badges;
              }
              if (data.discord_frame_enabled && !data.discord_decoration_url) {
                data.discord_decoration_url = mock.decoration_url;
              }
              changed = true;
            }
          }

          return { data, changed };
        }

        async function hydrateTemplateDemo(
          data,
          device,
          userPromise,
          preferLite,
        ) {
          if (!data || !data.is_template_demo) return data;
          try {
            const res = await hydrateTemplateDemoData(
              data,
              device,
              userPromise,
            );
            if (!res || !res.changed) return data;
            const next = res.data || data;
            lastData = next;
            renderTree(next, { preferLite, fromCache: true, device });
            return next;
          } catch (_) {
            return data;
          }
        }

        let currentUser = null;

        async function fetchSessionUser() {
          try {
            const r = await fetch("/api/auth/verify", {
              credentials: "include",
            });
            if (!r.ok) return null;
            const json = await r.json();
            currentUser = json && json.user ? json.user : null;
            return currentUser;
          } catch (_) {
            return null;
          }
        }

        function detectDevice(requestedDevice) {
          return requestedDevice === "mobile"
            ? "mobile"
            : requestedDevice === "pc"
              ? "pc"
              : window.matchMedia("(max-width: 720px)").matches
                ? "mobile"
                : "pc";
        }

        let visibilityHandlerAdded = false;

        async function fetchTreeData({ templateId, slug, device }) {
          if (templateId) {
            const r = await fetch(
              `/api/marketplace/templates/${encodeURIComponent(templateId)}`,
              { credentials: "include" },
            );
            if (!r.ok) return null;
            const tpl = await r.json();
            const variants = tpl.variants || [];
            const chosen =
              variants.find((v) => v.device_type === device) ||
              variants[0] ||
              tpl.data ||
              {};
            const data = { ...(chosen || {}) };
            data.slug = data.slug || tpl.name || "Template";
            data.device_type = data.device_type || device;
            data.user_username =
              data.user_username || tpl.owner_username || "Template";
            data.profile_picture =
              data.profile_picture || tpl.preview_image_url || null;
            data.template_id = tpl.id || templateId || null;
            data.is_template_demo = true;
            return data;
          }

          const r = await fetch(
            `/api/linktrees/${encodeURIComponent(slug)}?device=${device}`,
          );
          if (!r.ok) return null;
          return await r.json();
        }

        function showEditorMessage(text, ok = false) {
          const msg = document.getElementById("inspectorMsg");
          if (!msg) return;
          msg.textContent = text || "";
          msg.style.color = ok ? "#71e5d2" : "var(--muted)";
        }

        function showAttrMessage(el, text, ok = false) {
          if (!el) {
            showEditorMessage(text, ok);
            return;
          }
          el.textContent = text || "";
          el.style.color = ok ? "#71e5d2" : "var(--muted)";
        }

        function headers() {
          return { "Content-Type": "application/json" };
        }

        function slugFromQuery() {
          const params = new URLSearchParams(location.search);
          const slug = params.get("slug");
          return slug ? slug.trim() : "";
        }

        function deviceFromQuery() {
          const params = new URLSearchParams(location.search);
          const device = params.get("device");
          return device === "mobile" ? "mobile" : device === "pc" ? "pc" : "";
        }

        async function apiLoadTreeOwnerBySlug(slug, device = "pc") {
          const r = await fetch(
            `/api/linktrees/by-slug/${encodeURIComponent(
              slug,
            )}/manage?device=${encodeURIComponent(device)}`,
            { credentials: "include", headers: headers() },
          );
          if (!r.ok) return null;
          return await r.json();
        }

        async function apiCloneVariant(slug, targetDevice = "mobile") {
          const r = await fetch(
            `/api/linktrees/${encodeURIComponent(
              slug,
            )}/clone?target_device=${encodeURIComponent(targetDevice)}`,
            { method: "POST", headers: headers(), credentials: "include" },
          );
          if (!r.ok) throw new Error(await r.text());
          return await r.json();
        }

        async function saveCanvasLayout() {
          if (!linktreeId || !canvasLayout) {
            showEditorMessage("No linktree loaded.", false);
            return;
          }
          const activeDevice = currentDevice || "pc";
          const loadedDevice = (lastData && lastData.device_type) || null;
          if (!lastData || loadedDevice !== activeDevice) {
            showEditorMessage("Device variant is still loading.", false);
            return;
          }
          ensureCanvasLayoutSize(canvasLayout);
          const payload = {
            canvas_layout: {
              enabled: true,
              grid: 1,
              auto_fit_canvas_to_objects: !!canvasLayout.auto_fit_canvas_to_objects,
              auto_fit_element_backgrounds: !!canvasLayout.auto_fit_element_backgrounds,
              size: canvasLayout.size,
              plates: canvasLayout.plates,
              groups: canvasLayout.groups,
            },
          };
          if (metaDirtyFields.size && lastData) {
            metaDirtyFields.forEach((field) => {
              payload[field] = lastData[field] ?? null;
            });
          }
          try {
            const r = await fetch(`/api/linktrees/${linktreeId}`, {
              method: "PATCH",
              credentials: "include",
              headers: headers(),
              body: JSON.stringify(payload),
            });
            if (!r.ok) {
              showEditorMessage("Save failed.", false);
              return;
            }
            canvasDirty = false;
            metaDirtyFields = new Set();
            showEditorMessage("Canvas saved.", true);
          } catch (err) {
            showEditorMessage("Save failed.", false);
          }
        }

        function bindInspectorEvents() {
          const deviceSelect = document.getElementById("inDevice");
          const canvasW = document.getElementById("inCanvasW");
          const canvasH = document.getElementById("inCanvasH");
          const canvasAutoFit = document.getElementById("inCanvasAutoFitObjects");
          const canvasAutoFitElementBgs = document.getElementById(
            "inCanvasAutoFitElementBackgrounds",
          );
          const selX = document.getElementById("inSelX");
          const selY = document.getElementById("inSelY");
          const selW = document.getElementById("inSelW");
          const selH = document.getElementById("inSelH");
          const selGroup = document.getElementById("inSelGroup");
          const attrNameColor = document.getElementById("inAttrNameColor");
          const attrNameEffect = document.getElementById("inAttrNameEffect");
          const attrNameFont = document.getElementById("inAttrNameFont");
          const attrDisplayName = document.getElementById("inAttrDisplayName");
          const attrCustomName = document.getElementById("inAttrCustomName");
          const attrDiscordStatusToggle = document.getElementById(
            "inAttrDiscordStatus",
          );
          const attrQuote = document.getElementById("inAttrQuote");
          const attrQuoteTyping = document.getElementById("inAttrQuoteTyping");
          const attrQuoteAlt1 = document.getElementById("inAttrQuoteAlt1");
          const attrQuoteAlt2 = document.getElementById("inAttrQuoteAlt2");
          const attrQuoteSpeed = document.getElementById("inAttrQuoteSpeed");
          const attrQuotePause = document.getElementById("inAttrQuotePause");
          const attrQuoteColor = document.getElementById("inAttrQuoteColor");
          const attrQuoteEffect = document.getElementById("inAttrQuoteEffect");
          const attrQuoteFont = document.getElementById("inAttrQuoteFont");
          const attrQuoteSize = document.getElementById("inAttrQuoteSize");
          const attrQuoteStrength = document.getElementById(
            "inAttrQuoteEffectStrength",
          );
          const attrLocation = document.getElementById("inAttrLocation");
          const attrLocationColor = document.getElementById("inAttrLocationColor");
          const attrDiscordBadgesToggle = document.getElementById(
            "inAttrDiscordBadges",
          );
          const attrSongFile = document.getElementById("inAttrSongFile");
          const attrSongIconFile = document.getElementById("inAttrSongIconFile");
          const attrSong = document.getElementById("inAttrSong");
          const attrSongName = document.getElementById("inAttrSongName");
          const attrSongIcon = document.getElementById("inAttrSongIcon");
          const attrAudioPlayer = document.getElementById("inAttrAudioPlayer");
          const attrAudioBgColor = document.getElementById("inAttrAudioBgColor");
          const attrAudioBgAlpha = document.getElementById("inAttrAudioBgAlpha");
          const attrAudioTextColor = document.getElementById("inAttrAudioTextColor");
          const attrAudioAccentColor = document.getElementById(
            "inAttrAudioAccentColor",
          );
          const attrPfpFile = document.getElementById("inAttrPfpFile");
          const attrLinktreePfp = document.getElementById("inAttrLinktreePfp");
          const btnRemovePfp = document.getElementById("btnAttrRemovePfp");
          const attrDiscordFrame = document.getElementById("inAttrDiscordFrame");
          const attrDiscordPresence = document.getElementById(
            "inAttrDiscordPresence",
          );
          const btnDiscordLink = document.getElementById("btnAttrDiscordLink");
          const btnDiscordUnlink = document.getElementById("btnAttrDiscordUnlink");
          const btnRemoveSong = document.getElementById("btnAttrRemoveSong");
          const btnRemoveSongIcon = document.getElementById(
            "btnAttrRemoveSongIcon",
          );
          const attrLinkColor = document.getElementById("inAttrLinkColor");
          const attrLinkBgColor = document.getElementById("inAttrLinkBgColor");
          const attrLinkBgAlpha = document.getElementById("inAttrLinkBgAlpha");
          const attrLinkColumns = document.getElementById("inAttrLinkColumns");
          const attrLinkIconsOnly = document.getElementById(
            "inAttrLinkIconsOnly",
          );
          const attrLinkIconsOnlySize = document.getElementById(
            "inAttrLinkIconsOnlySize",
          );
          const attrLinkIconsOnlyGap = document.getElementById(
            "inAttrLinkIconsOnlyGap",
          );
          const attrLinkIconsOnlyGrouped = document.getElementById(
            "inAttrLinkIconsOnlyGrouped",
          );
          const attrLinkIconsOnlyDirection = document.getElementById(
            "inAttrLinkIconsOnlyDirection",
          );
          const attrLinkUrl = document.getElementById("inAttrLinkUrl");
          const attrLinkLabel = document.getElementById("inAttrLinkLabel");
          const attrLinkIconFile = document.getElementById("inAttrLinkIconFile");
          const attrLinkIcon = document.getElementById("inAttrLinkIcon");
          const btnRemoveLinkIcon = document.getElementById(
            "btnAttrRemoveLinkIcon",
          );
          const attrLinkActive = document.getElementById("inAttrLinkActive");
          const btnAddLink = document.getElementById("btnAttrAddLink");
          const attrShowCounter = document.getElementById("inAttrShowCounter");
          const attrCounterColor = document.getElementById("inAttrCounterColor");
          const attrCounterBgColor = document.getElementById("inAttrCounterBgColor");
          const attrCounterBgAlpha = document.getElementById(
            "inAttrCounterBgAlpha",
          );
          const saveBtn = document.getElementById("btnSaveCanvas");
          const resetBtn = document.getElementById("btnCanvasReset");

          if (deviceSelect) {
            deviceSelect.addEventListener("change", async (e) => {
              currentDevice = e.target.value === "mobile" ? "mobile" : "pc";
              await loadTree();
            });
          }
          if (canvasW) {
            canvasW.addEventListener("change", (e) => {
              if (!canvasLayout) return;
              const raw = parseInt(e.target.value || "0", 10);
              if (!Number.isFinite(raw)) return;
              canvasLayout.size = canvasLayout.size || { w: raw, h: CANVAS_SIZE_MIN_H };
              canvasLayout.size.w = Math.min(
                CANVAS_PLATE_MAX_W,
                Math.max(CANVAS_SIZE_MIN_W, raw),
              );
              canvasDirty = true;
              ensureCanvasLayoutSize(canvasLayout);
              updateCanvasCardSize(canvasLayout);
              syncCanvasControls();
            });
          }
          if (canvasH) {
            canvasH.addEventListener("change", (e) => {
              if (!canvasLayout) return;
              const raw = parseInt(e.target.value || "0", 10);
              if (!Number.isFinite(raw)) return;
              canvasLayout.size = canvasLayout.size || { w: CANVAS_SIZE_MIN_W, h: raw };
              canvasLayout.size.h = Math.min(
                CANVAS_PLATE_MAX_H,
                Math.max(CANVAS_SIZE_MIN_H, raw),
              );
              canvasDirty = true;
              ensureCanvasLayoutSize(canvasLayout);
              updateCanvasCardSize(canvasLayout);
              syncCanvasControls();
            });
          }
          if (canvasAutoFit) {
            canvasAutoFit.addEventListener("change", (e) => {
              if (!canvasLayout) return;
              canvasLayout.auto_fit_canvas_to_objects = !!e.target.checked;
              canvasDirty = true;
              if (canvasLayout.auto_fit_canvas_to_objects) {
                ensureCanvasLayoutSize(canvasLayout);
                updateCanvasCardSize(canvasLayout);
              }
              syncCanvasControls();
            });
          }
          if (canvasAutoFitElementBgs) {
            canvasAutoFitElementBgs.addEventListener("change", (e) => {
              if (!canvasLayout) return;
              canvasLayout.auto_fit_element_backgrounds = !!e.target.checked;
              canvasDirty = true;
              SECTION_ORDER_DEFAULT.forEach((key) => {
                const plate = canvasLayout.plates?.[key];
                if (!plate) return;
                applyPlateBackgroundFitMode(key, plate);
              });
              syncCanvasControls();
            });
          }

          const updateSelectionFromInputs = () => {
            if (!canvasLayout || !canvasSelection) return;
            if (canvasSelection.type === "group") {
              let activeGroupId = canvasSelection.id;
              if (selGroup) {
                const nextGroupId = selGroup.value.trim();
                if (nextGroupId && nextGroupId !== activeGroupId) {
                  const renamed = renameCanvasGroup(activeGroupId, nextGroupId);
                  if (!renamed) {
                    selGroup.value = activeGroupId;
                  } else {
                    activeGroupId = nextGroupId;
                  }
                } else if (!nextGroupId) {
                  selGroup.value = activeGroupId;
                }
              }
              const group = canvasLayout.groups?.[activeGroupId];
              if (!group) return;
              const nextX = parseInt(selX.value || group.x, 10);
              const nextY = parseInt(selY.value || group.y, 10);
              if (Number.isFinite(nextX)) group.x = nextX;
              if (Number.isFinite(nextY)) group.y = nextY;
              canvasDirty = true;
              const groupEl = document.querySelector(
                `.plate-group[data-group-id="${activeGroupId}"]`,
              );
              if (groupEl) {
                groupEl.style.transform = `translate(${group.x}px, ${group.y}px)`;
              }
              refreshGroupOptions();
              syncSelectionPanel();
              return;
            }
            const key = canvasSelection.key;
            const plate = canvasLayout.plates?.[key];
            if (!plate) return;
            const nextX = parseInt(selX.value || plate.x, 10);
            const nextY = parseInt(selY.value || plate.y, 10);
            const nextW = parseInt(selW.value || plate.w, 10);
            const nextH = parseInt(selH.value || plate.h, 10);
            if (Number.isFinite(nextX)) plate.x = nextX;
            if (Number.isFinite(nextY)) plate.y = nextY;
            if (Number.isFinite(nextW)) {
              plate.w = Math.min(
                CANVAS_PLATE_MAX_W,
                Math.max(CANVAS_PLATE_MIN_W, nextW),
              );
            }
            if (Number.isFinite(nextH)) {
              plate.h = Math.min(
                CANVAS_PLATE_MAX_H,
                Math.max(CANVAS_PLATE_MIN_H, nextH),
              );
            }
            if (selGroup) {
              assignPlateToGroup(key, selGroup.value);
            }
            canvasDirty = true;
            applyPlateStyles(key, plate);
            if (plate.group) {
              const groupEl = document.querySelector(
                `.plate-group[data-group-id="${plate.group}"]`,
              );
              updateGroupBounds(groupEl, plate.group, canvasLayout);
            }
            ensureCanvasLayoutSize(canvasLayout);
            updateCanvasCardSize(canvasLayout);
            syncCanvasControls();
          };

          if (selX) selX.addEventListener("change", updateSelectionFromInputs);
          if (selY) selY.addEventListener("change", updateSelectionFromInputs);
          if (selW) selW.addEventListener("change", updateSelectionFromInputs);
          if (selH) selH.addEventListener("change", updateSelectionFromInputs);
          if (selGroup) selGroup.addEventListener("change", updateSelectionFromInputs);
          const updateNameAttributes = () => {
            if (
              !lastData ||
              !canvasSelection ||
              canvasSelection.type !== "plate" ||
              canvasSelection.key !== "name"
            )
              return;
            const mode = attrDisplayName?.value || lastData.display_name_mode || "slug";
            if (attrDisplayName) {
              lastData.display_name_mode = mode;
              markMetaDirty("display_name_mode");
            }
            if (attrCustomName) {
              const custom = attrCustomName.value.trim();
              lastData.custom_display_name =
                mode === "custom" ? custom || null : null;
              attrCustomName.disabled = mode !== "custom";
              markMetaDirty("custom_display_name");
            }
            const nextColor = sanitizeHexColor(attrNameColor?.value);
            const nextEffect = normalizeEffectName(attrNameEffect?.value);
            const nextFont = normalizeFontFamily(attrNameFont?.value);
            lastData.name_color = nextColor || null;
            lastData.name_effect = nextEffect;
            lastData.name_font_family = nextFont;
            markMetaDirty("name_color");
            markMetaDirty("name_effect");
            markMetaDirty("name_font_family");
            applyTextColors(lastData);
            applyNameStyles(lastData);
          };
          const updateQuoteAttributes = () => {
            if (
              !lastData ||
              !canvasSelection ||
              canvasSelection.type !== "plate" ||
              canvasSelection.key !== "quote"
            )
              return;
            const texts = collectAttrQuoteTexts();
            lastData.quote = texts[0] || null;
            lastData.quote_typing_texts = texts;
            lastData.quote_typing_enabled = !!attrQuoteTyping?.checked;
            const speedRaw = parseInt(attrQuoteSpeed?.value ?? "", 10);
            const pauseRaw = parseInt(attrQuotePause?.value ?? "", 10);
            const sizeRaw = parseInt(attrQuoteSize?.value ?? "", 10);
            const strengthRaw = parseInt(attrQuoteStrength?.value ?? "", 10);
            lastData.quote_typing_speed = Number.isFinite(speedRaw)
              ? Math.min(200, Math.max(20, speedRaw))
              : 42;
            lastData.quote_typing_pause = Number.isFinite(pauseRaw)
              ? Math.min(10000, Math.max(200, pauseRaw))
              : 1200;
            lastData.quote_font_size = Number.isFinite(sizeRaw)
              ? Math.min(40, Math.max(10, sizeRaw))
              : 15;
            lastData.quote_effect_strength = Number.isFinite(strengthRaw)
              ? Math.min(100, Math.max(0, strengthRaw))
              : 70;
            const nextColor = sanitizeHexColor(attrQuoteColor?.value);
            const nextEffect = normalizeEffectName(attrQuoteEffect?.value);
            const nextFont = normalizeFontFamily(attrQuoteFont?.value);
            lastData.quote_color = nextColor || null;
            lastData.quote_effect = nextEffect;
            lastData.quote_font_family = nextFont;
            markMetaDirty("quote");
            markMetaDirty("quote_typing_texts");
            markMetaDirty("quote_typing_enabled");
            markMetaDirty("quote_typing_speed");
            markMetaDirty("quote_typing_pause");
            markMetaDirty("quote_font_size");
            markMetaDirty("quote_effect_strength");
            markMetaDirty("quote_color");
            markMetaDirty("quote_effect");
            markMetaDirty("quote_font_family");
            applyTextColors(lastData);
            applyQuoteEffectStrength(lastData);
            applyQuoteStyles(lastData);
            const hasQuote = updateQuoteDisplay(lastData);
            const quoteEl = document.getElementById("quote");
            if (quoteEl) {
              quoteEl.classList.toggle("hidden", !hasQuote);
            }
          };
          const updateLocationAttributes = () => {
            if (
              !lastData ||
              !canvasSelection ||
              canvasSelection.type !== "plate" ||
              canvasSelection.key !== "location"
            )
              return;
            const text = attrLocation?.value.trim() || "";
            const color = sanitizeHexColor(attrLocationColor?.value);
            lastData.location = text || null;
            lastData.location_color = color || null;
            markMetaDirty("location");
            markMetaDirty("location_color");
            applyTextColors(lastData);
            updateLocationDisplay(lastData);
          };
          const updateDiscordStatusAttributes = () => {
            if (
              !lastData ||
              !canvasSelection ||
              canvasSelection.type !== "plate" ||
              canvasSelection.key !== "discord_status"
            )
              return;
            lastData.discord_status_enabled = !!attrDiscordStatusToggle?.checked;
            markMetaDirty("discord_status_enabled");
            updateDiscordStatusDisplay(lastData);
          };
          const updatePfpAttributes = () => {
            if (
              !lastData ||
              !canvasSelection ||
              canvasSelection.type !== "plate" ||
              canvasSelection.key !== "pfp"
            )
              return;
            if (attrDiscordFrame) {
              lastData.discord_frame_enabled = !!attrDiscordFrame.checked;
              markMetaDirty("discord_frame_enabled");
            }
            if (attrDiscordPresence) {
              lastData.discord_presence_enabled = !!attrDiscordPresence.checked;
              markMetaDirty("discord_presence_enabled");
            }
            updatePfpDisplay(lastData);
            updateDiscordStatusDisplay(lastData);
          };
          const updateBadgesAttributes = () => {
            if (
              !lastData ||
              !canvasSelection ||
              canvasSelection.type !== "plate" ||
              canvasSelection.key !== "badges"
            )
              return;
            lastData.discord_badges_enabled = !!attrDiscordBadgesToggle?.checked;
            markMetaDirty("discord_badges_enabled");
            renderBadgesDisplay(lastData);
          };
          const updateAudioAttributes = () => {
            if (
              !lastData ||
              !canvasSelection ||
              canvasSelection.type !== "plate" ||
              canvasSelection.key !== "audio"
            )
              return;
            lastData.show_audio_player = !!attrAudioPlayer?.checked;
            lastData.audio_player_bg_color =
              sanitizeHexColor(attrAudioBgColor?.value) || null;
            lastData.audio_player_bg_alpha = clampPercent(
              attrAudioBgAlpha?.value,
              DEFAULT_AUDIO_BG_ALPHA,
            );
            lastData.audio_player_text_color =
              sanitizeHexColor(attrAudioTextColor?.value) || null;
            lastData.audio_player_accent_color =
              sanitizeHexColor(attrAudioAccentColor?.value) || null;
            markMetaDirty("show_audio_player");
            markMetaDirty("audio_player_bg_color");
            markMetaDirty("audio_player_bg_alpha");
            markMetaDirty("audio_player_text_color");
            markMetaDirty("audio_player_accent_color");
            applyAudioPlayerStyles(lastData);
            const songUrl = safeMediaUrl(lastData.song_url);
            const showPlayer = !!lastData.show_audio_player && !!songUrl;
            if (audioPlayer) audioPlayer.classList.toggle("hidden", !showPlayer);
          };
          const updateLinkStyleAttributes = () => {
            if (
              !lastData ||
              !canvasSelection ||
              canvasSelection.type !== "plate" ||
              canvasSelection.key !== "links"
            )
              return;
            lastData.link_color = sanitizeHexColor(attrLinkColor?.value) || null;
            lastData.link_bg_color = sanitizeHexColor(attrLinkBgColor?.value) || null;
            lastData.link_bg_alpha = clampPercent(attrLinkBgAlpha?.value, 100);
            lastData.link_columns = normalizeLinkColumns(
              attrLinkColumns?.value,
              null,
            );
            lastData.link_icons_only = !!attrLinkIconsOnly?.checked;
            lastData.link_icons_only_size = normalizeLinkIconsOnlySize(
              attrLinkIconsOnlySize?.value,
            );
            lastData.link_icons_only_gap = normalizeLinkIconsOnlyGap(
              attrLinkIconsOnlyGap?.value,
            );
            lastData.link_icons_only_grouped =
              (attrLinkIconsOnlyGrouped?.value || "separate") === "grouped";
            lastData.link_icons_only_direction = normalizeLinkIconsOnlyDirection(
              attrLinkIconsOnlyDirection?.value,
            );
            markMetaDirty("link_color");
            markMetaDirty("link_bg_color");
            markMetaDirty("link_bg_alpha");
            markMetaDirty("link_columns");
            markMetaDirty("link_icons_only");
            markMetaDirty("link_icons_only_size");
            markMetaDirty("link_icons_only_gap");
            markMetaDirty("link_icons_only_grouped");
            markMetaDirty("link_icons_only_direction");
            applyLinkStyles(
              lastData.link_color,
              lastData.link_bg_color,
              lastData.link_bg_alpha,
            );
            applyLinkLayout(lastData, {
              isMobile: currentDevice === "mobile",
              wantsWide: document.getElementById("card")?.classList.contains("wide"),
            });
            renderLinksDisplay(lastData);
          };
          const updateCounterAttributes = () => {
            if (
              !lastData ||
              !canvasSelection ||
              canvasSelection.type !== "plate" ||
              canvasSelection.key !== "visit_counter"
            )
              return;
            lastData.show_visit_counter = !!attrShowCounter?.checked;
            lastData.visit_counter_color =
              sanitizeHexColor(attrCounterColor?.value) || null;
            lastData.visit_counter_bg_color =
              sanitizeHexColor(attrCounterBgColor?.value) || null;
            lastData.visit_counter_bg_alpha = clampPercent(
              attrCounterBgAlpha?.value,
              20,
            );
            markMetaDirty("show_visit_counter");
            markMetaDirty("visit_counter_color");
            markMetaDirty("visit_counter_bg_color");
            markMetaDirty("visit_counter_bg_alpha");
            updateVisitCounterDisplay(lastData);
          };
          if (attrDisplayName)
            attrDisplayName.addEventListener("change", updateNameAttributes);
          if (attrCustomName)
            attrCustomName.addEventListener("input", updateNameAttributes);
          if (attrNameColor)
            attrNameColor.addEventListener("input", updateNameAttributes);
          if (attrNameEffect)
            attrNameEffect.addEventListener("change", updateNameAttributes);
          if (attrNameFont)
            attrNameFont.addEventListener("change", updateNameAttributes);
          if (attrDiscordStatusToggle)
            attrDiscordStatusToggle.addEventListener(
              "change",
              updateDiscordStatusAttributes,
            );
          if (attrQuote) attrQuote.addEventListener("input", updateQuoteAttributes);
          if (attrQuoteTyping)
            attrQuoteTyping.addEventListener("change", () => {
              toggleAttrQuoteTypingFields();
              updateQuoteAttributes();
            });
          if (attrQuoteAlt1)
            attrQuoteAlt1.addEventListener("input", updateQuoteAttributes);
          if (attrQuoteAlt2)
            attrQuoteAlt2.addEventListener("input", updateQuoteAttributes);
          if (attrQuoteSpeed)
            attrQuoteSpeed.addEventListener("change", updateQuoteAttributes);
          if (attrQuotePause)
            attrQuotePause.addEventListener("change", updateQuoteAttributes);
          if (attrQuoteColor)
            attrQuoteColor.addEventListener("input", updateQuoteAttributes);
          if (attrQuoteEffect)
            attrQuoteEffect.addEventListener("change", updateQuoteAttributes);
          if (attrQuoteFont)
            attrQuoteFont.addEventListener("change", updateQuoteAttributes);
          if (attrQuoteSize)
            attrQuoteSize.addEventListener("change", updateQuoteAttributes);
          if (attrQuoteStrength)
            attrQuoteStrength.addEventListener("change", updateQuoteAttributes);
          if (attrLocation)
            attrLocation.addEventListener("input", updateLocationAttributes);
          if (attrLocationColor)
            attrLocationColor.addEventListener("input", updateLocationAttributes);
          if (attrDiscordBadgesToggle)
            attrDiscordBadgesToggle.addEventListener(
              "change",
              updateBadgesAttributes,
            );
          if (attrAudioPlayer)
            attrAudioPlayer.addEventListener("change", updateAudioAttributes);
          if (attrAudioBgColor)
            attrAudioBgColor.addEventListener("input", updateAudioAttributes);
          if (attrAudioBgAlpha)
            attrAudioBgAlpha.addEventListener("change", updateAudioAttributes);
          if (attrAudioTextColor)
            attrAudioTextColor.addEventListener("input", updateAudioAttributes);
          if (attrAudioAccentColor)
            attrAudioAccentColor.addEventListener("input", updateAudioAttributes);
          if (attrDiscordFrame)
            attrDiscordFrame.addEventListener("change", updatePfpAttributes);
          if (attrDiscordPresence)
            attrDiscordPresence.addEventListener("change", updatePfpAttributes);
          if (attrLinkColor)
            attrLinkColor.addEventListener("input", updateLinkStyleAttributes);
          if (attrLinkBgColor)
            attrLinkBgColor.addEventListener("input", updateLinkStyleAttributes);
          if (attrLinkBgAlpha)
            attrLinkBgAlpha.addEventListener("change", updateLinkStyleAttributes);
          if (attrLinkColumns)
            attrLinkColumns.addEventListener("change", updateLinkStyleAttributes);
          if (attrLinkIconsOnly)
            attrLinkIconsOnly.addEventListener("change", updateLinkStyleAttributes);
          if (attrLinkIconsOnlySize)
            attrLinkIconsOnlySize.addEventListener("change", updateLinkStyleAttributes);
          if (attrLinkIconsOnlyGap)
            attrLinkIconsOnlyGap.addEventListener("change", updateLinkStyleAttributes);
          if (attrLinkIconsOnlyGrouped)
            attrLinkIconsOnlyGrouped.addEventListener(
              "change",
              updateLinkStyleAttributes,
            );
          if (attrLinkIconsOnlyDirection)
            attrLinkIconsOnlyDirection.addEventListener(
              "change",
              updateLinkStyleAttributes,
            );
          if (attrShowCounter)
            attrShowCounter.addEventListener("change", updateCounterAttributes);
          if (attrCounterColor)
            attrCounterColor.addEventListener("input", updateCounterAttributes);
          if (attrCounterBgColor)
            attrCounterBgColor.addEventListener("input", updateCounterAttributes);
          if (attrCounterBgAlpha)
            attrCounterBgAlpha.addEventListener("change", updateCounterAttributes);

          if (attrPfpFile) {
            attrPfpFile.addEventListener("change", async () => {
              if (!lastData) return;
              try {
                const res = await uploadFile(
                  "inAttrPfpFile",
                  `/api/users/me/linktree-pfp?device=${encodeURIComponent(
                    currentDevice || "pc",
                  )}`,
                );
                const url = res?.url || "";
                if (attrLinktreePfp) attrLinktreePfp.value = url;
                lastData.linktree_profile_picture = url || null;
                markMetaDirty("linktree_profile_picture");
                setUploadStatus(
                  "attrPfpStatus",
                  url,
                  "Using your account profile picture.",
                );
                updatePfpDisplay(lastData);
                showEditorMessage("Profile picture uploaded", true);
              } catch (e) {
                showEditorMessage("Profile picture upload failed", false);
              }
            });
          }
          if (btnRemovePfp) {
            btnRemovePfp.addEventListener("click", () => {
              if (!lastData) return;
              if (attrLinktreePfp) attrLinktreePfp.value = "";
              if (attrPfpFile) attrPfpFile.value = "";
              lastData.linktree_profile_picture = null;
              markMetaDirty("linktree_profile_picture");
              setUploadStatus(
                "attrPfpStatus",
                "",
                "Using your account profile picture.",
              );
              updatePfpDisplay(lastData);
              showEditorMessage("Profile picture removed", true);
            });
          }
          if (btnDiscordLink)
            btnDiscordLink.addEventListener("click", startDiscordLink);
          if (btnDiscordUnlink)
            btnDiscordUnlink.addEventListener("click", unlinkDiscord);

          if (attrSongFile) {
            attrSongFile.addEventListener("change", async () => {
              if (!lastData) return;
              try {
                const res = await uploadFile(
                  "inAttrSongFile",
                  `/api/users/me/song?device=${encodeURIComponent(
                    currentDevice || "pc",
                  )}`,
                );
                const url = res?.url || "";
                const name = res?.name || "";
                if (attrSong) attrSong.value = url;
                if (attrSongName) attrSongName.value = name;
                lastData.song_url = url || null;
                lastData.song_name = name || null;
                markMetaDirty("song_url");
                markMetaDirty("song_name");
                setUploadStatus("attrSongStatus", url, "No song uploaded yet.", name);
                refreshTreeFromData();
                showEditorMessage("Song uploaded", true);
              } catch (e) {
                showEditorMessage("Song upload failed", false);
              }
            });
          }
          if (btnRemoveSong) {
            btnRemoveSong.addEventListener("click", () => {
              if (!lastData) return;
              if (attrSong) attrSong.value = "";
              if (attrSongName) attrSongName.value = "";
              if (attrSongFile) attrSongFile.value = "";
              lastData.song_url = null;
              lastData.song_name = null;
              markMetaDirty("song_url");
              markMetaDirty("song_name");
              setUploadStatus("attrSongStatus", "", "No song uploaded yet.");
              refreshTreeFromData();
              showEditorMessage("Song removed", true);
            });
          }
          if (attrSongIconFile) {
            attrSongIconFile.addEventListener("change", async () => {
              if (!lastData) return;
              try {
                const res = await uploadFile(
                  "inAttrSongIconFile",
                  `/api/users/me/songicon?device=${encodeURIComponent(
                    currentDevice || "pc",
                  )}`,
                );
                const url = res?.url || "";
                if (attrSongIcon) attrSongIcon.value = url;
                lastData.song_icon_url = url || null;
                markMetaDirty("song_icon_url");
                setUploadStatus("attrSongIconStatus", url, "No icon uploaded.");
                refreshTreeFromData();
                showEditorMessage("Song icon uploaded", true);
              } catch (e) {
                showEditorMessage("Song icon upload failed", false);
              }
            });
          }
          if (btnRemoveSongIcon) {
            btnRemoveSongIcon.addEventListener("click", () => {
              if (!lastData) return;
              if (attrSongIcon) attrSongIcon.value = "";
              if (attrSongIconFile) attrSongIconFile.value = "";
              lastData.song_icon_url = null;
              markMetaDirty("song_icon_url");
              setUploadStatus("attrSongIconStatus", "", "No icon uploaded.");
              refreshTreeFromData();
              showEditorMessage("Song icon removed", true);
            });
          }
          if (attrLinkIconFile) {
            attrLinkIconFile.addEventListener("change", async () => {
              try {
                const url = await uploadInlineFile(
                  attrLinkIconFile,
                  "/api/users/me/linkicon",
                );
                if (!url) return;
                if (attrLinkIcon) attrLinkIcon.value = url;
                setUploadStatus("attrLinkIconStatus", url, "No icon uploaded.");
                showAttrMessage(
                  document.getElementById("attrLinksMsg"),
                  "Icon uploaded",
                  true,
                );
              } catch (e) {
                showAttrMessage(
                  document.getElementById("attrLinksMsg"),
                  "Icon upload failed",
                  false,
                );
              }
            });
          }
          if (btnRemoveLinkIcon) {
            btnRemoveLinkIcon.addEventListener("click", () => {
              if (attrLinkIcon) attrLinkIcon.value = "";
              if (attrLinkIconFile) attrLinkIconFile.value = "";
              setUploadStatus("attrLinkIconStatus", "", "No icon uploaded.");
            });
          }
          if (btnAddLink) {
            btnAddLink.addEventListener("click", async () => {
              const url = attrLinkUrl?.value.trim() || "";
              const label = attrLinkLabel?.value.trim() || null;
              const iconUrl = attrLinkIcon?.value.trim() || null;
              const isActive = (attrLinkActive?.value || "true") === "true";
              if (!url) {
                showAttrMessage(
                  document.getElementById("attrLinksMsg"),
                  "URL is required",
                  false,
                );
                return;
              }
              const link = await apiAddLink({
                url,
                label,
                icon_url: iconUrl,
                is_active: isActive,
              });
              if (!link) return;
              if (lastData) {
                lastData.links = Array.isArray(lastData.links)
                  ? lastData.links.concat([link])
                  : [link];
              }
              renderLinksDisplay(lastData);
              renderAttrLinks(lastData.links || []);
              if (attrLinkUrl) attrLinkUrl.value = "";
              if (attrLinkLabel) attrLinkLabel.value = "";
              if (attrLinkIcon) attrLinkIcon.value = "";
              if (attrLinkIconFile) attrLinkIconFile.value = "";
              setUploadStatus("attrLinkIconStatus", "", "No icon uploaded.");
              if (attrLinkActive) attrLinkActive.value = "true";
            });
          }
          if (saveBtn) saveBtn.addEventListener("click", saveCanvasLayout);
          if (resetBtn) {
            resetBtn.addEventListener("click", () => {
              if (!lastData) return;
              const card = document.getElementById("card");
              if (!card) return;
              resetCanvasLayout(card);
              const hasSideBySide = applySectionOrder(lastData.section_order);
              if (hasSideBySide) {
                card.classList.add("wide");
              } else {
                card.classList.remove("wide");
              }
              capturePfpOffsets();
              canvasLayout = buildCanvasLayoutFromDom(lastData.section_order);
              canvasDirty = true;
              clearCanvasSelection();
              applySectionLayout(lastData.section_order, lastData.canvas_layout, {
                isMobile: currentDevice === "mobile",
              });
              syncCanvasControls();
              showEditorMessage("Canvas reset to linktree layout.", true);
            });
          }
        }

        function renderTree(
          data,
          {
            preferLite = shouldUseLiteMedia(),
            fromCache = false,
            device = detectDevice(),
          } = {},
        ) {
          if (!data) return;
          lastData = data;
          lastMediaMode = preferLite ? "lite" : "full";
          lastDevice = device;
          const isMobile = device === "mobile";
          let normalizedLayout = normalizeCanvasLayout(
            data.canvas_layout,
            data.section_order,
          );
          const hasSavedLayout = !!normalizedLayout;
          if (EDITOR_MODE) {
            if (!canvasLayout || !canvasDirty) {
              canvasLayout = normalizedLayout;
              canvasDirty = false;
            }
            if (canvasLayout) ensureCanvasLayoutSize(canvasLayout);
          }
          const layoutResult = applySectionLayout(
            data.section_order,
            data.canvas_layout,
            { isMobile },
          );
          const hasSideBySide = layoutResult.hasSideBySide;
          let usedCanvas = layoutResult.usedCanvas;
          if (EDITOR_MODE) {
            if (!hasSavedLayout && !canvasDirty && !usedCanvas) {
              canvasLayout = buildCanvasLayoutFromDom(data.section_order);
              canvasDirty = true;
              const reapply = applySectionLayout(
                data.section_order,
                data.canvas_layout,
                {
                  isMobile,
                },
              );
              usedCanvas = reapply.usedCanvas;
            }
            if (canvasLayout) {
              updateCanvasGridStyle(canvasLayout);
              updateCanvasCardSize(canvasLayout);
              syncCanvasControls();
            }
            if (usedCanvas && canvasLayout) {
              requestAnimationFrame(() => {
                ensurePlateSizesFromDom();
                syncSelectionPanel();
              });
            } else {
              requestAnimationFrame(() => {
                capturePfpOffsets();
              });
            }
            bindCanvasStageEvents();
          }
          let needsGate = false;

          const bgSource = pickBackgroundSource(data, preferLite);
          const bgUrlNext = bgSource.url || "";
          const bgIsVideoNext = bgSource.isVideo;
          applyMeta(data, { bgUrl: bgUrlNext, bgIsVideo: bgIsVideoNext });
          const songUrlNext = safeMediaUrl(data.song_url);
          const songIconUrlNext = safeMediaUrl(data.song_icon_url);
          const showAudioPlayer = !!data.show_audio_player && !!songUrlNext;
          const cursorUrl = safeMediaUrl(data.cursor_url);
          const bgSig = hashString(
            `bg|${bgIsVideoNext ? "v" : "i"}|${bgUrlNext}`,
          );
          const audioSig = hashString(
            `audio|${songUrlNext}|${songIconUrlNext}|${
              showAudioPlayer ? "1" : "0"
            }`,
          );
          const cursorSig = hashString(
            `cursor|${cursorUrl}|${data.cursor_effect || "none"}|${
              isMobile ? "m" : "d"
            }|${data.cursor_effect_color || ""}|${
              data.cursor_effect_alpha ?? ""
            }`,
          );
          const mediaSig = hashString(`${bgSig}|${audioSig}|${cursorSig}`);
          const bgChanged = bgSig !== lastBgSig;
          const audioChanged = audioSig !== lastAudioSig;
          gateCacheKey = `taoma:linktree:gate:${mediaSig}`;
          const gateDismissed = (() => {
            try {
              return sessionStorage.getItem(gateCacheKey) === "1";
            } catch (_) {
              return false;
            }
          })();

          const bgEl = document.getElementById("bg");
          if (bgChanged) {
            bgVideo = null;
            if (bgEl) {
              bgEl.textContent = "";
              if (bgUrlNext) {
                if (bgIsVideoNext) {
                  const video = document.createElement("video");
                  video.id = "bgvid";
                  video.src = bgUrlNext;
                  video.autoplay = false;
                  video.muted = true;
                  video.loop = true;
                  video.setAttribute("muted", "");
                  video.setAttribute("playsinline", "");
                  video.setAttribute("webkit-playsinline", "");
                  video.preload = preferLite ? "metadata" : "auto";
                  if (preferLite) {
                    video.setAttribute("data-lite", "true");
                  }
                  video.addEventListener("loadeddata", () => {
                    if (bgVideo !== video) return;
                    if (video.dataset.userReady !== "1" || document.hidden)
                      return;
                    playBackgroundVideo(video.dataset.wantSound === "1");
                  });
                  bgEl.appendChild(video);
                  bgVideo = video;
                  needsGate = true;
                  if (!visibilityHandlerAdded) {
                    document.addEventListener("visibilitychange", () => {
                      if (!document.hidden && !gateActive && bgVideo) {
                        playBackgroundVideo(bgVideo.dataset.wantSound === "1");
                      }
                    });
                    visibilityHandlerAdded = true;
                  }
                } else {
                  const img = document.createElement("img");
                  img.src = bgUrlNext;
                  img.alt = "Background";
                  img.loading = "lazy";
                  img.decoding = "async";
                  bgEl.appendChild(img);
                }
              }
            }
          }
          if (bgEl) {
            bgEl.classList.remove("night", "rain", "snow");
            if (data.background_effect && data.background_effect !== "none") {
              bgEl.classList.add(data.background_effect);
            }
          }

          // Audio (Song hat Vorrang vor Video-Ton)
          if (audioChanged) {
            if (bgAudio) {
              try {
                bgAudio.pause();
              } catch {}
              if (audioCleanup) {
                audioCleanup();
                audioCleanup = null;
              }
              bgAudio.remove();
              bgAudio = null;
            }
          }
          syncAudioUI();
          if (audioPlayer) {
            applyAudioPlayerStyles(data);
            audioPlayer.classList.toggle("hidden", !showAudioPlayer);
          }
          if (audioIcon) {
            if (songIconUrlNext) {
              const abs = (() => {
                try {
                  return new URL(songIconUrlNext, window.location.origin).href;
                } catch (_) {
                  return songIconUrlNext;
                }
              })();
              if (audioIcon.src !== abs) audioIcon.src = songIconUrlNext;
              audioIcon.classList.remove("hidden");
            } else {
              audioIcon.removeAttribute("src");
              audioIcon.classList.add("hidden");
            }
          }
          if (showAudioPlayer && audioTitle) {
            const songName = (data.song_name || "").trim();
            const title =
              stripFileExtension(songName) || getAudioTitle(songUrlNext);
            audioTitle.style.display = "";
            audioTitle.textContent = title || "Audio";
          }
          if (songUrlNext) {
            if (!bgAudio) {
              bgAudio = document.createElement("audio");
              bgAudio.src = songUrlNext;
              bgAudio.loop = true;
              bgAudio.preload = preferLite ? "metadata" : "auto";
              bgAudio.muted = true; // Autoplay-friendly start, gate will unmute
              document.body.appendChild(bgAudio);
              bgAudio.play().catch(() => {});
              audioCleanup = bindAudioPlayer(bgAudio);
              syncAudioUI();
            }
            needsGate = true;
            if (soundBtn) soundBtn.classList.remove("hidden"); // Button zeigen - Nutzer kann unmute'n
          } else if (bgIsVideoNext && bgVideo) {
            // Kein Song -> Videoton anbieten
            if (soundBtn) soundBtn.classList.remove("hidden");
          } else {
            if (soundBtn) soundBtn.classList.add("hidden"); // nichts abzuspielen
          }
          if (bgVideo && songUrlNext) {
            bgVideo.muted = true;
          }
          const hasVideo = bgChanged ? bgIsVideoNext : !!bgVideo;
          const hasAudio = audioChanged ? !!songUrlNext : !!bgAudio;
          needsGate = needsGate || hasVideo || hasAudio;
          if (bgChanged || audioChanged) {
            if (needsGate && !gateDismissed) {
              showGate(true);
            } else {
              showGate(false);
            }
            soundOn = false;
            updateSoundUI();
          }
          lastMediaSig = mediaSig;
          lastBgSig = bgSig;
          lastAudioSig = audioSig;
          lastCursorSig = cursorSig;

          const layoutMode = (data.layout_mode || "center")
            .toString()
            .toLowerCase();
          const wantsWide =
            !isMobile && !usedCanvas && (layoutMode === "wide" || hasSideBySide);
          const cardEl = document.getElementById("card");
          if (cardEl) {
            cardEl.classList.toggle("wide", wantsWide);
            const raw = Number(data.transparency);
            const clamped = Number.isFinite(raw)
              ? Math.min(100, Math.max(0, raw))
              : 0;
            const cardAlpha = 1 - clamped / 100;
            const cardHex =
              sanitizeHexColor(data.card_color) || DEFAULT_CARD_COLOR;
            const cardBg =
              hexToRgba(cardHex, cardAlpha) || `rgba(23, 27, 59, ${cardAlpha})`;

            if (cardAlpha <= 0) {
              cardEl.classList.add("transparent");
              cardEl.style.background = "";
            } else {
              cardEl.classList.remove("transparent");
              cardEl.style.background = cardBg;
            }
          }
          applyTextColors(data);
          applyQuoteEffectStrength(data);
          applyLinkStyles(
            data.link_color,
            data.link_bg_color,
            data.link_bg_alpha,
          );
          applyLinkLayout(data, { isMobile, wantsWide });
          const cursorFxHex =
            sanitizeHexColor(data.cursor_effect_color) ||
            sanitizeHexColor(data.link_color) ||
            sanitizeHexColor(data.name_color) ||
            DEFAULT_AUDIO_ACCENT_COLOR;
          const rawCursorFxAlpha = data.cursor_effect_alpha;
          const cursorFxAlpha =
            rawCursorFxAlpha === undefined || rawCursorFxAlpha === null
              ? 70
              : Number(rawCursorFxAlpha);
          setCursorFxSettings({ color: cursorFxHex, alpha: cursorFxAlpha });
          setCursorFxOffset(cursorUrl && !isMobile ? CURSOR_IMAGE_SIZE / 2 : 0);
          applyCursorEffect(data.cursor_effect || "none", { isMobile });

          if (cursorUrl && !isMobile) {
            const shouldResize =
              !cursorFxImage || cursorFxImageSrc !== cursorUrl;
            if (shouldResize) {
              resizeCursorImage(cursorUrl, CURSOR_IMAGE_SIZE)
                .then((resized) => {
                  const cursorDecl = `url("${resized}") 0 0, auto`;
                  document.documentElement.style.setProperty(
                    "--cursor",
                    cursorDecl,
                  );
                  cursorFxImage = resized;
                  cursorFxImageSrc = cursorUrl;
                  setCursorGlowImage(resized, CURSOR_IMAGE_SIZE);
                })
                .catch(() => {
                  document.documentElement.style.setProperty(
                    "--cursor",
                    "auto",
                  );
                  setCursorGlowImage("");
                });
            } else {
              const cursorDecl = `url("${cursorFxImage}") 0 0, auto`;
              document.documentElement.style.setProperty(
                "--cursor",
                cursorDecl,
              );
              setCursorGlowImage(cursorFxImage, CURSOR_IMAGE_SIZE);
            }
          } else {
            document.documentElement.style.setProperty("--cursor", "auto");
            setCursorGlowImage("");
          }

          // Profil/Badges/Links wie gehabt
          const pfp = document.getElementById("pfp");
          const pfpFrame = document.getElementById("pfpFrame");
          if (pfp) {
            const prefersUserPfp =
              data.is_template_demo &&
              currentUser &&
              currentUser.profile_picture;
            const linktreePfp = safeMediaUrl(data.linktree_profile_picture);
            const primaryPfp = prefersUserPfp
              ? currentUser.profile_picture
              : linktreePfp || data.profile_picture;
            const profileUrl =
              safeMediaUrl(
                primaryPfp,
              ) ||
              safeMediaUrl(currentUser && currentUser.profile_picture) ||
              "/static/icon.png";
            pfp.src = profileUrl;
          }
          if (pfpFrame) {
            const frameUrl = safeMediaUrl(data.discord_decoration_url);
            if (data.discord_frame_enabled && frameUrl) {
              pfpFrame.src = frameUrl;
              pfpFrame.style.display = "block";
            } else {
              pfpFrame.style.display = "none";
            }
          }
          const presence = normalizePresence(data.discord_presence);
          const presenceLabel = PRESENCE_LABELS[presence] || "Online";
          const presenceEl = document.getElementById("discordPresence");
          const statusLine = document.getElementById("discordStatusLine");
          const statusTextEl = document.getElementById("discordStatusText");
          const discordLinked = !!data.discord_linked;
          if (presenceEl) {
            const showPresence = discordLinked && data.discord_presence_enabled;
            presenceEl.classList.toggle("hidden", !showPresence);
            applyPresenceClass(presenceEl, presence);
            presenceEl.setAttribute(
              "aria-label",
              `Discord status: ${presenceLabel}`,
            );
          }
          if (statusLine && statusTextEl) {
            const showStatus = discordLinked && data.discord_status_enabled;
            statusLine.classList.toggle("hidden", !showStatus);
            if (showStatus) {
              applyPresenceClass(statusLine, presence);
              const statusText = (data.discord_status_text || "").trim();
              statusTextEl.textContent = statusText || presenceLabel;
            } else {
              statusTextEl.textContent = "";
            }
          }
          const enterTextEl = document.getElementById("enterText");
            if (enterTextEl) {
              const entryText = (data.entry_text || "").trim();
              enterTextEl.textContent = entryText || "Click to enter";
            enterTextEl.classList.remove(
              "glow",
              "neon",
              "rainbow",
              "font-serif",
              "font-mono",
              "font-script",
              "font-display",
            );
            const entryFx = (data.entry_effect || "none").toString().toLowerCase();
            if (entryFx && entryFx !== "none") {
              enterTextEl.classList.add(entryFx);
            }
            const entryFont = (data.entry_font_family || "default")
              .toString()
              .toLowerCase();
            if (entryFont && entryFont !== "default") {
              enterTextEl.classList.add(`font-${entryFont}`);
            }
            const entrySize = Number(data.entry_font_size);
            if (Number.isFinite(entrySize) && entrySize > 0) {
              const clamped = Math.min(40, Math.max(10, entrySize));
              enterTextEl.style.fontSize = `${clamped}px`;
            } else {
              enterTextEl.style.removeProperty("font-size");
            }
            const entryColor =
              sanitizeHexColor(data.entry_text_color) || DEFAULT_ENTRY_TEXT_COLOR;
              if (entryColor) {
                enterTextEl.style.color = entryColor;
              } else {
                enterTextEl.style.removeProperty("color");
              }
            }
            const enterGate = document.getElementById("enterOverlay");
            if (enterGate) {
              const rawOverlayAlpha = Number(data.entry_overlay_alpha);
              const overlayAlpha = Number.isFinite(rawOverlayAlpha)
                ? Math.min(100, Math.max(0, rawOverlayAlpha))
                : DEFAULT_ENTRY_OVERLAY_ALPHA;
              enterGate.style.background = `rgba(0, 0, 0, ${
                overlayAlpha / 100
              })`;
            }
            const enterBox = document.querySelector(".enter-box");
            if (enterBox) {
              const boxEnabled =
                data.entry_box_enabled !== undefined && data.entry_box_enabled !== null
                  ? !!data.entry_box_enabled
                  : true;
              const borderEnabled =
                data.entry_border_enabled !== undefined &&
                data.entry_border_enabled !== null
                  ? !!data.entry_border_enabled
                  : true;
              const rawAlpha = Number(data.entry_bg_alpha);
              const alpha = Number.isFinite(rawAlpha)
                ? Math.min(100, Math.max(0, rawAlpha))
                : DEFAULT_ENTRY_BG_ALPHA;
              if (!boxEnabled) {
                enterBox.style.background = "transparent";
                enterBox.style.border = "none";
                enterBox.style.boxShadow = "none";
                enterBox.style.padding = "0";
                enterBox.style.minWidth = "auto";
              } else {
                const bg =
                  hexToRgba(DEFAULT_ENTRY_BG_COLOR, alpha / 100) ||
                  hexToRgba(DEFAULT_ENTRY_BG_COLOR, DEFAULT_ENTRY_BG_ALPHA / 100);
                if (bg) {
                  enterBox.style.background = bg;
                } else {
                  enterBox.style.removeProperty("background");
                }
                enterBox.style.removeProperty("box-shadow");
                enterBox.style.removeProperty("padding");
                enterBox.style.removeProperty("min-width");
                if (!borderEnabled) {
                  enterBox.style.border = "none";
                } else {
                  const borderColor = sanitizeHexColor(data.entry_border_color);
                  if (borderColor) {
                    enterBox.style.border = `1px solid ${borderColor}`;
                  } else {
                    enterBox.style.removeProperty("border");
                    enterBox.style.removeProperty("border-color");
                  }
                }
              }
            }
          applyNameStyles(data);
          applyQuoteStyles(data);
          const hasQuote = updateQuoteDisplay(data);
          const quoteEl = document.getElementById("quote");
          if (quoteEl) {
            quoteEl.classList.toggle("hidden", !hasQuote);
          }
          const locEl = document.getElementById("loc");
          if (locEl) {
            locEl.textContent = "";
            const locText =
              typeof data.location === "string" ? data.location.trim() : "";
            locEl.classList.toggle("hidden", !locText);
            if (locText) {
              const icon = createLocationIcon();
              const text = document.createElement("span");
              text.textContent = ` ${locText}`;
              locEl.appendChild(icon);
              locEl.appendChild(text);
            }
          }

          const badgesEl = document.getElementById("badges");
          if (badgesEl) {
            badgesEl.innerHTML = "";
            const frag = document.createDocumentFragment();
            let badgeCount = 0;
            (data.icons || []).forEach((ic) => {
              if (!ic.displayed) return;

              const desc = ic.description || ic.code || "badge";
              const wrap = document.createElement("span");
              wrap.className = "badge";
              // Tooltip via title (Desktop) + aria-label (AT / Touch-Langdruck zeigt oft auch title)
              wrap.title = desc;
              wrap.setAttribute("aria-label", desc);

              const img = document.createElement("img");
              const iconUrl = safeMediaUrl(ic.image_url);
              if (!iconUrl) return;
              img.src = iconUrl;
              img.alt = desc;
              img.width = 20;
              img.height = 20;
              img.loading = "lazy";
              img.decoding = "async";

              wrap.appendChild(img);
              frag.appendChild(wrap);
              badgeCount += 1;
            });

            if (discordLinked && data.discord_badges_enabled) {
              let discordList = Array.isArray(data.discord_badges)
                ? data.discord_badges
                : [];
              const filterCodes = Array.isArray(data.discord_badge_codes)
                ? data.discord_badge_codes
                : null;
              if (filterCodes) {
                discordList = discordList.filter((b) =>
                  filterCodes.includes(b && b.code),
                );
              }
              discordList.forEach((badge) => {
                if (!badge) return;
                const desc = badge.label || badge.code || "badge";
                const wrap = document.createElement("span");
                wrap.className = "badge";
                wrap.title = desc;
                wrap.setAttribute("aria-label", desc);

                const img = document.createElement("img");
                const iconUrl = safeMediaUrl(badge.icon_url);
                if (!iconUrl) return;
                img.src = iconUrl;
                img.alt = desc;
                img.width = 20;
                img.height = 20;
                img.loading = "lazy";
                img.decoding = "async";

                wrap.appendChild(img);
                frag.appendChild(wrap);
                badgeCount += 1;
              });
            }
            badgesEl.appendChild(frag);
            badgesEl.classList.toggle("hidden", badgeCount === 0);
          }
          const linksEl = document.getElementById("links");
          if (linksEl) {
            linksEl.textContent = "";
            const frag = document.createDocumentFragment();
            const rawLinks = Array.isArray(data.links) ? data.links : [];
            let linkItems = rawLinks;
            if (data.is_template_demo && data.demo_show_links) {
              const label =
                (data.demo_link_label || "").trim() || "Example Link";
              let url = (data.demo_link_url || "").trim();
              if (!url) url = "https://example.com";
              const iconUrl = (data.demo_link_icon_url || "").trim() || null;
              const demoLink = {
                label,
                url,
                icon_url: iconUrl,
                is_active: true,
              };
              linkItems = rawLinks.length ? rawLinks : [demoLink];
            }
            const iconsOnly = !!data.link_icons_only;
            linksEl.classList.toggle("icons-only", iconsOnly);
            let linkCount = 0;
            (linkItems || []).forEach((l) => {
              if (!l.is_active) return;
              const href = safeLinkUrl(l.url);
              if (!href) return;
              const a = document.createElement("a");
              a.className = "link";
              a.href = href;
              a.target = "_blank";
              a.rel = "noreferrer noopener";
              const labelText = (l.label || l.url || "").trim();
              if (labelText) {
                a.dataset.label = labelText;
                a.setAttribute("aria-label", labelText);
              } else {
                a.dataset.label = "";
              }
              const hoverTarget = (l.url || href || "").trim();
              const hoverText = iconsOnly ? hoverTarget || labelText : labelText || "";
              a.dataset.tooltip = hoverText;
              if (hoverText) a.title = hoverText;
              const iconUrl = safeMediaUrl(l.icon_url);
              if (iconUrl) {
                const img = document.createElement("img");
                img.src = iconUrl;
                img.alt = "";
                img.loading = "lazy";
                img.decoding = "async";
                a.appendChild(img);
              } else if (iconsOnly) {
                a.classList.add("no-icon");
              }
              const span = document.createElement("span");
              span.textContent = labelText || l.url;
              if (iconsOnly && iconUrl) span.classList.add("sr-only");
              a.appendChild(span);
              frag.appendChild(a);
              linkCount += 1;
            });
            linksEl.appendChild(frag);
            linksEl.classList.toggle("hidden", linkCount === 0);
          }

          const visitBox = document.getElementById("visitCounter");
          const visitValue = document.getElementById("visitCounterValue");
          if (visitBox && visitValue) {
            if (data.show_visit_counter) {
              visitValue.textContent = Number(
                data.visit_count || 0,
              ).toLocaleString();
              const textColor =
                hexToRgba(data.visit_counter_color, 1) ||
                hexToRgba(data.text_color, 1) ||
                null;
              if (textColor) visitBox.style.color = textColor;
              const bgAlpha = Number.isFinite(
                Number(data.visit_counter_bg_alpha),
              )
                ? Number(data.visit_counter_bg_alpha)
                : 20;
              const bgColor =
                hexToRgba(
                  data.visit_counter_bg_color || "#ffffff",
                  Math.min(1, Math.max(0, bgAlpha / 100)),
                ) || "rgba(255,255,255,0.14)";
              visitBox.style.backgroundColor = bgColor;
              visitBox.style.display = "inline-flex";
            } else {
              visitBox.style.display = "none";
            }
          }
        }

        async function loadTree() {
          try {
            linktreeId = null;
            const user = await fetchSessionUser();
            if (!user) {
              showEditorMessage("Please log in to edit your canvas.", false);
              return;
            }
            currentUser = user;
            const slugParam = slugFromQuery();
            const slug =
              slugParam ||
              String(user.linktree_slug || "").trim() ||
              String(user.username || "").trim().toLowerCase();
            if (!slug) {
              showEditorMessage("Missing slug.", false);
              return;
            }
            const deviceParam = deviceFromQuery();
            currentDevice = deviceParam || currentDevice || "pc";
            const deviceSelect = document.getElementById("inDevice");
            if (deviceSelect) deviceSelect.value = currentDevice;
            canvasDirty = false;
            metaDirtyFields = new Set();
            discordBadgeCodes = null;
            canvasLayout = null;
            let data = await apiLoadTreeOwnerBySlug(slug, currentDevice);
            if (!data && currentDevice === "mobile") {
              try {
                data = await apiCloneVariant(slug, "mobile");
                showEditorMessage("Mobile version created from desktop.", true);
              } catch (_) {
                showEditorMessage("Create mobile copy failed.", false);
              }
            }
            if (!data) {
              linktreeId = null;
              showEditorMessage("No linktree found for this slug.", false);
              return;
            }
            linktreeId = data.id;
            renderTree(data, {
              preferLite: shouldUseLiteMedia(),
              device: currentDevice,
            });
            showEditorMessage("Canvas ready.", true);
          } catch (e) {
            console.error("loadTree failed:", e);
            showEditorMessage("Failed to load canvas.", false);
          }
        }

        const connection =
          navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection;
        const prefersReducedData =
          typeof window.matchMedia === "function"
            ? window.matchMedia("(prefers-reduced-data: reduce)")
            : null;

        function handleMediaPreferenceChange() {
          if (!lastData) return;
          const preferLite = shouldUseLiteMedia();
          if ((preferLite ? "lite" : "full") === lastMediaMode) return;
          renderTree(lastData, {
            preferLite,
            fromCache: true,
            device: lastDevice || detectDevice(),
          });
        }

        if (connection && connection.addEventListener) {
          connection.addEventListener("change", handleMediaPreferenceChange);
        }
        if (prefersReducedData && prefersReducedData.addEventListener) {
          prefersReducedData.addEventListener(
            "change",
            handleMediaPreferenceChange,
          );
        } else if (prefersReducedData && prefersReducedData.addListener) {
          prefersReducedData.addListener(handleMediaPreferenceChange);
        }

        window.addEventListener("message", async (evt) => {
          if (evt && evt.data && evt.data.type === "discord-linked") {
            await loadDiscordStatusIntoData();
            showEditorMessage("Discord linked", true);
          }
        });

        bindInspectorEvents();
        loadTree();
        document.addEventListener("DOMContentLoaded", () => {
          console.log("Page loaded (HTML ready)");
        });
      })();
    </script>
  </body>
</html>
